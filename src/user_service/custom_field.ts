// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: user_service/custom_field.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  ProfileSection,
  profileSectionFromJSON,
  profileSectionToJSON,
  profileSectionToNumber,
} from "../organization_service/organization_profile_settings";
import { ObjectId } from "../utils/object_id";
import { UserType, userTypeFromJSON, userTypeToJSON, userTypeToNumber } from "../utils/user_type";
import { StudentStatus, studentStatusFromJSON, studentStatusToJSON, studentStatusToNumber } from "./student";

export const protobufPackage = "user_service";

/** Custom field type enum */
export enum CustomFieldType {
  STRING = "STRING",
  SELECT = "SELECT",
  ADDRESS = "ADDRESS",
  DATE = "DATE",
  REGEX_VALIDATED = "REGEX_VALIDATED",
  CHECKBOX = "CHECKBOX",
  DOCUMENT = "DOCUMENT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function customFieldTypeFromJSON(object: any): CustomFieldType {
  switch (object) {
    case 0:
    case "STRING":
      return CustomFieldType.STRING;
    case 1:
    case "SELECT":
      return CustomFieldType.SELECT;
    case 2:
    case "ADDRESS":
      return CustomFieldType.ADDRESS;
    case 3:
    case "DATE":
      return CustomFieldType.DATE;
    case 4:
    case "REGEX_VALIDATED":
      return CustomFieldType.REGEX_VALIDATED;
    case 5:
    case "CHECKBOX":
      return CustomFieldType.CHECKBOX;
    case 6:
    case "DOCUMENT":
      return CustomFieldType.DOCUMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomFieldType.UNRECOGNIZED;
  }
}

export function customFieldTypeToJSON(object: CustomFieldType): string {
  switch (object) {
    case CustomFieldType.STRING:
      return "STRING";
    case CustomFieldType.SELECT:
      return "SELECT";
    case CustomFieldType.ADDRESS:
      return "ADDRESS";
    case CustomFieldType.DATE:
      return "DATE";
    case CustomFieldType.REGEX_VALIDATED:
      return "REGEX_VALIDATED";
    case CustomFieldType.CHECKBOX:
      return "CHECKBOX";
    case CustomFieldType.DOCUMENT:
      return "DOCUMENT";
    case CustomFieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function customFieldTypeToNumber(object: CustomFieldType): number {
  switch (object) {
    case CustomFieldType.STRING:
      return 0;
    case CustomFieldType.SELECT:
      return 1;
    case CustomFieldType.ADDRESS:
      return 2;
    case CustomFieldType.DATE:
      return 3;
    case CustomFieldType.REGEX_VALIDATED:
      return 4;
    case CustomFieldType.CHECKBOX:
      return 5;
    case CustomFieldType.DOCUMENT:
      return 6;
    case CustomFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Approval status enum for group approval workflow */
export enum ApprovalStatus {
  APPROVAL_STATUS_REQUIRED_TO_FILL = "APPROVAL_STATUS_REQUIRED_TO_FILL",
  APPROVAL_STATUS_PENDING_REVIEW = "APPROVAL_STATUS_PENDING_REVIEW",
  APPROVAL_STATUS_APPROVED = "APPROVAL_STATUS_APPROVED",
  APPROVAL_STATUS_REJECTED = "APPROVAL_STATUS_REJECTED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function approvalStatusFromJSON(object: any): ApprovalStatus {
  switch (object) {
    case 0:
    case "APPROVAL_STATUS_REQUIRED_TO_FILL":
      return ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL;
    case 1:
    case "APPROVAL_STATUS_PENDING_REVIEW":
      return ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW;
    case 2:
    case "APPROVAL_STATUS_APPROVED":
      return ApprovalStatus.APPROVAL_STATUS_APPROVED;
    case 3:
    case "APPROVAL_STATUS_REJECTED":
      return ApprovalStatus.APPROVAL_STATUS_REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApprovalStatus.UNRECOGNIZED;
  }
}

export function approvalStatusToJSON(object: ApprovalStatus): string {
  switch (object) {
    case ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL:
      return "APPROVAL_STATUS_REQUIRED_TO_FILL";
    case ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW:
      return "APPROVAL_STATUS_PENDING_REVIEW";
    case ApprovalStatus.APPROVAL_STATUS_APPROVED:
      return "APPROVAL_STATUS_APPROVED";
    case ApprovalStatus.APPROVAL_STATUS_REJECTED:
      return "APPROVAL_STATUS_REJECTED";
    case ApprovalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function approvalStatusToNumber(object: ApprovalStatus): number {
  switch (object) {
    case ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL:
      return 0;
    case ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW:
      return 1;
    case ApprovalStatus.APPROVAL_STATUS_APPROVED:
      return 2;
    case ApprovalStatus.APPROVAL_STATUS_REJECTED:
      return 3;
    case ApprovalStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Custom field definition */
export interface CustomField {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  groupId: ObjectId | undefined;
  name: string;
  fieldType: CustomFieldType;
  userType: UserType;
  isRequired: boolean;
  description: string;
  regexPattern?: string | undefined;
  options: string[];
  isArchived: boolean;
}

/** Custom fields group */
export interface CustomFieldsGroup {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  groupName: string;
  userType: UserType;
  profileSection: ProfileSection;
  hints: string[];
  groupAccessSettings: ObjectId | undefined;
  entriesAccessSettings:
    | ObjectId
    | undefined;
  /** these fields are only for custom field groups for user type: Student */
  visibleToParentsForStatuses: StudentStatus[];
  visibleToTeachersForStatuses: StudentStatus[];
}

/** Group approval status (approval workflow for custom field groups) */
export interface GroupApprovalStatus {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  groupId: ObjectId | undefined;
  userId: ObjectId | undefined;
  status: ApprovalStatus;
  rejectionMessage?: string | undefined;
}

export interface StudentPrimaryIdField {
  fieldName: string;
  value: string;
}

/** Custom fields group with its associated custom fields */
export interface CustomFieldsGroupWithFields {
  group: CustomFieldsGroup | undefined;
  fields: CustomField[];
}

function createBaseCustomField(): CustomField {
  return {
    id: undefined,
    organization: undefined,
    groupId: undefined,
    name: "",
    fieldType: CustomFieldType.STRING,
    userType: UserType.NONE,
    isRequired: false,
    description: "",
    regexPattern: "",
    options: [],
    isArchived: false,
  };
}

export const CustomField: MessageFns<CustomField> = {
  encode(message: CustomField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.groupId !== undefined) {
      ObjectId.encode(message.groupId, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.fieldType !== CustomFieldType.STRING) {
      writer.uint32(40).int32(customFieldTypeToNumber(message.fieldType));
    }
    if (message.userType !== UserType.NONE) {
      writer.uint32(48).int32(userTypeToNumber(message.userType));
    }
    if (message.isRequired !== false) {
      writer.uint32(56).bool(message.isRequired);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.regexPattern !== undefined && message.regexPattern !== "") {
      writer.uint32(74).string(message.regexPattern);
    }
    for (const v of message.options) {
      writer.uint32(82).string(v!);
    }
    if (message.isArchived !== false) {
      writer.uint32(88).bool(message.isArchived);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fieldType = customFieldTypeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.userType = userTypeFromJSON(reader.int32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isRequired = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.regexPattern = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.options.push(reader.string());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isArchived = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomField {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      groupId: isSet(object.groupId) ? ObjectId.fromJSON(object.groupId) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fieldType: isSet(object.fieldType) ? customFieldTypeFromJSON(object.fieldType) : CustomFieldType.STRING,
      userType: isSet(object.userType) ? userTypeFromJSON(object.userType) : UserType.NONE,
      isRequired: isSet(object.isRequired) ? globalThis.Boolean(object.isRequired) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      regexPattern: isSet(object.regexPattern) ? globalThis.String(object.regexPattern) : "",
      options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
      isArchived: isSet(object.isArchived) ? globalThis.Boolean(object.isArchived) : false,
    };
  },

  toJSON(message: CustomField): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.groupId !== undefined) {
      obj.groupId = ObjectId.toJSON(message.groupId);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fieldType !== CustomFieldType.STRING) {
      obj.fieldType = customFieldTypeToJSON(message.fieldType);
    }
    if (message.userType !== UserType.NONE) {
      obj.userType = userTypeToJSON(message.userType);
    }
    if (message.isRequired !== false) {
      obj.isRequired = message.isRequired;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.regexPattern !== undefined && message.regexPattern !== "") {
      obj.regexPattern = message.regexPattern;
    }
    if (message.options?.length) {
      obj.options = message.options;
    }
    if (message.isArchived !== false) {
      obj.isArchived = message.isArchived;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomField>, I>>(base?: I): CustomField {
    return CustomField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomField>, I>>(object: I): CustomField {
    const message = createBaseCustomField();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.groupId = (object.groupId !== undefined && object.groupId !== null)
      ? ObjectId.fromPartial(object.groupId)
      : undefined;
    message.name = object.name ?? "";
    message.fieldType = object.fieldType ?? CustomFieldType.STRING;
    message.userType = object.userType ?? UserType.NONE;
    message.isRequired = object.isRequired ?? false;
    message.description = object.description ?? "";
    message.regexPattern = object.regexPattern ?? "";
    message.options = object.options?.map((e) => e) || [];
    message.isArchived = object.isArchived ?? false;
    return message;
  },
};

function createBaseCustomFieldsGroup(): CustomFieldsGroup {
  return {
    id: undefined,
    organization: undefined,
    groupName: "",
    userType: UserType.NONE,
    profileSection: ProfileSection.OVERVIEW,
    hints: [],
    groupAccessSettings: undefined,
    entriesAccessSettings: undefined,
    visibleToParentsForStatuses: [],
    visibleToTeachersForStatuses: [],
  };
}

export const CustomFieldsGroup: MessageFns<CustomFieldsGroup> = {
  encode(message: CustomFieldsGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.groupName !== "") {
      writer.uint32(26).string(message.groupName);
    }
    if (message.userType !== UserType.NONE) {
      writer.uint32(32).int32(userTypeToNumber(message.userType));
    }
    if (message.profileSection !== ProfileSection.OVERVIEW) {
      writer.uint32(40).int32(profileSectionToNumber(message.profileSection));
    }
    for (const v of message.hints) {
      writer.uint32(50).string(v!);
    }
    if (message.groupAccessSettings !== undefined) {
      ObjectId.encode(message.groupAccessSettings, writer.uint32(58).fork()).join();
    }
    if (message.entriesAccessSettings !== undefined) {
      ObjectId.encode(message.entriesAccessSettings, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.visibleToParentsForStatuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    writer.uint32(82).fork();
    for (const v of message.visibleToTeachersForStatuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFieldsGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFieldsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.userType = userTypeFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.profileSection = profileSectionFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hints.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.groupAccessSettings = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entriesAccessSettings = ObjectId.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.visibleToParentsForStatuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visibleToParentsForStatuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 10:
          if (tag === 80) {
            message.visibleToTeachersForStatuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visibleToTeachersForStatuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFieldsGroup {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      userType: isSet(object.userType) ? userTypeFromJSON(object.userType) : UserType.NONE,
      profileSection: isSet(object.profileSection)
        ? profileSectionFromJSON(object.profileSection)
        : ProfileSection.OVERVIEW,
      hints: globalThis.Array.isArray(object?.hints) ? object.hints.map((e: any) => globalThis.String(e)) : [],
      groupAccessSettings: isSet(object.groupAccessSettings)
        ? ObjectId.fromJSON(object.groupAccessSettings)
        : undefined,
      entriesAccessSettings: isSet(object.entriesAccessSettings)
        ? ObjectId.fromJSON(object.entriesAccessSettings)
        : undefined,
      visibleToParentsForStatuses: globalThis.Array.isArray(object?.visibleToParentsForStatuses)
        ? object.visibleToParentsForStatuses.map((e: any) => studentStatusFromJSON(e))
        : [],
      visibleToTeachersForStatuses: globalThis.Array.isArray(object?.visibleToTeachersForStatuses)
        ? object.visibleToTeachersForStatuses.map((e: any) => studentStatusFromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomFieldsGroup): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.userType !== UserType.NONE) {
      obj.userType = userTypeToJSON(message.userType);
    }
    if (message.profileSection !== ProfileSection.OVERVIEW) {
      obj.profileSection = profileSectionToJSON(message.profileSection);
    }
    if (message.hints?.length) {
      obj.hints = message.hints;
    }
    if (message.groupAccessSettings !== undefined) {
      obj.groupAccessSettings = ObjectId.toJSON(message.groupAccessSettings);
    }
    if (message.entriesAccessSettings !== undefined) {
      obj.entriesAccessSettings = ObjectId.toJSON(message.entriesAccessSettings);
    }
    if (message.visibleToParentsForStatuses?.length) {
      obj.visibleToParentsForStatuses = message.visibleToParentsForStatuses.map((e) => studentStatusToJSON(e));
    }
    if (message.visibleToTeachersForStatuses?.length) {
      obj.visibleToTeachersForStatuses = message.visibleToTeachersForStatuses.map((e) => studentStatusToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFieldsGroup>, I>>(base?: I): CustomFieldsGroup {
    return CustomFieldsGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFieldsGroup>, I>>(object: I): CustomFieldsGroup {
    const message = createBaseCustomFieldsGroup();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.groupName = object.groupName ?? "";
    message.userType = object.userType ?? UserType.NONE;
    message.profileSection = object.profileSection ?? ProfileSection.OVERVIEW;
    message.hints = object.hints?.map((e) => e) || [];
    message.groupAccessSettings = (object.groupAccessSettings !== undefined && object.groupAccessSettings !== null)
      ? ObjectId.fromPartial(object.groupAccessSettings)
      : undefined;
    message.entriesAccessSettings =
      (object.entriesAccessSettings !== undefined && object.entriesAccessSettings !== null)
        ? ObjectId.fromPartial(object.entriesAccessSettings)
        : undefined;
    message.visibleToParentsForStatuses = object.visibleToParentsForStatuses?.map((e) => e) || [];
    message.visibleToTeachersForStatuses = object.visibleToTeachersForStatuses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGroupApprovalStatus(): GroupApprovalStatus {
  return {
    id: undefined,
    organization: undefined,
    groupId: undefined,
    userId: undefined,
    status: ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL,
    rejectionMessage: "",
  };
}

export const GroupApprovalStatus: MessageFns<GroupApprovalStatus> = {
  encode(message: GroupApprovalStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.groupId !== undefined) {
      ObjectId.encode(message.groupId, writer.uint32(26).fork()).join();
    }
    if (message.userId !== undefined) {
      ObjectId.encode(message.userId, writer.uint32(34).fork()).join();
    }
    if (message.status !== ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL) {
      writer.uint32(40).int32(approvalStatusToNumber(message.status));
    }
    if (message.rejectionMessage !== undefined && message.rejectionMessage !== "") {
      writer.uint32(50).string(message.rejectionMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupApprovalStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupApprovalStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = approvalStatusFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rejectionMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupApprovalStatus {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      groupId: isSet(object.groupId) ? ObjectId.fromJSON(object.groupId) : undefined,
      userId: isSet(object.userId) ? ObjectId.fromJSON(object.userId) : undefined,
      status: isSet(object.status)
        ? approvalStatusFromJSON(object.status)
        : ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL,
      rejectionMessage: isSet(object.rejectionMessage) ? globalThis.String(object.rejectionMessage) : "",
    };
  },

  toJSON(message: GroupApprovalStatus): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.groupId !== undefined) {
      obj.groupId = ObjectId.toJSON(message.groupId);
    }
    if (message.userId !== undefined) {
      obj.userId = ObjectId.toJSON(message.userId);
    }
    if (message.status !== ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL) {
      obj.status = approvalStatusToJSON(message.status);
    }
    if (message.rejectionMessage !== undefined && message.rejectionMessage !== "") {
      obj.rejectionMessage = message.rejectionMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupApprovalStatus>, I>>(base?: I): GroupApprovalStatus {
    return GroupApprovalStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupApprovalStatus>, I>>(object: I): GroupApprovalStatus {
    const message = createBaseGroupApprovalStatus();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.groupId = (object.groupId !== undefined && object.groupId !== null)
      ? ObjectId.fromPartial(object.groupId)
      : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? ObjectId.fromPartial(object.userId)
      : undefined;
    message.status = object.status ?? ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL;
    message.rejectionMessage = object.rejectionMessage ?? "";
    return message;
  },
};

function createBaseStudentPrimaryIdField(): StudentPrimaryIdField {
  return { fieldName: "", value: "" };
}

export const StudentPrimaryIdField: MessageFns<StudentPrimaryIdField> = {
  encode(message: StudentPrimaryIdField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentPrimaryIdField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentPrimaryIdField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentPrimaryIdField {
    return {
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StudentPrimaryIdField): unknown {
    const obj: any = {};
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentPrimaryIdField>, I>>(base?: I): StudentPrimaryIdField {
    return StudentPrimaryIdField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentPrimaryIdField>, I>>(object: I): StudentPrimaryIdField {
    const message = createBaseStudentPrimaryIdField();
    message.fieldName = object.fieldName ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomFieldsGroupWithFields(): CustomFieldsGroupWithFields {
  return { group: undefined, fields: [] };
}

export const CustomFieldsGroupWithFields: MessageFns<CustomFieldsGroupWithFields> = {
  encode(message: CustomFieldsGroupWithFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      CustomFieldsGroup.encode(message.group, writer.uint32(10).fork()).join();
    }
    for (const v of message.fields) {
      CustomField.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFieldsGroupWithFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFieldsGroupWithFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustomFieldsGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(CustomField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFieldsGroupWithFields {
    return {
      group: isSet(object.group) ? CustomFieldsGroup.fromJSON(object.group) : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => CustomField.fromJSON(e)) : [],
    };
  },

  toJSON(message: CustomFieldsGroupWithFields): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustomFieldsGroup.toJSON(message.group);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => CustomField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFieldsGroupWithFields>, I>>(base?: I): CustomFieldsGroupWithFields {
    return CustomFieldsGroupWithFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFieldsGroupWithFields>, I>>(object: I): CustomFieldsGroupWithFields {
    const message = createBaseCustomFieldsGroupWithFields();
    message.group = (object.group !== undefined && object.group !== null)
      ? CustomFieldsGroup.fromPartial(object.group)
      : undefined;
    message.fields = object.fields?.map((e) => CustomField.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

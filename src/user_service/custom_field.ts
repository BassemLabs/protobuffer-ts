// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: user_service/custom_field.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  ProfileSection,
  profileSectionFromJSON,
  profileSectionToJSON,
  profileSectionToNumber,
} from "../organization_service/organization_profile_settings";
import { ObjectId } from "../utils/object_id";
import { UserType, userTypeFromJSON, userTypeToJSON, userTypeToNumber } from "../utils/user_type";
import { StudentStatus, studentStatusFromJSON, studentStatusToJSON, studentStatusToNumber } from "./student";

export const protobufPackage = "user_service";

/** Custom field type enum */
export enum CustomFieldType {
  STRING = "STRING",
  SELECT = "SELECT",
  ADDRESS = "ADDRESS",
  DATE = "DATE",
  REGEX_VALIDATED = "REGEX_VALIDATED",
  CHECKBOX = "CHECKBOX",
  DOCUMENT = "DOCUMENT",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function customFieldTypeFromJSON(object: any): CustomFieldType {
  switch (object) {
    case 0:
    case "STRING":
      return CustomFieldType.STRING;
    case 1:
    case "SELECT":
      return CustomFieldType.SELECT;
    case 2:
    case "ADDRESS":
      return CustomFieldType.ADDRESS;
    case 3:
    case "DATE":
      return CustomFieldType.DATE;
    case 4:
    case "REGEX_VALIDATED":
      return CustomFieldType.REGEX_VALIDATED;
    case 5:
    case "CHECKBOX":
      return CustomFieldType.CHECKBOX;
    case 6:
    case "DOCUMENT":
      return CustomFieldType.DOCUMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CustomFieldType.UNRECOGNIZED;
  }
}

export function customFieldTypeToJSON(object: CustomFieldType): string {
  switch (object) {
    case CustomFieldType.STRING:
      return "STRING";
    case CustomFieldType.SELECT:
      return "SELECT";
    case CustomFieldType.ADDRESS:
      return "ADDRESS";
    case CustomFieldType.DATE:
      return "DATE";
    case CustomFieldType.REGEX_VALIDATED:
      return "REGEX_VALIDATED";
    case CustomFieldType.CHECKBOX:
      return "CHECKBOX";
    case CustomFieldType.DOCUMENT:
      return "DOCUMENT";
    case CustomFieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function customFieldTypeToNumber(object: CustomFieldType): number {
  switch (object) {
    case CustomFieldType.STRING:
      return 0;
    case CustomFieldType.SELECT:
      return 1;
    case CustomFieldType.ADDRESS:
      return 2;
    case CustomFieldType.DATE:
      return 3;
    case CustomFieldType.REGEX_VALIDATED:
      return 4;
    case CustomFieldType.CHECKBOX:
      return 5;
    case CustomFieldType.DOCUMENT:
      return 6;
    case CustomFieldType.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Approval status enum for group approval workflow */
export enum ApprovalStatus {
  APPROVAL_STATUS_REQUIRED_TO_FILL = "APPROVAL_STATUS_REQUIRED_TO_FILL",
  APPROVAL_STATUS_PENDING_REVIEW = "APPROVAL_STATUS_PENDING_REVIEW",
  APPROVAL_STATUS_APPROVED = "APPROVAL_STATUS_APPROVED",
  APPROVAL_STATUS_REJECTED = "APPROVAL_STATUS_REJECTED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function approvalStatusFromJSON(object: any): ApprovalStatus {
  switch (object) {
    case 0:
    case "APPROVAL_STATUS_REQUIRED_TO_FILL":
      return ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL;
    case 1:
    case "APPROVAL_STATUS_PENDING_REVIEW":
      return ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW;
    case 2:
    case "APPROVAL_STATUS_APPROVED":
      return ApprovalStatus.APPROVAL_STATUS_APPROVED;
    case 3:
    case "APPROVAL_STATUS_REJECTED":
      return ApprovalStatus.APPROVAL_STATUS_REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApprovalStatus.UNRECOGNIZED;
  }
}

export function approvalStatusToJSON(object: ApprovalStatus): string {
  switch (object) {
    case ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL:
      return "APPROVAL_STATUS_REQUIRED_TO_FILL";
    case ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW:
      return "APPROVAL_STATUS_PENDING_REVIEW";
    case ApprovalStatus.APPROVAL_STATUS_APPROVED:
      return "APPROVAL_STATUS_APPROVED";
    case ApprovalStatus.APPROVAL_STATUS_REJECTED:
      return "APPROVAL_STATUS_REJECTED";
    case ApprovalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function approvalStatusToNumber(object: ApprovalStatus): number {
  switch (object) {
    case ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL:
      return 0;
    case ApprovalStatus.APPROVAL_STATUS_PENDING_REVIEW:
      return 1;
    case ApprovalStatus.APPROVAL_STATUS_APPROVED:
      return 2;
    case ApprovalStatus.APPROVAL_STATUS_REJECTED:
      return 3;
    case ApprovalStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

/** Custom field definition */
export interface CustomField {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  group_id: ObjectId | undefined;
  name: string;
  field_type: CustomFieldType;
  user_type: UserType;
  is_required: boolean;
  description: string;
  regex_pattern?: string | undefined;
  options: string[];
  is_archived: boolean;
}

/** Custom fields group */
export interface CustomFieldsGroup {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  group_name: string;
  user_type: UserType;
  profile_section: ProfileSection;
  hints: string[];
  group_access_settings: ObjectId | undefined;
  entries_access_settings:
    | ObjectId
    | undefined;
  /** these fields are only for custom field groups for user type: Student */
  visible_to_parents_for_statuses: StudentStatus[];
  visible_to_teachers_for_statuses: StudentStatus[];
}

/** Group approval status (approval workflow for custom field groups) */
export interface GroupApprovalStatus {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  group_id: ObjectId | undefined;
  user_id: ObjectId | undefined;
  status: ApprovalStatus;
  rejection_message?: string | undefined;
}

export interface StudentPrimaryIdField {
  field_name: string;
  value: string;
}

/** Custom fields group with its associated custom fields */
export interface CustomFieldsGroupWithFields {
  group: CustomFieldsGroup | undefined;
  fields: CustomField[];
}

function createBaseCustomField(): CustomField {
  return {
    id: undefined,
    organization: undefined,
    group_id: undefined,
    name: "",
    field_type: CustomFieldType.STRING,
    user_type: UserType.NONE,
    is_required: false,
    description: "",
    regex_pattern: "",
    options: [],
    is_archived: false,
  };
}

export const CustomField: MessageFns<CustomField> = {
  encode(message: CustomField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.group_id !== undefined) {
      ObjectId.encode(message.group_id, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.field_type !== CustomFieldType.STRING) {
      writer.uint32(40).int32(customFieldTypeToNumber(message.field_type));
    }
    if (message.user_type !== UserType.NONE) {
      writer.uint32(48).int32(userTypeToNumber(message.user_type));
    }
    if (message.is_required !== false) {
      writer.uint32(56).bool(message.is_required);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.regex_pattern !== undefined && message.regex_pattern !== "") {
      writer.uint32(74).string(message.regex_pattern);
    }
    for (const v of message.options) {
      writer.uint32(82).string(v!);
    }
    if (message.is_archived !== false) {
      writer.uint32(88).bool(message.is_archived);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.field_type = customFieldTypeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.user_type = userTypeFromJSON(reader.int32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.is_required = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.regex_pattern = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.options.push(reader.string());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.is_archived = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomField {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      group_id: isSet(object.group_id) ? ObjectId.fromJSON(object.group_id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      field_type: isSet(object.field_type) ? customFieldTypeFromJSON(object.field_type) : CustomFieldType.STRING,
      user_type: isSet(object.user_type) ? userTypeFromJSON(object.user_type) : UserType.NONE,
      is_required: isSet(object.is_required) ? globalThis.Boolean(object.is_required) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      regex_pattern: isSet(object.regex_pattern) ? globalThis.String(object.regex_pattern) : "",
      options: globalThis.Array.isArray(object?.options) ? object.options.map((e: any) => globalThis.String(e)) : [],
      is_archived: isSet(object.is_archived) ? globalThis.Boolean(object.is_archived) : false,
    };
  },

  toJSON(message: CustomField): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.group_id !== undefined) {
      obj.group_id = ObjectId.toJSON(message.group_id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.field_type !== CustomFieldType.STRING) {
      obj.field_type = customFieldTypeToJSON(message.field_type);
    }
    if (message.user_type !== UserType.NONE) {
      obj.user_type = userTypeToJSON(message.user_type);
    }
    if (message.is_required !== false) {
      obj.is_required = message.is_required;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.regex_pattern !== undefined && message.regex_pattern !== "") {
      obj.regex_pattern = message.regex_pattern;
    }
    if (message.options?.length) {
      obj.options = message.options;
    }
    if (message.is_archived !== false) {
      obj.is_archived = message.is_archived;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomField>, I>>(base?: I): CustomField {
    return CustomField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomField>, I>>(object: I): CustomField {
    const message = createBaseCustomField();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.group_id = (object.group_id !== undefined && object.group_id !== null)
      ? ObjectId.fromPartial(object.group_id)
      : undefined;
    message.name = object.name ?? "";
    message.field_type = object.field_type ?? CustomFieldType.STRING;
    message.user_type = object.user_type ?? UserType.NONE;
    message.is_required = object.is_required ?? false;
    message.description = object.description ?? "";
    message.regex_pattern = object.regex_pattern ?? "";
    message.options = object.options?.map((e) => e) || [];
    message.is_archived = object.is_archived ?? false;
    return message;
  },
};

function createBaseCustomFieldsGroup(): CustomFieldsGroup {
  return {
    id: undefined,
    organization: undefined,
    group_name: "",
    user_type: UserType.NONE,
    profile_section: ProfileSection.OVERVIEW,
    hints: [],
    group_access_settings: undefined,
    entries_access_settings: undefined,
    visible_to_parents_for_statuses: [],
    visible_to_teachers_for_statuses: [],
  };
}

export const CustomFieldsGroup: MessageFns<CustomFieldsGroup> = {
  encode(message: CustomFieldsGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.group_name !== "") {
      writer.uint32(26).string(message.group_name);
    }
    if (message.user_type !== UserType.NONE) {
      writer.uint32(32).int32(userTypeToNumber(message.user_type));
    }
    if (message.profile_section !== ProfileSection.OVERVIEW) {
      writer.uint32(40).int32(profileSectionToNumber(message.profile_section));
    }
    for (const v of message.hints) {
      writer.uint32(50).string(v!);
    }
    if (message.group_access_settings !== undefined) {
      ObjectId.encode(message.group_access_settings, writer.uint32(58).fork()).join();
    }
    if (message.entries_access_settings !== undefined) {
      ObjectId.encode(message.entries_access_settings, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.visible_to_parents_for_statuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    writer.uint32(82).fork();
    for (const v of message.visible_to_teachers_for_statuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFieldsGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFieldsGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group_name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.user_type = userTypeFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.profile_section = profileSectionFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hints.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.group_access_settings = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entries_access_settings = ObjectId.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.visible_to_parents_for_statuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visible_to_parents_for_statuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 10:
          if (tag === 80) {
            message.visible_to_teachers_for_statuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.visible_to_teachers_for_statuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFieldsGroup {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      group_name: isSet(object.group_name) ? globalThis.String(object.group_name) : "",
      user_type: isSet(object.user_type) ? userTypeFromJSON(object.user_type) : UserType.NONE,
      profile_section: isSet(object.profile_section)
        ? profileSectionFromJSON(object.profile_section)
        : ProfileSection.OVERVIEW,
      hints: globalThis.Array.isArray(object?.hints) ? object.hints.map((e: any) => globalThis.String(e)) : [],
      group_access_settings: isSet(object.group_access_settings)
        ? ObjectId.fromJSON(object.group_access_settings)
        : undefined,
      entries_access_settings: isSet(object.entries_access_settings)
        ? ObjectId.fromJSON(object.entries_access_settings)
        : undefined,
      visible_to_parents_for_statuses: globalThis.Array.isArray(object?.visible_to_parents_for_statuses)
        ? object.visible_to_parents_for_statuses.map((e: any) => studentStatusFromJSON(e))
        : [],
      visible_to_teachers_for_statuses: globalThis.Array.isArray(object?.visible_to_teachers_for_statuses)
        ? object.visible_to_teachers_for_statuses.map((e: any) => studentStatusFromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomFieldsGroup): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.group_name !== "") {
      obj.group_name = message.group_name;
    }
    if (message.user_type !== UserType.NONE) {
      obj.user_type = userTypeToJSON(message.user_type);
    }
    if (message.profile_section !== ProfileSection.OVERVIEW) {
      obj.profile_section = profileSectionToJSON(message.profile_section);
    }
    if (message.hints?.length) {
      obj.hints = message.hints;
    }
    if (message.group_access_settings !== undefined) {
      obj.group_access_settings = ObjectId.toJSON(message.group_access_settings);
    }
    if (message.entries_access_settings !== undefined) {
      obj.entries_access_settings = ObjectId.toJSON(message.entries_access_settings);
    }
    if (message.visible_to_parents_for_statuses?.length) {
      obj.visible_to_parents_for_statuses = message.visible_to_parents_for_statuses.map((e) => studentStatusToJSON(e));
    }
    if (message.visible_to_teachers_for_statuses?.length) {
      obj.visible_to_teachers_for_statuses = message.visible_to_teachers_for_statuses.map((e) =>
        studentStatusToJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFieldsGroup>, I>>(base?: I): CustomFieldsGroup {
    return CustomFieldsGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFieldsGroup>, I>>(object: I): CustomFieldsGroup {
    const message = createBaseCustomFieldsGroup();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.group_name = object.group_name ?? "";
    message.user_type = object.user_type ?? UserType.NONE;
    message.profile_section = object.profile_section ?? ProfileSection.OVERVIEW;
    message.hints = object.hints?.map((e) => e) || [];
    message.group_access_settings =
      (object.group_access_settings !== undefined && object.group_access_settings !== null)
        ? ObjectId.fromPartial(object.group_access_settings)
        : undefined;
    message.entries_access_settings =
      (object.entries_access_settings !== undefined && object.entries_access_settings !== null)
        ? ObjectId.fromPartial(object.entries_access_settings)
        : undefined;
    message.visible_to_parents_for_statuses = object.visible_to_parents_for_statuses?.map((e) => e) || [];
    message.visible_to_teachers_for_statuses = object.visible_to_teachers_for_statuses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGroupApprovalStatus(): GroupApprovalStatus {
  return {
    id: undefined,
    organization: undefined,
    group_id: undefined,
    user_id: undefined,
    status: ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL,
    rejection_message: "",
  };
}

export const GroupApprovalStatus: MessageFns<GroupApprovalStatus> = {
  encode(message: GroupApprovalStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.group_id !== undefined) {
      ObjectId.encode(message.group_id, writer.uint32(26).fork()).join();
    }
    if (message.user_id !== undefined) {
      ObjectId.encode(message.user_id, writer.uint32(34).fork()).join();
    }
    if (message.status !== ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL) {
      writer.uint32(40).int32(approvalStatusToNumber(message.status));
    }
    if (message.rejection_message !== undefined && message.rejection_message !== "") {
      writer.uint32(50).string(message.rejection_message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupApprovalStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupApprovalStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = approvalStatusFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rejection_message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupApprovalStatus {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      group_id: isSet(object.group_id) ? ObjectId.fromJSON(object.group_id) : undefined,
      user_id: isSet(object.user_id) ? ObjectId.fromJSON(object.user_id) : undefined,
      status: isSet(object.status)
        ? approvalStatusFromJSON(object.status)
        : ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL,
      rejection_message: isSet(object.rejection_message) ? globalThis.String(object.rejection_message) : "",
    };
  },

  toJSON(message: GroupApprovalStatus): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.group_id !== undefined) {
      obj.group_id = ObjectId.toJSON(message.group_id);
    }
    if (message.user_id !== undefined) {
      obj.user_id = ObjectId.toJSON(message.user_id);
    }
    if (message.status !== ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL) {
      obj.status = approvalStatusToJSON(message.status);
    }
    if (message.rejection_message !== undefined && message.rejection_message !== "") {
      obj.rejection_message = message.rejection_message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupApprovalStatus>, I>>(base?: I): GroupApprovalStatus {
    return GroupApprovalStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupApprovalStatus>, I>>(object: I): GroupApprovalStatus {
    const message = createBaseGroupApprovalStatus();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.group_id = (object.group_id !== undefined && object.group_id !== null)
      ? ObjectId.fromPartial(object.group_id)
      : undefined;
    message.user_id = (object.user_id !== undefined && object.user_id !== null)
      ? ObjectId.fromPartial(object.user_id)
      : undefined;
    message.status = object.status ?? ApprovalStatus.APPROVAL_STATUS_REQUIRED_TO_FILL;
    message.rejection_message = object.rejection_message ?? "";
    return message;
  },
};

function createBaseStudentPrimaryIdField(): StudentPrimaryIdField {
  return { field_name: "", value: "" };
}

export const StudentPrimaryIdField: MessageFns<StudentPrimaryIdField> = {
  encode(message: StudentPrimaryIdField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field_name !== "") {
      writer.uint32(10).string(message.field_name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentPrimaryIdField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentPrimaryIdField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field_name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentPrimaryIdField {
    return {
      field_name: isSet(object.field_name) ? globalThis.String(object.field_name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StudentPrimaryIdField): unknown {
    const obj: any = {};
    if (message.field_name !== "") {
      obj.field_name = message.field_name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentPrimaryIdField>, I>>(base?: I): StudentPrimaryIdField {
    return StudentPrimaryIdField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentPrimaryIdField>, I>>(object: I): StudentPrimaryIdField {
    const message = createBaseStudentPrimaryIdField();
    message.field_name = object.field_name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomFieldsGroupWithFields(): CustomFieldsGroupWithFields {
  return { group: undefined, fields: [] };
}

export const CustomFieldsGroupWithFields: MessageFns<CustomFieldsGroupWithFields> = {
  encode(message: CustomFieldsGroupWithFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      CustomFieldsGroup.encode(message.group, writer.uint32(10).fork()).join();
    }
    for (const v of message.fields) {
      CustomField.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomFieldsGroupWithFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomFieldsGroupWithFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustomFieldsGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(CustomField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomFieldsGroupWithFields {
    return {
      group: isSet(object.group) ? CustomFieldsGroup.fromJSON(object.group) : undefined,
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => CustomField.fromJSON(e)) : [],
    };
  },

  toJSON(message: CustomFieldsGroupWithFields): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustomFieldsGroup.toJSON(message.group);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => CustomField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomFieldsGroupWithFields>, I>>(base?: I): CustomFieldsGroupWithFields {
    return CustomFieldsGroupWithFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomFieldsGroupWithFields>, I>>(object: I): CustomFieldsGroupWithFields {
    const message = createBaseCustomFieldsGroupWithFields();
    message.group = (object.group !== undefined && object.group !== null)
      ? CustomFieldsGroup.fromPartial(object.group)
      : undefined;
    message.fields = object.fields?.map((e) => CustomField.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

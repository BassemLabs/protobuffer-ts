// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: user_service/resource_access_settings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ObjectId } from "../utils/object_id";
import { UserType, userTypeFromJSON, userTypeToJSON, userTypeToNumber } from "../utils/user_type";
import { UserRole, userRoleFromJSON, userRoleToJSON, userRoleToNumber } from "./user_role";

export const protobufPackage = "user_service";

export enum OwnershipKind {
  OWNED = "OWNED",
  UNOWNED = "UNOWNED",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function ownershipKindFromJSON(object: any): OwnershipKind {
  switch (object) {
    case 0:
    case "OWNED":
      return OwnershipKind.OWNED;
    case 1:
    case "UNOWNED":
      return OwnershipKind.UNOWNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OwnershipKind.UNRECOGNIZED;
  }
}

export function ownershipKindToJSON(object: OwnershipKind): string {
  switch (object) {
    case OwnershipKind.OWNED:
      return "OWNED";
    case OwnershipKind.UNOWNED:
      return "UNOWNED";
    case OwnershipKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function ownershipKindToNumber(object: OwnershipKind): number {
  switch (object) {
    case OwnershipKind.OWNED:
      return 0;
    case OwnershipKind.UNOWNED:
      return 1;
    case OwnershipKind.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum PrincipalType {
  USER = "USER",
  FAMILY = "FAMILY",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function principalTypeFromJSON(object: any): PrincipalType {
  switch (object) {
    case 0:
    case "USER":
      return PrincipalType.USER;
    case 1:
    case "FAMILY":
      return PrincipalType.FAMILY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrincipalType.UNRECOGNIZED;
  }
}

export function principalTypeToJSON(object: PrincipalType): string {
  switch (object) {
    case PrincipalType.USER:
      return "USER";
    case PrincipalType.FAMILY:
      return "FAMILY";
    case PrincipalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function principalTypeToNumber(object: PrincipalType): number {
  switch (object) {
    case PrincipalType.USER:
      return 0;
    case PrincipalType.FAMILY:
      return 1;
    case PrincipalType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum AccessPermissionType {
  ALLOW_READ = "ALLOW_READ",
  ALLOW_WRITE = "ALLOW_WRITE",
  DENY_READ = "DENY_READ",
  DENY_WRITE = "DENY_WRITE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function accessPermissionTypeFromJSON(object: any): AccessPermissionType {
  switch (object) {
    case 0:
    case "ALLOW_READ":
      return AccessPermissionType.ALLOW_READ;
    case 1:
    case "ALLOW_WRITE":
      return AccessPermissionType.ALLOW_WRITE;
    case 2:
    case "DENY_READ":
      return AccessPermissionType.DENY_READ;
    case 3:
    case "DENY_WRITE":
      return AccessPermissionType.DENY_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessPermissionType.UNRECOGNIZED;
  }
}

export function accessPermissionTypeToJSON(object: AccessPermissionType): string {
  switch (object) {
    case AccessPermissionType.ALLOW_READ:
      return "ALLOW_READ";
    case AccessPermissionType.ALLOW_WRITE:
      return "ALLOW_WRITE";
    case AccessPermissionType.DENY_READ:
      return "DENY_READ";
    case AccessPermissionType.DENY_WRITE:
      return "DENY_WRITE";
    case AccessPermissionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function accessPermissionTypeToNumber(object: AccessPermissionType): number {
  switch (object) {
    case AccessPermissionType.ALLOW_READ:
      return 0;
    case AccessPermissionType.ALLOW_WRITE:
      return 1;
    case AccessPermissionType.DENY_READ:
      return 2;
    case AccessPermissionType.DENY_WRITE:
      return 3;
    case AccessPermissionType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum WildcardAccessType {
  ALL_PRINCIPALS = "ALL_PRINCIPALS",
  ALL_TEACHER_PRINCIPALS = "ALL_TEACHER_PRINCIPALS",
  ALL_PARENT_PRINCIPALS = "ALL_PARENT_PRINCIPALS",
  ALL_STUDENT_PRINCIPALS = "ALL_STUDENT_PRINCIPALS",
  ROLE = "ROLE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function wildcardAccessTypeFromJSON(object: any): WildcardAccessType {
  switch (object) {
    case 0:
    case "ALL_PRINCIPALS":
      return WildcardAccessType.ALL_PRINCIPALS;
    case 1:
    case "ALL_TEACHER_PRINCIPALS":
      return WildcardAccessType.ALL_TEACHER_PRINCIPALS;
    case 2:
    case "ALL_PARENT_PRINCIPALS":
      return WildcardAccessType.ALL_PARENT_PRINCIPALS;
    case 3:
    case "ALL_STUDENT_PRINCIPALS":
      return WildcardAccessType.ALL_STUDENT_PRINCIPALS;
    case 4:
    case "ROLE":
      return WildcardAccessType.ROLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WildcardAccessType.UNRECOGNIZED;
  }
}

export function wildcardAccessTypeToJSON(object: WildcardAccessType): string {
  switch (object) {
    case WildcardAccessType.ALL_PRINCIPALS:
      return "ALL_PRINCIPALS";
    case WildcardAccessType.ALL_TEACHER_PRINCIPALS:
      return "ALL_TEACHER_PRINCIPALS";
    case WildcardAccessType.ALL_PARENT_PRINCIPALS:
      return "ALL_PARENT_PRINCIPALS";
    case WildcardAccessType.ALL_STUDENT_PRINCIPALS:
      return "ALL_STUDENT_PRINCIPALS";
    case WildcardAccessType.ROLE:
      return "ROLE";
    case WildcardAccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function wildcardAccessTypeToNumber(object: WildcardAccessType): number {
  switch (object) {
    case WildcardAccessType.ALL_PRINCIPALS:
      return 0;
    case WildcardAccessType.ALL_TEACHER_PRINCIPALS:
      return 1;
    case WildcardAccessType.ALL_PARENT_PRINCIPALS:
      return 2;
    case WildcardAccessType.ALL_STUDENT_PRINCIPALS:
      return 3;
    case WildcardAccessType.ROLE:
      return 4;
    case WildcardAccessType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface ResourceAccessSettings {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  name: string;
  ownershipKind: OwnershipKind;
  userType: UserType;
  accessRules: AccessRule[];
}

export interface AccessRule {
  permissionType: AccessPermissionType;
  principal?: PrincipalType | undefined;
  wildcard?: WildcardAccess | undefined;
}

export interface WildcardAccess {
  type: WildcardAccessType;
  /** Only used when type is ROLE */
  role?: UserRole | undefined;
}

function createBaseResourceAccessSettings(): ResourceAccessSettings {
  return {
    id: undefined,
    organization: undefined,
    name: "",
    ownershipKind: OwnershipKind.OWNED,
    userType: UserType.NONE,
    accessRules: [],
  };
}

export const ResourceAccessSettings: MessageFns<ResourceAccessSettings> = {
  encode(message: ResourceAccessSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.ownershipKind !== OwnershipKind.OWNED) {
      writer.uint32(32).int32(ownershipKindToNumber(message.ownershipKind));
    }
    if (message.userType !== UserType.NONE) {
      writer.uint32(40).int32(userTypeToNumber(message.userType));
    }
    for (const v of message.accessRules) {
      AccessRule.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceAccessSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAccessSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ownershipKind = ownershipKindFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.userType = userTypeFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.accessRules.push(AccessRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceAccessSettings {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ownershipKind: isSet(object.ownershipKind) ? ownershipKindFromJSON(object.ownershipKind) : OwnershipKind.OWNED,
      userType: isSet(object.userType) ? userTypeFromJSON(object.userType) : UserType.NONE,
      accessRules: globalThis.Array.isArray(object?.accessRules)
        ? object.accessRules.map((e: any) => AccessRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResourceAccessSettings): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ownershipKind !== OwnershipKind.OWNED) {
      obj.ownershipKind = ownershipKindToJSON(message.ownershipKind);
    }
    if (message.userType !== UserType.NONE) {
      obj.userType = userTypeToJSON(message.userType);
    }
    if (message.accessRules?.length) {
      obj.accessRules = message.accessRules.map((e) => AccessRule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceAccessSettings>, I>>(base?: I): ResourceAccessSettings {
    return ResourceAccessSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceAccessSettings>, I>>(object: I): ResourceAccessSettings {
    const message = createBaseResourceAccessSettings();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.name = object.name ?? "";
    message.ownershipKind = object.ownershipKind ?? OwnershipKind.OWNED;
    message.userType = object.userType ?? UserType.NONE;
    message.accessRules = object.accessRules?.map((e) => AccessRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAccessRule(): AccessRule {
  return { permissionType: AccessPermissionType.ALLOW_READ, principal: PrincipalType.USER, wildcard: undefined };
}

export const AccessRule: MessageFns<AccessRule> = {
  encode(message: AccessRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.permissionType !== AccessPermissionType.ALLOW_READ) {
      writer.uint32(8).int32(accessPermissionTypeToNumber(message.permissionType));
    }
    if (message.principal !== undefined && message.principal !== PrincipalType.USER) {
      writer.uint32(16).int32(principalTypeToNumber(message.principal));
    }
    if (message.wildcard !== undefined) {
      WildcardAccess.encode(message.wildcard, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.permissionType = accessPermissionTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.principal = principalTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.wildcard = WildcardAccess.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessRule {
    return {
      permissionType: isSet(object.permissionType)
        ? accessPermissionTypeFromJSON(object.permissionType)
        : AccessPermissionType.ALLOW_READ,
      principal: isSet(object.principal) ? principalTypeFromJSON(object.principal) : PrincipalType.USER,
      wildcard: isSet(object.wildcard) ? WildcardAccess.fromJSON(object.wildcard) : undefined,
    };
  },

  toJSON(message: AccessRule): unknown {
    const obj: any = {};
    if (message.permissionType !== AccessPermissionType.ALLOW_READ) {
      obj.permissionType = accessPermissionTypeToJSON(message.permissionType);
    }
    if (message.principal !== undefined && message.principal !== PrincipalType.USER) {
      obj.principal = principalTypeToJSON(message.principal);
    }
    if (message.wildcard !== undefined) {
      obj.wildcard = WildcardAccess.toJSON(message.wildcard);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessRule>, I>>(base?: I): AccessRule {
    return AccessRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessRule>, I>>(object: I): AccessRule {
    const message = createBaseAccessRule();
    message.permissionType = object.permissionType ?? AccessPermissionType.ALLOW_READ;
    message.principal = object.principal ?? PrincipalType.USER;
    message.wildcard = (object.wildcard !== undefined && object.wildcard !== null)
      ? WildcardAccess.fromPartial(object.wildcard)
      : undefined;
    return message;
  },
};

function createBaseWildcardAccess(): WildcardAccess {
  return { type: WildcardAccessType.ALL_PRINCIPALS, role: UserRole.DEVELOPER };
}

export const WildcardAccess: MessageFns<WildcardAccess> = {
  encode(message: WildcardAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== WildcardAccessType.ALL_PRINCIPALS) {
      writer.uint32(8).int32(wildcardAccessTypeToNumber(message.type));
    }
    if (message.role !== undefined && message.role !== UserRole.DEVELOPER) {
      writer.uint32(16).int32(userRoleToNumber(message.role));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WildcardAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWildcardAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = wildcardAccessTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = userRoleFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WildcardAccess {
    return {
      type: isSet(object.type) ? wildcardAccessTypeFromJSON(object.type) : WildcardAccessType.ALL_PRINCIPALS,
      role: isSet(object.role) ? userRoleFromJSON(object.role) : UserRole.DEVELOPER,
    };
  },

  toJSON(message: WildcardAccess): unknown {
    const obj: any = {};
    if (message.type !== WildcardAccessType.ALL_PRINCIPALS) {
      obj.type = wildcardAccessTypeToJSON(message.type);
    }
    if (message.role !== undefined && message.role !== UserRole.DEVELOPER) {
      obj.role = userRoleToJSON(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WildcardAccess>, I>>(base?: I): WildcardAccess {
    return WildcardAccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WildcardAccess>, I>>(object: I): WildcardAccess {
    const message = createBaseWildcardAccess();
    message.type = object.type ?? WildcardAccessType.ALL_PRINCIPALS;
    message.role = object.role ?? UserRole.DEVELOPER;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

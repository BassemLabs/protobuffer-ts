// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: class_service/gclass.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { DateTime } from "../utils/datetime";
import { ObjectId } from "../utils/object_id";

export const protobufPackage = "class_service";

export enum States {
  STATES_CREATED = 0,
  STATES_NEW = 1,
  STATES_RECLAIMED_BY_STUDENT = 2,
  STATES_RETURNED = 3,
  STATES_SUBMISSION_STATE_UNSPECIFIED = 4,
  STATES_TURNED_IN = 5,
  STATES_NOOP = 6,
  STATES_FALLTHROUGH_STRING = 7,
  UNRECOGNIZED = -1,
}

export function statesFromJSON(object: any): States {
  switch (object) {
    case 0:
    case "STATES_CREATED":
      return States.STATES_CREATED;
    case 1:
    case "STATES_NEW":
      return States.STATES_NEW;
    case 2:
    case "STATES_RECLAIMED_BY_STUDENT":
      return States.STATES_RECLAIMED_BY_STUDENT;
    case 3:
    case "STATES_RETURNED":
      return States.STATES_RETURNED;
    case 4:
    case "STATES_SUBMISSION_STATE_UNSPECIFIED":
      return States.STATES_SUBMISSION_STATE_UNSPECIFIED;
    case 5:
    case "STATES_TURNED_IN":
      return States.STATES_TURNED_IN;
    case 6:
    case "STATES_NOOP":
      return States.STATES_NOOP;
    case 7:
    case "STATES_FALLTHROUGH_STRING":
      return States.STATES_FALLTHROUGH_STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return States.UNRECOGNIZED;
  }
}

export function statesToJSON(object: States): string {
  switch (object) {
    case States.STATES_CREATED:
      return "STATES_CREATED";
    case States.STATES_NEW:
      return "STATES_NEW";
    case States.STATES_RECLAIMED_BY_STUDENT:
      return "STATES_RECLAIMED_BY_STUDENT";
    case States.STATES_RETURNED:
      return "STATES_RETURNED";
    case States.STATES_SUBMISSION_STATE_UNSPECIFIED:
      return "STATES_SUBMISSION_STATE_UNSPECIFIED";
    case States.STATES_TURNED_IN:
      return "STATES_TURNED_IN";
    case States.STATES_NOOP:
      return "STATES_NOOP";
    case States.STATES_FALLTHROUGH_STRING:
      return "STATES_FALLTHROUGH_STRING";
    case States.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkType {
  WORKTYPE_ASSIGNMENT = 0,
  WORKTYPE_COURSE_WORK_TYPE_UNSPECIFIED = 1,
  WORKTYPE_MULTIPLE_CHOICE_QUESTION = 2,
  WORKTYPE_SHORT_ANSWER_QUESTION = 3,
  WORKTYPE_NOOP = 4,
  WORKTYPE_FALLTHROUGH_STRING = 5,
  UNRECOGNIZED = -1,
}

export function workTypeFromJSON(object: any): WorkType {
  switch (object) {
    case 0:
    case "WORKTYPE_ASSIGNMENT":
      return WorkType.WORKTYPE_ASSIGNMENT;
    case 1:
    case "WORKTYPE_COURSE_WORK_TYPE_UNSPECIFIED":
      return WorkType.WORKTYPE_COURSE_WORK_TYPE_UNSPECIFIED;
    case 2:
    case "WORKTYPE_MULTIPLE_CHOICE_QUESTION":
      return WorkType.WORKTYPE_MULTIPLE_CHOICE_QUESTION;
    case 3:
    case "WORKTYPE_SHORT_ANSWER_QUESTION":
      return WorkType.WORKTYPE_SHORT_ANSWER_QUESTION;
    case 4:
    case "WORKTYPE_NOOP":
      return WorkType.WORKTYPE_NOOP;
    case 5:
    case "WORKTYPE_FALLTHROUGH_STRING":
      return WorkType.WORKTYPE_FALLTHROUGH_STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkType.UNRECOGNIZED;
  }
}

export function workTypeToJSON(object: WorkType): string {
  switch (object) {
    case WorkType.WORKTYPE_ASSIGNMENT:
      return "WORKTYPE_ASSIGNMENT";
    case WorkType.WORKTYPE_COURSE_WORK_TYPE_UNSPECIFIED:
      return "WORKTYPE_COURSE_WORK_TYPE_UNSPECIFIED";
    case WorkType.WORKTYPE_MULTIPLE_CHOICE_QUESTION:
      return "WORKTYPE_MULTIPLE_CHOICE_QUESTION";
    case WorkType.WORKTYPE_SHORT_ANSWER_QUESTION:
      return "WORKTYPE_SHORT_ANSWER_QUESTION";
    case WorkType.WORKTYPE_NOOP:
      return "WORKTYPE_NOOP";
    case WorkType.WORKTYPE_FALLTHROUGH_STRING:
      return "WORKTYPE_FALLTHROUGH_STRING";
    case WorkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GradeChangeType {
  GRADE_CHANGE_ASSIGNED_GRADE_POINTS_EARNED = 0,
  GRADE_CHANGE_DRAFT_GRADE_POINTS_EARNED = 1,
  GRADE_CHANGE_MAX_POINTS = 2,
  GRADE_CHANGE_UNKNOWN = 3,
  GRADE_CHANGE_NOOP = 4,
  GRADE_CHANGE_FALLTHROUGH_STRING = 5,
  UNRECOGNIZED = -1,
}

export function gradeChangeTypeFromJSON(object: any): GradeChangeType {
  switch (object) {
    case 0:
    case "GRADE_CHANGE_ASSIGNED_GRADE_POINTS_EARNED":
      return GradeChangeType.GRADE_CHANGE_ASSIGNED_GRADE_POINTS_EARNED;
    case 1:
    case "GRADE_CHANGE_DRAFT_GRADE_POINTS_EARNED":
      return GradeChangeType.GRADE_CHANGE_DRAFT_GRADE_POINTS_EARNED;
    case 2:
    case "GRADE_CHANGE_MAX_POINTS":
      return GradeChangeType.GRADE_CHANGE_MAX_POINTS;
    case 3:
    case "GRADE_CHANGE_UNKNOWN":
      return GradeChangeType.GRADE_CHANGE_UNKNOWN;
    case 4:
    case "GRADE_CHANGE_NOOP":
      return GradeChangeType.GRADE_CHANGE_NOOP;
    case 5:
    case "GRADE_CHANGE_FALLTHROUGH_STRING":
      return GradeChangeType.GRADE_CHANGE_FALLTHROUGH_STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GradeChangeType.UNRECOGNIZED;
  }
}

export function gradeChangeTypeToJSON(object: GradeChangeType): string {
  switch (object) {
    case GradeChangeType.GRADE_CHANGE_ASSIGNED_GRADE_POINTS_EARNED:
      return "GRADE_CHANGE_ASSIGNED_GRADE_POINTS_EARNED";
    case GradeChangeType.GRADE_CHANGE_DRAFT_GRADE_POINTS_EARNED:
      return "GRADE_CHANGE_DRAFT_GRADE_POINTS_EARNED";
    case GradeChangeType.GRADE_CHANGE_MAX_POINTS:
      return "GRADE_CHANGE_MAX_POINTS";
    case GradeChangeType.GRADE_CHANGE_UNKNOWN:
      return "GRADE_CHANGE_UNKNOWN";
    case GradeChangeType.GRADE_CHANGE_NOOP:
      return "GRADE_CHANGE_NOOP";
    case GradeChangeType.GRADE_CHANGE_FALLTHROUGH_STRING:
      return "GRADE_CHANGE_FALLTHROUGH_STRING";
    case GradeChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StateHistory {
  HISTORY_CREATED = 0,
  HISTORY_RECLAIMED_BY_STUDENT = 1,
  HISTORY_RETURNED = 2,
  HISTORY_UNSPECIFIED = 3,
  HISTORY_STUDENT_EDITED_AFTER_TURN_IN = 4,
  HISTORY_TURNED_IN = 5,
  HISTORY_NOOP = 6,
  HISTORY_FALLTHROUGH_STRING = 7,
  UNRECOGNIZED = -1,
}

export function stateHistoryFromJSON(object: any): StateHistory {
  switch (object) {
    case 0:
    case "HISTORY_CREATED":
      return StateHistory.HISTORY_CREATED;
    case 1:
    case "HISTORY_RECLAIMED_BY_STUDENT":
      return StateHistory.HISTORY_RECLAIMED_BY_STUDENT;
    case 2:
    case "HISTORY_RETURNED":
      return StateHistory.HISTORY_RETURNED;
    case 3:
    case "HISTORY_UNSPECIFIED":
      return StateHistory.HISTORY_UNSPECIFIED;
    case 4:
    case "HISTORY_STUDENT_EDITED_AFTER_TURN_IN":
      return StateHistory.HISTORY_STUDENT_EDITED_AFTER_TURN_IN;
    case 5:
    case "HISTORY_TURNED_IN":
      return StateHistory.HISTORY_TURNED_IN;
    case 6:
    case "HISTORY_NOOP":
      return StateHistory.HISTORY_NOOP;
    case 7:
    case "HISTORY_FALLTHROUGH_STRING":
      return StateHistory.HISTORY_FALLTHROUGH_STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateHistory.UNRECOGNIZED;
  }
}

export function stateHistoryToJSON(object: StateHistory): string {
  switch (object) {
    case StateHistory.HISTORY_CREATED:
      return "HISTORY_CREATED";
    case StateHistory.HISTORY_RECLAIMED_BY_STUDENT:
      return "HISTORY_RECLAIMED_BY_STUDENT";
    case StateHistory.HISTORY_RETURNED:
      return "HISTORY_RETURNED";
    case StateHistory.HISTORY_UNSPECIFIED:
      return "HISTORY_UNSPECIFIED";
    case StateHistory.HISTORY_STUDENT_EDITED_AFTER_TURN_IN:
      return "HISTORY_STUDENT_EDITED_AFTER_TURN_IN";
    case StateHistory.HISTORY_TURNED_IN:
      return "HISTORY_TURNED_IN";
    case StateHistory.HISTORY_NOOP:
      return "HISTORY_NOOP";
    case StateHistory.HISTORY_FALLTHROUGH_STRING:
      return "HISTORY_FALLTHROUGH_STRING";
    case StateHistory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a GClass student submission */
export interface GClassStudentSubmission {
  gclassStudentSubmissionId: string;
  gclassCourseId: string;
  gclassCourseWorkId: string;
  gclassUserId: string;
  gclassLink: string;
  studentId: ObjectId | undefined;
  homeroomId?: ObjectId | undefined;
  courseId?: ObjectId | undefined;
  submissionState: States;
  workNotSubmittedAndLate: boolean;
  /** Assuming "number" means float/double in TS */
  assignedGrade: number;
  workType: WorkType;
  submissionHistory: SubmissionHistory[];
  assignmentSubmission?: AssignmentSubmission | undefined;
  shortAnswerSubmission?: ShortAnswerSubmission | undefined;
  multipleChoiceSubmission?: MultipleChoiceSubmission | undefined;
  rawJsonData: string;
}

/** Represents GClass course work */
export interface GClassCourseWork {
  gclassCourseWorkId: string;
  gclassCourseId: string;
  homeroomId?: ObjectId | undefined;
  courseId?: ObjectId | undefined;
  title: string;
  description: string;
  gclassLink: string;
  materials: Attachment[];
  /** Assuming ISO datetime format in TS */
  creationTime:
    | DateTime
    | undefined;
  /** Same here */
  dueDate: DateTime | undefined;
  workType: WorkType;
  rawJsonData: string;
}

/** Represents submission history */
export interface SubmissionHistory {
  gradeHistory?: GradeHistory | undefined;
  stateHistory?: StateHistoryData | undefined;
}

/** Represents grade history */
export interface GradeHistory {
  actorUserId: string;
  gradeChangeType?: GradeChangeType | undefined;
  gradeTimestamp?: DateTime | undefined;
  maxPoints: number;
  pointsEarned: number;
}

/** Represents state history data */
export interface StateHistoryData {
  actorUserId: string;
  state?: StateHistory | undefined;
  stateTimestamp?: DateTime | undefined;
}

/** Represents an assignment submission */
export interface AssignmentSubmission {
  attachments: Attachment[];
}

/** Represents a short answer submission */
export interface ShortAnswerSubmission {
  answer: string;
}

/** Represents a multiple-choice submission */
export interface MultipleChoiceSubmission {
  answer: string;
}

/** Represents an attachment */
export interface Attachment {
  driveFile?: DriveFile | undefined;
  form?: Form | undefined;
  link?: Link | undefined;
  youtubeVideo?: YouTubeVideo | undefined;
}

/** Represents a Google Drive file attachment */
export interface DriveFile {
  alternateLink: string;
  id: string;
  thumbnailUrl: string;
  title: string;
}

/** Represents a Google Form */
export interface Form {
  formUrl: string;
  responseUrl: string;
  thumbnailUrl: string;
  title: string;
}

/** Represents a link attachment */
export interface Link {
  thumbnailUrl: string;
  title: string;
  url: string;
}

/** Represents a YouTube video attachment */
export interface YouTubeVideo {
  alternateLink: string;
  id: string;
  thumbnailUrl: string;
  title: string;
}

function createBaseGClassStudentSubmission(): GClassStudentSubmission {
  return {
    gclassStudentSubmissionId: "",
    gclassCourseId: "",
    gclassCourseWorkId: "",
    gclassUserId: "",
    gclassLink: "",
    studentId: undefined,
    homeroomId: undefined,
    courseId: undefined,
    submissionState: 0,
    workNotSubmittedAndLate: false,
    assignedGrade: 0,
    workType: 0,
    submissionHistory: [],
    assignmentSubmission: undefined,
    shortAnswerSubmission: undefined,
    multipleChoiceSubmission: undefined,
    rawJsonData: "",
  };
}

export const GClassStudentSubmission: MessageFns<GClassStudentSubmission> = {
  encode(message: GClassStudentSubmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclassStudentSubmissionId !== "") {
      writer.uint32(10).string(message.gclassStudentSubmissionId);
    }
    if (message.gclassCourseId !== "") {
      writer.uint32(18).string(message.gclassCourseId);
    }
    if (message.gclassCourseWorkId !== "") {
      writer.uint32(26).string(message.gclassCourseWorkId);
    }
    if (message.gclassUserId !== "") {
      writer.uint32(34).string(message.gclassUserId);
    }
    if (message.gclassLink !== "") {
      writer.uint32(42).string(message.gclassLink);
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(50).fork()).join();
    }
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(58).fork()).join();
    }
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(66).fork()).join();
    }
    if (message.submissionState !== 0) {
      writer.uint32(72).int32(message.submissionState);
    }
    if (message.workNotSubmittedAndLate !== false) {
      writer.uint32(80).bool(message.workNotSubmittedAndLate);
    }
    if (message.assignedGrade !== 0) {
      writer.uint32(89).double(message.assignedGrade);
    }
    if (message.workType !== 0) {
      writer.uint32(96).int32(message.workType);
    }
    for (const v of message.submissionHistory) {
      SubmissionHistory.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.assignmentSubmission !== undefined) {
      AssignmentSubmission.encode(message.assignmentSubmission, writer.uint32(114).fork()).join();
    }
    if (message.shortAnswerSubmission !== undefined) {
      ShortAnswerSubmission.encode(message.shortAnswerSubmission, writer.uint32(122).fork()).join();
    }
    if (message.multipleChoiceSubmission !== undefined) {
      MultipleChoiceSubmission.encode(message.multipleChoiceSubmission, writer.uint32(130).fork()).join();
    }
    if (message.rawJsonData !== "") {
      writer.uint32(138).string(message.rawJsonData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GClassStudentSubmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGClassStudentSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gclassStudentSubmissionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gclassCourseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gclassCourseWorkId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gclassUserId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gclassLink = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.submissionState = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.workNotSubmittedAndLate = reader.bool();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.assignedGrade = reader.double();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.workType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.submissionHistory.push(SubmissionHistory.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assignmentSubmission = AssignmentSubmission.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.shortAnswerSubmission = ShortAnswerSubmission.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.multipleChoiceSubmission = MultipleChoiceSubmission.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.rawJsonData = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GClassStudentSubmission {
    return {
      gclassStudentSubmissionId: isSet(object.gclassStudentSubmissionId)
        ? globalThis.String(object.gclassStudentSubmissionId)
        : "",
      gclassCourseId: isSet(object.gclassCourseId) ? globalThis.String(object.gclassCourseId) : "",
      gclassCourseWorkId: isSet(object.gclassCourseWorkId) ? globalThis.String(object.gclassCourseWorkId) : "",
      gclassUserId: isSet(object.gclassUserId) ? globalThis.String(object.gclassUserId) : "",
      gclassLink: isSet(object.gclassLink) ? globalThis.String(object.gclassLink) : "",
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      submissionState: isSet(object.submissionState) ? statesFromJSON(object.submissionState) : 0,
      workNotSubmittedAndLate: isSet(object.workNotSubmittedAndLate)
        ? globalThis.Boolean(object.workNotSubmittedAndLate)
        : false,
      assignedGrade: isSet(object.assignedGrade) ? globalThis.Number(object.assignedGrade) : 0,
      workType: isSet(object.workType) ? workTypeFromJSON(object.workType) : 0,
      submissionHistory: globalThis.Array.isArray(object?.submissionHistory)
        ? object.submissionHistory.map((e: any) => SubmissionHistory.fromJSON(e))
        : [],
      assignmentSubmission: isSet(object.assignmentSubmission)
        ? AssignmentSubmission.fromJSON(object.assignmentSubmission)
        : undefined,
      shortAnswerSubmission: isSet(object.shortAnswerSubmission)
        ? ShortAnswerSubmission.fromJSON(object.shortAnswerSubmission)
        : undefined,
      multipleChoiceSubmission: isSet(object.multipleChoiceSubmission)
        ? MultipleChoiceSubmission.fromJSON(object.multipleChoiceSubmission)
        : undefined,
      rawJsonData: isSet(object.rawJsonData) ? globalThis.String(object.rawJsonData) : "",
    };
  },

  toJSON(message: GClassStudentSubmission): unknown {
    const obj: any = {};
    if (message.gclassStudentSubmissionId !== "") {
      obj.gclassStudentSubmissionId = message.gclassStudentSubmissionId;
    }
    if (message.gclassCourseId !== "") {
      obj.gclassCourseId = message.gclassCourseId;
    }
    if (message.gclassCourseWorkId !== "") {
      obj.gclassCourseWorkId = message.gclassCourseWorkId;
    }
    if (message.gclassUserId !== "") {
      obj.gclassUserId = message.gclassUserId;
    }
    if (message.gclassLink !== "") {
      obj.gclassLink = message.gclassLink;
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.submissionState !== 0) {
      obj.submissionState = statesToJSON(message.submissionState);
    }
    if (message.workNotSubmittedAndLate !== false) {
      obj.workNotSubmittedAndLate = message.workNotSubmittedAndLate;
    }
    if (message.assignedGrade !== 0) {
      obj.assignedGrade = message.assignedGrade;
    }
    if (message.workType !== 0) {
      obj.workType = workTypeToJSON(message.workType);
    }
    if (message.submissionHistory?.length) {
      obj.submissionHistory = message.submissionHistory.map((e) => SubmissionHistory.toJSON(e));
    }
    if (message.assignmentSubmission !== undefined) {
      obj.assignmentSubmission = AssignmentSubmission.toJSON(message.assignmentSubmission);
    }
    if (message.shortAnswerSubmission !== undefined) {
      obj.shortAnswerSubmission = ShortAnswerSubmission.toJSON(message.shortAnswerSubmission);
    }
    if (message.multipleChoiceSubmission !== undefined) {
      obj.multipleChoiceSubmission = MultipleChoiceSubmission.toJSON(message.multipleChoiceSubmission);
    }
    if (message.rawJsonData !== "") {
      obj.rawJsonData = message.rawJsonData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GClassStudentSubmission>, I>>(base?: I): GClassStudentSubmission {
    return GClassStudentSubmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GClassStudentSubmission>, I>>(object: I): GClassStudentSubmission {
    const message = createBaseGClassStudentSubmission();
    message.gclassStudentSubmissionId = object.gclassStudentSubmissionId ?? "";
    message.gclassCourseId = object.gclassCourseId ?? "";
    message.gclassCourseWorkId = object.gclassCourseWorkId ?? "";
    message.gclassUserId = object.gclassUserId ?? "";
    message.gclassLink = object.gclassLink ?? "";
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.submissionState = object.submissionState ?? 0;
    message.workNotSubmittedAndLate = object.workNotSubmittedAndLate ?? false;
    message.assignedGrade = object.assignedGrade ?? 0;
    message.workType = object.workType ?? 0;
    message.submissionHistory = object.submissionHistory?.map((e) => SubmissionHistory.fromPartial(e)) || [];
    message.assignmentSubmission = (object.assignmentSubmission !== undefined && object.assignmentSubmission !== null)
      ? AssignmentSubmission.fromPartial(object.assignmentSubmission)
      : undefined;
    message.shortAnswerSubmission =
      (object.shortAnswerSubmission !== undefined && object.shortAnswerSubmission !== null)
        ? ShortAnswerSubmission.fromPartial(object.shortAnswerSubmission)
        : undefined;
    message.multipleChoiceSubmission =
      (object.multipleChoiceSubmission !== undefined && object.multipleChoiceSubmission !== null)
        ? MultipleChoiceSubmission.fromPartial(object.multipleChoiceSubmission)
        : undefined;
    message.rawJsonData = object.rawJsonData ?? "";
    return message;
  },
};

function createBaseGClassCourseWork(): GClassCourseWork {
  return {
    gclassCourseWorkId: "",
    gclassCourseId: "",
    homeroomId: undefined,
    courseId: undefined,
    title: "",
    description: "",
    gclassLink: "",
    materials: [],
    creationTime: undefined,
    dueDate: undefined,
    workType: 0,
    rawJsonData: "",
  };
}

export const GClassCourseWork: MessageFns<GClassCourseWork> = {
  encode(message: GClassCourseWork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gclassCourseWorkId !== "") {
      writer.uint32(10).string(message.gclassCourseWorkId);
    }
    if (message.gclassCourseId !== "") {
      writer.uint32(18).string(message.gclassCourseId);
    }
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(26).fork()).join();
    }
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(34).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.gclassLink !== "") {
      writer.uint32(58).string(message.gclassLink);
    }
    for (const v of message.materials) {
      Attachment.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.creationTime !== undefined) {
      DateTime.encode(message.creationTime, writer.uint32(74).fork()).join();
    }
    if (message.dueDate !== undefined) {
      DateTime.encode(message.dueDate, writer.uint32(82).fork()).join();
    }
    if (message.workType !== 0) {
      writer.uint32(88).int32(message.workType);
    }
    if (message.rawJsonData !== "") {
      writer.uint32(98).string(message.rawJsonData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GClassCourseWork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGClassCourseWork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gclassCourseWorkId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gclassCourseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gclassLink = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.materials.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.creationTime = DateTime.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dueDate = DateTime.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.workType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.rawJsonData = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GClassCourseWork {
    return {
      gclassCourseWorkId: isSet(object.gclassCourseWorkId) ? globalThis.String(object.gclassCourseWorkId) : "",
      gclassCourseId: isSet(object.gclassCourseId) ? globalThis.String(object.gclassCourseId) : "",
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      gclassLink: isSet(object.gclassLink) ? globalThis.String(object.gclassLink) : "",
      materials: globalThis.Array.isArray(object?.materials)
        ? object.materials.map((e: any) => Attachment.fromJSON(e))
        : [],
      creationTime: isSet(object.creationTime) ? DateTime.fromJSON(object.creationTime) : undefined,
      dueDate: isSet(object.dueDate) ? DateTime.fromJSON(object.dueDate) : undefined,
      workType: isSet(object.workType) ? workTypeFromJSON(object.workType) : 0,
      rawJsonData: isSet(object.rawJsonData) ? globalThis.String(object.rawJsonData) : "",
    };
  },

  toJSON(message: GClassCourseWork): unknown {
    const obj: any = {};
    if (message.gclassCourseWorkId !== "") {
      obj.gclassCourseWorkId = message.gclassCourseWorkId;
    }
    if (message.gclassCourseId !== "") {
      obj.gclassCourseId = message.gclassCourseId;
    }
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.gclassLink !== "") {
      obj.gclassLink = message.gclassLink;
    }
    if (message.materials?.length) {
      obj.materials = message.materials.map((e) => Attachment.toJSON(e));
    }
    if (message.creationTime !== undefined) {
      obj.creationTime = DateTime.toJSON(message.creationTime);
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = DateTime.toJSON(message.dueDate);
    }
    if (message.workType !== 0) {
      obj.workType = workTypeToJSON(message.workType);
    }
    if (message.rawJsonData !== "") {
      obj.rawJsonData = message.rawJsonData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GClassCourseWork>, I>>(base?: I): GClassCourseWork {
    return GClassCourseWork.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GClassCourseWork>, I>>(object: I): GClassCourseWork {
    const message = createBaseGClassCourseWork();
    message.gclassCourseWorkId = object.gclassCourseWorkId ?? "";
    message.gclassCourseId = object.gclassCourseId ?? "";
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.gclassLink = object.gclassLink ?? "";
    message.materials = object.materials?.map((e) => Attachment.fromPartial(e)) || [];
    message.creationTime = (object.creationTime !== undefined && object.creationTime !== null)
      ? DateTime.fromPartial(object.creationTime)
      : undefined;
    message.dueDate = (object.dueDate !== undefined && object.dueDate !== null)
      ? DateTime.fromPartial(object.dueDate)
      : undefined;
    message.workType = object.workType ?? 0;
    message.rawJsonData = object.rawJsonData ?? "";
    return message;
  },
};

function createBaseSubmissionHistory(): SubmissionHistory {
  return { gradeHistory: undefined, stateHistory: undefined };
}

export const SubmissionHistory: MessageFns<SubmissionHistory> = {
  encode(message: SubmissionHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gradeHistory !== undefined) {
      GradeHistory.encode(message.gradeHistory, writer.uint32(10).fork()).join();
    }
    if (message.stateHistory !== undefined) {
      StateHistoryData.encode(message.stateHistory, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmissionHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmissionHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gradeHistory = GradeHistory.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateHistory = StateHistoryData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmissionHistory {
    return {
      gradeHistory: isSet(object.gradeHistory) ? GradeHistory.fromJSON(object.gradeHistory) : undefined,
      stateHistory: isSet(object.stateHistory) ? StateHistoryData.fromJSON(object.stateHistory) : undefined,
    };
  },

  toJSON(message: SubmissionHistory): unknown {
    const obj: any = {};
    if (message.gradeHistory !== undefined) {
      obj.gradeHistory = GradeHistory.toJSON(message.gradeHistory);
    }
    if (message.stateHistory !== undefined) {
      obj.stateHistory = StateHistoryData.toJSON(message.stateHistory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmissionHistory>, I>>(base?: I): SubmissionHistory {
    return SubmissionHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmissionHistory>, I>>(object: I): SubmissionHistory {
    const message = createBaseSubmissionHistory();
    message.gradeHistory = (object.gradeHistory !== undefined && object.gradeHistory !== null)
      ? GradeHistory.fromPartial(object.gradeHistory)
      : undefined;
    message.stateHistory = (object.stateHistory !== undefined && object.stateHistory !== null)
      ? StateHistoryData.fromPartial(object.stateHistory)
      : undefined;
    return message;
  },
};

function createBaseGradeHistory(): GradeHistory {
  return { actorUserId: "", gradeChangeType: 0, gradeTimestamp: undefined, maxPoints: 0, pointsEarned: 0 };
}

export const GradeHistory: MessageFns<GradeHistory> = {
  encode(message: GradeHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actorUserId !== "") {
      writer.uint32(10).string(message.actorUserId);
    }
    if (message.gradeChangeType !== undefined && message.gradeChangeType !== 0) {
      writer.uint32(16).int32(message.gradeChangeType);
    }
    if (message.gradeTimestamp !== undefined) {
      DateTime.encode(message.gradeTimestamp, writer.uint32(26).fork()).join();
    }
    if (message.maxPoints !== 0) {
      writer.uint32(33).double(message.maxPoints);
    }
    if (message.pointsEarned !== 0) {
      writer.uint32(41).double(message.pointsEarned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GradeHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGradeHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gradeChangeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gradeTimestamp = DateTime.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.maxPoints = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.pointsEarned = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GradeHistory {
    return {
      actorUserId: isSet(object.actorUserId) ? globalThis.String(object.actorUserId) : "",
      gradeChangeType: isSet(object.gradeChangeType) ? gradeChangeTypeFromJSON(object.gradeChangeType) : 0,
      gradeTimestamp: isSet(object.gradeTimestamp) ? DateTime.fromJSON(object.gradeTimestamp) : undefined,
      maxPoints: isSet(object.maxPoints) ? globalThis.Number(object.maxPoints) : 0,
      pointsEarned: isSet(object.pointsEarned) ? globalThis.Number(object.pointsEarned) : 0,
    };
  },

  toJSON(message: GradeHistory): unknown {
    const obj: any = {};
    if (message.actorUserId !== "") {
      obj.actorUserId = message.actorUserId;
    }
    if (message.gradeChangeType !== undefined && message.gradeChangeType !== 0) {
      obj.gradeChangeType = gradeChangeTypeToJSON(message.gradeChangeType);
    }
    if (message.gradeTimestamp !== undefined) {
      obj.gradeTimestamp = DateTime.toJSON(message.gradeTimestamp);
    }
    if (message.maxPoints !== 0) {
      obj.maxPoints = message.maxPoints;
    }
    if (message.pointsEarned !== 0) {
      obj.pointsEarned = message.pointsEarned;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GradeHistory>, I>>(base?: I): GradeHistory {
    return GradeHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GradeHistory>, I>>(object: I): GradeHistory {
    const message = createBaseGradeHistory();
    message.actorUserId = object.actorUserId ?? "";
    message.gradeChangeType = object.gradeChangeType ?? 0;
    message.gradeTimestamp = (object.gradeTimestamp !== undefined && object.gradeTimestamp !== null)
      ? DateTime.fromPartial(object.gradeTimestamp)
      : undefined;
    message.maxPoints = object.maxPoints ?? 0;
    message.pointsEarned = object.pointsEarned ?? 0;
    return message;
  },
};

function createBaseStateHistoryData(): StateHistoryData {
  return { actorUserId: "", state: 0, stateTimestamp: undefined };
}

export const StateHistoryData: MessageFns<StateHistoryData> = {
  encode(message: StateHistoryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actorUserId !== "") {
      writer.uint32(10).string(message.actorUserId);
    }
    if (message.state !== undefined && message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.stateTimestamp !== undefined) {
      DateTime.encode(message.stateTimestamp, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateHistoryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateHistoryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorUserId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateTimestamp = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateHistoryData {
    return {
      actorUserId: isSet(object.actorUserId) ? globalThis.String(object.actorUserId) : "",
      state: isSet(object.state) ? stateHistoryFromJSON(object.state) : 0,
      stateTimestamp: isSet(object.stateTimestamp) ? DateTime.fromJSON(object.stateTimestamp) : undefined,
    };
  },

  toJSON(message: StateHistoryData): unknown {
    const obj: any = {};
    if (message.actorUserId !== "") {
      obj.actorUserId = message.actorUserId;
    }
    if (message.state !== undefined && message.state !== 0) {
      obj.state = stateHistoryToJSON(message.state);
    }
    if (message.stateTimestamp !== undefined) {
      obj.stateTimestamp = DateTime.toJSON(message.stateTimestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StateHistoryData>, I>>(base?: I): StateHistoryData {
    return StateHistoryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StateHistoryData>, I>>(object: I): StateHistoryData {
    const message = createBaseStateHistoryData();
    message.actorUserId = object.actorUserId ?? "";
    message.state = object.state ?? 0;
    message.stateTimestamp = (object.stateTimestamp !== undefined && object.stateTimestamp !== null)
      ? DateTime.fromPartial(object.stateTimestamp)
      : undefined;
    return message;
  },
};

function createBaseAssignmentSubmission(): AssignmentSubmission {
  return { attachments: [] };
}

export const AssignmentSubmission: MessageFns<AssignmentSubmission> = {
  encode(message: AssignmentSubmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attachments) {
      Attachment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignmentSubmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignmentSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachments.push(Attachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignmentSubmission {
    return {
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => Attachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AssignmentSubmission): unknown {
    const obj: any = {};
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => Attachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignmentSubmission>, I>>(base?: I): AssignmentSubmission {
    return AssignmentSubmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignmentSubmission>, I>>(object: I): AssignmentSubmission {
    const message = createBaseAssignmentSubmission();
    message.attachments = object.attachments?.map((e) => Attachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseShortAnswerSubmission(): ShortAnswerSubmission {
  return { answer: "" };
}

export const ShortAnswerSubmission: MessageFns<ShortAnswerSubmission> = {
  encode(message: ShortAnswerSubmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShortAnswerSubmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShortAnswerSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShortAnswerSubmission {
    return { answer: isSet(object.answer) ? globalThis.String(object.answer) : "" };
  },

  toJSON(message: ShortAnswerSubmission): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShortAnswerSubmission>, I>>(base?: I): ShortAnswerSubmission {
    return ShortAnswerSubmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShortAnswerSubmission>, I>>(object: I): ShortAnswerSubmission {
    const message = createBaseShortAnswerSubmission();
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseMultipleChoiceSubmission(): MultipleChoiceSubmission {
  return { answer: "" };
}

export const MultipleChoiceSubmission: MessageFns<MultipleChoiceSubmission> = {
  encode(message: MultipleChoiceSubmission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleChoiceSubmission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleChoiceSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleChoiceSubmission {
    return { answer: isSet(object.answer) ? globalThis.String(object.answer) : "" };
  },

  toJSON(message: MultipleChoiceSubmission): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultipleChoiceSubmission>, I>>(base?: I): MultipleChoiceSubmission {
    return MultipleChoiceSubmission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultipleChoiceSubmission>, I>>(object: I): MultipleChoiceSubmission {
    const message = createBaseMultipleChoiceSubmission();
    message.answer = object.answer ?? "";
    return message;
  },
};

function createBaseAttachment(): Attachment {
  return { driveFile: undefined, form: undefined, link: undefined, youtubeVideo: undefined };
}

export const Attachment: MessageFns<Attachment> = {
  encode(message: Attachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.driveFile !== undefined) {
      DriveFile.encode(message.driveFile, writer.uint32(10).fork()).join();
    }
    if (message.form !== undefined) {
      Form.encode(message.form, writer.uint32(18).fork()).join();
    }
    if (message.link !== undefined) {
      Link.encode(message.link, writer.uint32(26).fork()).join();
    }
    if (message.youtubeVideo !== undefined) {
      YouTubeVideo.encode(message.youtubeVideo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.driveFile = DriveFile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.form = Form.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.link = Link.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.youtubeVideo = YouTubeVideo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attachment {
    return {
      driveFile: isSet(object.driveFile) ? DriveFile.fromJSON(object.driveFile) : undefined,
      form: isSet(object.form) ? Form.fromJSON(object.form) : undefined,
      link: isSet(object.link) ? Link.fromJSON(object.link) : undefined,
      youtubeVideo: isSet(object.youtubeVideo) ? YouTubeVideo.fromJSON(object.youtubeVideo) : undefined,
    };
  },

  toJSON(message: Attachment): unknown {
    const obj: any = {};
    if (message.driveFile !== undefined) {
      obj.driveFile = DriveFile.toJSON(message.driveFile);
    }
    if (message.form !== undefined) {
      obj.form = Form.toJSON(message.form);
    }
    if (message.link !== undefined) {
      obj.link = Link.toJSON(message.link);
    }
    if (message.youtubeVideo !== undefined) {
      obj.youtubeVideo = YouTubeVideo.toJSON(message.youtubeVideo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Attachment>, I>>(base?: I): Attachment {
    return Attachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Attachment>, I>>(object: I): Attachment {
    const message = createBaseAttachment();
    message.driveFile = (object.driveFile !== undefined && object.driveFile !== null)
      ? DriveFile.fromPartial(object.driveFile)
      : undefined;
    message.form = (object.form !== undefined && object.form !== null) ? Form.fromPartial(object.form) : undefined;
    message.link = (object.link !== undefined && object.link !== null) ? Link.fromPartial(object.link) : undefined;
    message.youtubeVideo = (object.youtubeVideo !== undefined && object.youtubeVideo !== null)
      ? YouTubeVideo.fromPartial(object.youtubeVideo)
      : undefined;
    return message;
  },
};

function createBaseDriveFile(): DriveFile {
  return { alternateLink: "", id: "", thumbnailUrl: "", title: "" };
}

export const DriveFile: MessageFns<DriveFile> = {
  encode(message: DriveFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alternateLink !== "") {
      writer.uint32(10).string(message.alternateLink);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(26).string(message.thumbnailUrl);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DriveFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDriveFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternateLink = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DriveFile {
    return {
      alternateLink: isSet(object.alternateLink) ? globalThis.String(object.alternateLink) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: DriveFile): unknown {
    const obj: any = {};
    if (message.alternateLink !== "") {
      obj.alternateLink = message.alternateLink;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DriveFile>, I>>(base?: I): DriveFile {
    return DriveFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DriveFile>, I>>(object: I): DriveFile {
    const message = createBaseDriveFile();
    message.alternateLink = object.alternateLink ?? "";
    message.id = object.id ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseForm(): Form {
  return { formUrl: "", responseUrl: "", thumbnailUrl: "", title: "" };
}

export const Form: MessageFns<Form> = {
  encode(message: Form, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.formUrl !== "") {
      writer.uint32(10).string(message.formUrl);
    }
    if (message.responseUrl !== "") {
      writer.uint32(18).string(message.responseUrl);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(26).string(message.thumbnailUrl);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Form {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.formUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.responseUrl = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Form {
    return {
      formUrl: isSet(object.formUrl) ? globalThis.String(object.formUrl) : "",
      responseUrl: isSet(object.responseUrl) ? globalThis.String(object.responseUrl) : "",
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: Form): unknown {
    const obj: any = {};
    if (message.formUrl !== "") {
      obj.formUrl = message.formUrl;
    }
    if (message.responseUrl !== "") {
      obj.responseUrl = message.responseUrl;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Form>, I>>(base?: I): Form {
    return Form.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Form>, I>>(object: I): Form {
    const message = createBaseForm();
    message.formUrl = object.formUrl ?? "";
    message.responseUrl = object.responseUrl ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseLink(): Link {
  return { thumbnailUrl: "", title: "", url: "" };
}

export const Link: MessageFns<Link> = {
  encode(message: Link, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thumbnailUrl !== "") {
      writer.uint32(10).string(message.thumbnailUrl);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Link {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Link {
    return {
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Link>, I>>(base?: I): Link {
    return Link.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Link>, I>>(object: I): Link {
    const message = createBaseLink();
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.title = object.title ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseYouTubeVideo(): YouTubeVideo {
  return { alternateLink: "", id: "", thumbnailUrl: "", title: "" };
}

export const YouTubeVideo: MessageFns<YouTubeVideo> = {
  encode(message: YouTubeVideo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alternateLink !== "") {
      writer.uint32(10).string(message.alternateLink);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.thumbnailUrl !== "") {
      writer.uint32(26).string(message.thumbnailUrl);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YouTubeVideo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYouTubeVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternateLink = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.thumbnailUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YouTubeVideo {
    return {
      alternateLink: isSet(object.alternateLink) ? globalThis.String(object.alternateLink) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      thumbnailUrl: isSet(object.thumbnailUrl) ? globalThis.String(object.thumbnailUrl) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: YouTubeVideo): unknown {
    const obj: any = {};
    if (message.alternateLink !== "") {
      obj.alternateLink = message.alternateLink;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.thumbnailUrl !== "") {
      obj.thumbnailUrl = message.thumbnailUrl;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<YouTubeVideo>, I>>(base?: I): YouTubeVideo {
    return YouTubeVideo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<YouTubeVideo>, I>>(object: I): YouTubeVideo {
    const message = createBaseYouTubeVideo();
    message.alternateLink = object.alternateLink ?? "";
    message.id = object.id ?? "";
    message.thumbnailUrl = object.thumbnailUrl ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

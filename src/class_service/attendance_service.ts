// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: class_service/attendance_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";
import { Student } from "../user_service/student";
import { TeacherBasic } from "../user_service/teacher";
import { ObjectId } from "../utils/object_id";
import { RequestContext } from "../utils/request_context";
import { UserType, userTypeFromJSON, userTypeToJSON, userTypeToNumber } from "../utils/user_type";
import {
  Attendance,
  AttendanceStatus,
  attendanceStatusFromJSON,
  attendanceStatusToJSON,
  attendanceStatusToNumber,
} from "./attendance";
import { Course } from "./course";
import { Homeroom } from "./homeroom";

export const protobufPackage = "class_service.attendance_service";

export enum TimeType {
  SignIn = "SignIn",
  SignOut = "SignOut",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function timeTypeFromJSON(object: any): TimeType {
  switch (object) {
    case 0:
    case "SignIn":
      return TimeType.SignIn;
    case 1:
    case "SignOut":
      return TimeType.SignOut;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TimeType.UNRECOGNIZED;
  }
}

export function timeTypeToJSON(object: TimeType): string {
  switch (object) {
    case TimeType.SignIn:
      return "SignIn";
    case TimeType.SignOut:
      return "SignOut";
    case TimeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function timeTypeToNumber(object: TimeType): number {
  switch (object) {
    case TimeType.SignIn:
      return 0;
    case TimeType.SignOut:
      return 1;
    case TimeType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum AttendanceCompletionStatus {
  EMPTY = "EMPTY",
  PARTIAL = "PARTIAL",
  FULL = "FULL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function attendanceCompletionStatusFromJSON(object: any): AttendanceCompletionStatus {
  switch (object) {
    case 0:
    case "EMPTY":
      return AttendanceCompletionStatus.EMPTY;
    case 1:
    case "PARTIAL":
      return AttendanceCompletionStatus.PARTIAL;
    case 2:
    case "FULL":
      return AttendanceCompletionStatus.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttendanceCompletionStatus.UNRECOGNIZED;
  }
}

export function attendanceCompletionStatusToJSON(object: AttendanceCompletionStatus): string {
  switch (object) {
    case AttendanceCompletionStatus.EMPTY:
      return "EMPTY";
    case AttendanceCompletionStatus.PARTIAL:
      return "PARTIAL";
    case AttendanceCompletionStatus.FULL:
      return "FULL";
    case AttendanceCompletionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function attendanceCompletionStatusToNumber(object: AttendanceCompletionStatus): number {
  switch (object) {
    case AttendanceCompletionStatus.EMPTY:
      return 0;
    case AttendanceCompletionStatus.PARTIAL:
      return 1;
    case AttendanceCompletionStatus.FULL:
      return 2;
    case AttendanceCompletionStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface AttendanceResponse {
  attendance: Attendance[];
}

/** One-of to reference class context */
export interface ClassRef {
  courseId?: ObjectId | undefined;
  homeroomId?: ObjectId | undefined;
}

/** Queries */
export interface GetStudentEntriesRequest {
  context:
    | RequestContext
    | undefined;
  /** when omitted, fetch across all classes */
  classRef?: ClassRef | undefined;
  studentId:
    | ObjectId
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  startDate: string;
  /** YYYY-MM-DD format for NaiveDate */
  endDate: string;
}

export interface GetStudentsEntriesCountRequest {
  context:
    | RequestContext
    | undefined;
  /** when omitted, fetch across all classes */
  classRef?: ClassRef | undefined;
  studentIds: ObjectId[];
  /** YYYY-MM-DD format for NaiveDate */
  startDate: string;
  /** YYYY-MM-DD format for NaiveDate */
  endDate: string;
}

/** Updates */
export interface UpdateStatusRequest {
  context: RequestContext | undefined;
  attendanceEntryId: ObjectId | undefined;
  status: AttendanceStatus;
}

export interface UpdateTimeRequest {
  context: RequestContext | undefined;
  attendanceEntryId: ObjectId | undefined;
  timeType: TimeType;
  time: Date | undefined;
}

export interface UpdateReasonRequest {
  context: RequestContext | undefined;
  attendanceEntryId: ObjectId | undefined;
  reason: string;
}

export interface UpdateLateDismissalDateRequest {
  context: RequestContext | undefined;
  attendanceEntryId: ObjectId | undefined;
  lateDismissalDate?: Date | undefined;
}

export interface UpdateExcuseStudentRequest {
  context: RequestContext | undefined;
  attendanceEntryId: ObjectId | undefined;
  reason: string;
  studentExcusedBy: ObjectId | undefined;
  studentExcusedByUserType: UserType;
}

/** Aggregations */
export interface AttendanceCounts {
  none: number;
  present: number;
  late: number;
  absent: number;
  excusedAbsent: number;
  nonExcusedAbsent: number;
}

export interface StudentAttendanceCounts {
  student: Student | undefined;
  counts: AttendanceCounts | undefined;
}

export interface StudentsAttendanceCountsResponse {
  studentCounts: StudentAttendanceCounts[];
}

export interface GetCoursesAttendanceOverviewRequest {
  context:
    | RequestContext
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  showAllClasses: boolean;
}

export interface GetCoursesAttendanceOverviewResponse {
  courses: Course[];
  teachers: TeacherBasic[];
  entryStatus: CourseEntryStatus[];
}

export interface CourseEntryStatus {
  courseId: ObjectId | undefined;
  isComplete: boolean;
}

export interface GetHomeroomsAttendanceOverviewRequest {
  context:
    | RequestContext
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  showAllClasses: boolean;
}

export interface GetHomeroomsAttendanceOverviewResponse {
  homerooms: Homeroom[];
  teachers: TeacherBasic[];
  entryStatus: HomeroomEntryStatus[];
}

export interface HomeroomEntryStatus {
  homeroomId: ObjectId | undefined;
  isComplete: boolean;
}

export interface GetHomeroomAttendanceDetailsRequest {
  context: RequestContext | undefined;
  homeroomId:
    | ObjectId
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  periodNumber: number;
}

export interface GetHomeroomAttendanceDetailsResponse {
  homeroom: Homeroom | undefined;
  students: Student[];
  attendanceEntries: Attendance[];
}

export interface GetSingleStudentHomeroomAttendanceEntryRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
  homeroomId:
    | ObjectId
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
}

export interface GetSingleStudentHomeroomAttendanceEntryResponse {
  student: Student | undefined;
  attendanceEntry: Attendance | undefined;
  homeroom: Homeroom | undefined;
}

export interface GetAttendanceDateMapRequest {
  context: RequestContext | undefined;
  classRef:
    | ClassRef
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  startDate: string;
  /** YYYY-MM-DD format for NaiveDate */
  endDate: string;
}

export interface GetAttendanceDateMapResponse {
  entries: AttendanceDateMapEntry[];
}

export interface AttendanceDateMapEntry {
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  completionStatus: AttendanceCompletionStatus;
}

export interface GetAttendanceCsvDataRequest {
  context: RequestContext | undefined;
  classRef:
    | ClassRef
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  startDate: string;
  /** YYYY-MM-DD format for NaiveDate */
  endDate: string;
}

export interface GetAttendanceCsvDataResponse {
  csvData: string;
  filename: string;
}

export interface GetCourseAttendanceDetailsRequest {
  context: RequestContext | undefined;
  courseId:
    | ObjectId
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  periodNumber: number;
}

export interface GetCourseAttendanceDetailsResponse {
  course: Course | undefined;
  students: Student[];
  attendanceEntries: Attendance[];
}

export interface GetSingleStudentCourseAttendanceEntryRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
  courseId:
    | ObjectId
    | undefined;
  /** YYYY-MM-DD format for NaiveDate */
  date: string;
  periodNumber: number;
}

export interface GetSingleStudentCourseAttendanceEntryResponse {
  student: Student | undefined;
  attendanceEntry: Attendance | undefined;
  course: Course | undefined;
}

function createBaseAttendanceResponse(): AttendanceResponse {
  return { attendance: [] };
}

export const AttendanceResponse: MessageFns<AttendanceResponse> = {
  encode(message: AttendanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attendance) {
      Attendance.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttendanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttendanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attendance.push(Attendance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttendanceResponse {
    return {
      attendance: globalThis.Array.isArray(object?.attendance)
        ? object.attendance.map((e: any) => Attendance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AttendanceResponse): unknown {
    const obj: any = {};
    if (message.attendance?.length) {
      obj.attendance = message.attendance.map((e) => Attendance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttendanceResponse>, I>>(base?: I): AttendanceResponse {
    return AttendanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttendanceResponse>, I>>(object: I): AttendanceResponse {
    const message = createBaseAttendanceResponse();
    message.attendance = object.attendance?.map((e) => Attendance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClassRef(): ClassRef {
  return { courseId: undefined, homeroomId: undefined };
}

export const ClassRef: MessageFns<ClassRef> = {
  encode(message: ClassRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(10).fork()).join();
    }
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClassRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassRef {
    return {
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
    };
  },

  toJSON(message: ClassRef): unknown {
    const obj: any = {};
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClassRef>, I>>(base?: I): ClassRef {
    return ClassRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClassRef>, I>>(object: I): ClassRef {
    const message = createBaseClassRef();
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    return message;
  },
};

function createBaseGetStudentEntriesRequest(): GetStudentEntriesRequest {
  return { context: undefined, classRef: undefined, studentId: undefined, startDate: "", endDate: "" };
}

export const GetStudentEntriesRequest: MessageFns<GetStudentEntriesRequest> = {
  encode(message: GetStudentEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.classRef !== undefined) {
      ClassRef.encode(message.classRef, writer.uint32(18).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(26).fork()).join();
    }
    if (message.startDate !== "") {
      writer.uint32(34).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(42).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classRef = ClassRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentEntriesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      classRef: isSet(object.classRef) ? ClassRef.fromJSON(object.classRef) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: GetStudentEntriesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.classRef !== undefined) {
      obj.classRef = ClassRef.toJSON(message.classRef);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentEntriesRequest>, I>>(base?: I): GetStudentEntriesRequest {
    return GetStudentEntriesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentEntriesRequest>, I>>(object: I): GetStudentEntriesRequest {
    const message = createBaseGetStudentEntriesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.classRef = (object.classRef !== undefined && object.classRef !== null)
      ? ClassRef.fromPartial(object.classRef)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseGetStudentsEntriesCountRequest(): GetStudentsEntriesCountRequest {
  return { context: undefined, classRef: undefined, studentIds: [], startDate: "", endDate: "" };
}

export const GetStudentsEntriesCountRequest: MessageFns<GetStudentsEntriesCountRequest> = {
  encode(message: GetStudentsEntriesCountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.classRef !== undefined) {
      ClassRef.encode(message.classRef, writer.uint32(18).fork()).join();
    }
    for (const v of message.studentIds) {
      ObjectId.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.startDate !== "") {
      writer.uint32(34).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(42).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsEntriesCountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsEntriesCountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classRef = ClassRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.studentIds.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsEntriesCountRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      classRef: isSet(object.classRef) ? ClassRef.fromJSON(object.classRef) : undefined,
      studentIds: globalThis.Array.isArray(object?.studentIds)
        ? object.studentIds.map((e: any) => ObjectId.fromJSON(e))
        : [],
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: GetStudentsEntriesCountRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.classRef !== undefined) {
      obj.classRef = ClassRef.toJSON(message.classRef);
    }
    if (message.studentIds?.length) {
      obj.studentIds = message.studentIds.map((e) => ObjectId.toJSON(e));
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsEntriesCountRequest>, I>>(base?: I): GetStudentsEntriesCountRequest {
    return GetStudentsEntriesCountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsEntriesCountRequest>, I>>(
    object: I,
  ): GetStudentsEntriesCountRequest {
    const message = createBaseGetStudentsEntriesCountRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.classRef = (object.classRef !== undefined && object.classRef !== null)
      ? ClassRef.fromPartial(object.classRef)
      : undefined;
    message.studentIds = object.studentIds?.map((e) => ObjectId.fromPartial(e)) || [];
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseUpdateStatusRequest(): UpdateStatusRequest {
  return { context: undefined, attendanceEntryId: undefined, status: AttendanceStatus.None };
}

export const UpdateStatusRequest: MessageFns<UpdateStatusRequest> = {
  encode(message: UpdateStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntryId !== undefined) {
      ObjectId.encode(message.attendanceEntryId, writer.uint32(18).fork()).join();
    }
    if (message.status !== AttendanceStatus.None) {
      writer.uint32(24).int32(attendanceStatusToNumber(message.status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntryId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = attendanceStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateStatusRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      attendanceEntryId: isSet(object.attendanceEntryId) ? ObjectId.fromJSON(object.attendanceEntryId) : undefined,
      status: isSet(object.status) ? attendanceStatusFromJSON(object.status) : AttendanceStatus.None,
    };
  },

  toJSON(message: UpdateStatusRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.attendanceEntryId !== undefined) {
      obj.attendanceEntryId = ObjectId.toJSON(message.attendanceEntryId);
    }
    if (message.status !== AttendanceStatus.None) {
      obj.status = attendanceStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateStatusRequest>, I>>(base?: I): UpdateStatusRequest {
    return UpdateStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateStatusRequest>, I>>(object: I): UpdateStatusRequest {
    const message = createBaseUpdateStatusRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.attendanceEntryId = (object.attendanceEntryId !== undefined && object.attendanceEntryId !== null)
      ? ObjectId.fromPartial(object.attendanceEntryId)
      : undefined;
    message.status = object.status ?? AttendanceStatus.None;
    return message;
  },
};

function createBaseUpdateTimeRequest(): UpdateTimeRequest {
  return { context: undefined, attendanceEntryId: undefined, timeType: TimeType.SignIn, time: undefined };
}

export const UpdateTimeRequest: MessageFns<UpdateTimeRequest> = {
  encode(message: UpdateTimeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntryId !== undefined) {
      ObjectId.encode(message.attendanceEntryId, writer.uint32(18).fork()).join();
    }
    if (message.timeType !== TimeType.SignIn) {
      writer.uint32(24).int32(timeTypeToNumber(message.timeType));
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTimeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntryId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeType = timeTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTimeRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      attendanceEntryId: isSet(object.attendanceEntryId) ? ObjectId.fromJSON(object.attendanceEntryId) : undefined,
      timeType: isSet(object.timeType) ? timeTypeFromJSON(object.timeType) : TimeType.SignIn,
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
    };
  },

  toJSON(message: UpdateTimeRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.attendanceEntryId !== undefined) {
      obj.attendanceEntryId = ObjectId.toJSON(message.attendanceEntryId);
    }
    if (message.timeType !== TimeType.SignIn) {
      obj.timeType = timeTypeToJSON(message.timeType);
    }
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTimeRequest>, I>>(base?: I): UpdateTimeRequest {
    return UpdateTimeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTimeRequest>, I>>(object: I): UpdateTimeRequest {
    const message = createBaseUpdateTimeRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.attendanceEntryId = (object.attendanceEntryId !== undefined && object.attendanceEntryId !== null)
      ? ObjectId.fromPartial(object.attendanceEntryId)
      : undefined;
    message.timeType = object.timeType ?? TimeType.SignIn;
    message.time = object.time ?? undefined;
    return message;
  },
};

function createBaseUpdateReasonRequest(): UpdateReasonRequest {
  return { context: undefined, attendanceEntryId: undefined, reason: "" };
}

export const UpdateReasonRequest: MessageFns<UpdateReasonRequest> = {
  encode(message: UpdateReasonRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntryId !== undefined) {
      ObjectId.encode(message.attendanceEntryId, writer.uint32(18).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateReasonRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateReasonRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntryId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateReasonRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      attendanceEntryId: isSet(object.attendanceEntryId) ? ObjectId.fromJSON(object.attendanceEntryId) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: UpdateReasonRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.attendanceEntryId !== undefined) {
      obj.attendanceEntryId = ObjectId.toJSON(message.attendanceEntryId);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateReasonRequest>, I>>(base?: I): UpdateReasonRequest {
    return UpdateReasonRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateReasonRequest>, I>>(object: I): UpdateReasonRequest {
    const message = createBaseUpdateReasonRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.attendanceEntryId = (object.attendanceEntryId !== undefined && object.attendanceEntryId !== null)
      ? ObjectId.fromPartial(object.attendanceEntryId)
      : undefined;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseUpdateLateDismissalDateRequest(): UpdateLateDismissalDateRequest {
  return { context: undefined, attendanceEntryId: undefined, lateDismissalDate: undefined };
}

export const UpdateLateDismissalDateRequest: MessageFns<UpdateLateDismissalDateRequest> = {
  encode(message: UpdateLateDismissalDateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntryId !== undefined) {
      ObjectId.encode(message.attendanceEntryId, writer.uint32(18).fork()).join();
    }
    if (message.lateDismissalDate !== undefined) {
      Timestamp.encode(toTimestamp(message.lateDismissalDate), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLateDismissalDateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLateDismissalDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntryId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lateDismissalDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLateDismissalDateRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      attendanceEntryId: isSet(object.attendanceEntryId) ? ObjectId.fromJSON(object.attendanceEntryId) : undefined,
      lateDismissalDate: isSet(object.lateDismissalDate) ? fromJsonTimestamp(object.lateDismissalDate) : undefined,
    };
  },

  toJSON(message: UpdateLateDismissalDateRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.attendanceEntryId !== undefined) {
      obj.attendanceEntryId = ObjectId.toJSON(message.attendanceEntryId);
    }
    if (message.lateDismissalDate !== undefined) {
      obj.lateDismissalDate = message.lateDismissalDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateLateDismissalDateRequest>, I>>(base?: I): UpdateLateDismissalDateRequest {
    return UpdateLateDismissalDateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateLateDismissalDateRequest>, I>>(
    object: I,
  ): UpdateLateDismissalDateRequest {
    const message = createBaseUpdateLateDismissalDateRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.attendanceEntryId = (object.attendanceEntryId !== undefined && object.attendanceEntryId !== null)
      ? ObjectId.fromPartial(object.attendanceEntryId)
      : undefined;
    message.lateDismissalDate = object.lateDismissalDate ?? undefined;
    return message;
  },
};

function createBaseUpdateExcuseStudentRequest(): UpdateExcuseStudentRequest {
  return {
    context: undefined,
    attendanceEntryId: undefined,
    reason: "",
    studentExcusedBy: undefined,
    studentExcusedByUserType: UserType.None,
  };
}

export const UpdateExcuseStudentRequest: MessageFns<UpdateExcuseStudentRequest> = {
  encode(message: UpdateExcuseStudentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntryId !== undefined) {
      ObjectId.encode(message.attendanceEntryId, writer.uint32(18).fork()).join();
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.studentExcusedBy !== undefined) {
      ObjectId.encode(message.studentExcusedBy, writer.uint32(34).fork()).join();
    }
    if (message.studentExcusedByUserType !== UserType.None) {
      writer.uint32(40).int32(userTypeToNumber(message.studentExcusedByUserType));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateExcuseStudentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExcuseStudentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntryId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.studentExcusedBy = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.studentExcusedByUserType = userTypeFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExcuseStudentRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      attendanceEntryId: isSet(object.attendanceEntryId) ? ObjectId.fromJSON(object.attendanceEntryId) : undefined,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      studentExcusedBy: isSet(object.studentExcusedBy) ? ObjectId.fromJSON(object.studentExcusedBy) : undefined,
      studentExcusedByUserType: isSet(object.studentExcusedByUserType)
        ? userTypeFromJSON(object.studentExcusedByUserType)
        : UserType.None,
    };
  },

  toJSON(message: UpdateExcuseStudentRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.attendanceEntryId !== undefined) {
      obj.attendanceEntryId = ObjectId.toJSON(message.attendanceEntryId);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.studentExcusedBy !== undefined) {
      obj.studentExcusedBy = ObjectId.toJSON(message.studentExcusedBy);
    }
    if (message.studentExcusedByUserType !== UserType.None) {
      obj.studentExcusedByUserType = userTypeToJSON(message.studentExcusedByUserType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExcuseStudentRequest>, I>>(base?: I): UpdateExcuseStudentRequest {
    return UpdateExcuseStudentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateExcuseStudentRequest>, I>>(object: I): UpdateExcuseStudentRequest {
    const message = createBaseUpdateExcuseStudentRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.attendanceEntryId = (object.attendanceEntryId !== undefined && object.attendanceEntryId !== null)
      ? ObjectId.fromPartial(object.attendanceEntryId)
      : undefined;
    message.reason = object.reason ?? "";
    message.studentExcusedBy = (object.studentExcusedBy !== undefined && object.studentExcusedBy !== null)
      ? ObjectId.fromPartial(object.studentExcusedBy)
      : undefined;
    message.studentExcusedByUserType = object.studentExcusedByUserType ?? UserType.None;
    return message;
  },
};

function createBaseAttendanceCounts(): AttendanceCounts {
  return { none: 0, present: 0, late: 0, absent: 0, excusedAbsent: 0, nonExcusedAbsent: 0 };
}

export const AttendanceCounts: MessageFns<AttendanceCounts> = {
  encode(message: AttendanceCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.none !== 0) {
      writer.uint32(8).uint32(message.none);
    }
    if (message.present !== 0) {
      writer.uint32(16).uint32(message.present);
    }
    if (message.late !== 0) {
      writer.uint32(24).uint32(message.late);
    }
    if (message.absent !== 0) {
      writer.uint32(32).uint32(message.absent);
    }
    if (message.excusedAbsent !== 0) {
      writer.uint32(40).uint32(message.excusedAbsent);
    }
    if (message.nonExcusedAbsent !== 0) {
      writer.uint32(48).uint32(message.nonExcusedAbsent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttendanceCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttendanceCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.none = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.present = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.late = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.absent = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.excusedAbsent = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nonExcusedAbsent = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttendanceCounts {
    return {
      none: isSet(object.none) ? globalThis.Number(object.none) : 0,
      present: isSet(object.present) ? globalThis.Number(object.present) : 0,
      late: isSet(object.late) ? globalThis.Number(object.late) : 0,
      absent: isSet(object.absent) ? globalThis.Number(object.absent) : 0,
      excusedAbsent: isSet(object.excusedAbsent) ? globalThis.Number(object.excusedAbsent) : 0,
      nonExcusedAbsent: isSet(object.nonExcusedAbsent) ? globalThis.Number(object.nonExcusedAbsent) : 0,
    };
  },

  toJSON(message: AttendanceCounts): unknown {
    const obj: any = {};
    if (message.none !== 0) {
      obj.none = Math.round(message.none);
    }
    if (message.present !== 0) {
      obj.present = Math.round(message.present);
    }
    if (message.late !== 0) {
      obj.late = Math.round(message.late);
    }
    if (message.absent !== 0) {
      obj.absent = Math.round(message.absent);
    }
    if (message.excusedAbsent !== 0) {
      obj.excusedAbsent = Math.round(message.excusedAbsent);
    }
    if (message.nonExcusedAbsent !== 0) {
      obj.nonExcusedAbsent = Math.round(message.nonExcusedAbsent);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttendanceCounts>, I>>(base?: I): AttendanceCounts {
    return AttendanceCounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttendanceCounts>, I>>(object: I): AttendanceCounts {
    const message = createBaseAttendanceCounts();
    message.none = object.none ?? 0;
    message.present = object.present ?? 0;
    message.late = object.late ?? 0;
    message.absent = object.absent ?? 0;
    message.excusedAbsent = object.excusedAbsent ?? 0;
    message.nonExcusedAbsent = object.nonExcusedAbsent ?? 0;
    return message;
  },
};

function createBaseStudentAttendanceCounts(): StudentAttendanceCounts {
  return { student: undefined, counts: undefined };
}

export const StudentAttendanceCounts: MessageFns<StudentAttendanceCounts> = {
  encode(message: StudentAttendanceCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(10).fork()).join();
    }
    if (message.counts !== undefined) {
      AttendanceCounts.encode(message.counts, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentAttendanceCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentAttendanceCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.counts = AttendanceCounts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentAttendanceCounts {
    return {
      student: isSet(object.student) ? Student.fromJSON(object.student) : undefined,
      counts: isSet(object.counts) ? AttendanceCounts.fromJSON(object.counts) : undefined,
    };
  },

  toJSON(message: StudentAttendanceCounts): unknown {
    const obj: any = {};
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    if (message.counts !== undefined) {
      obj.counts = AttendanceCounts.toJSON(message.counts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentAttendanceCounts>, I>>(base?: I): StudentAttendanceCounts {
    return StudentAttendanceCounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentAttendanceCounts>, I>>(object: I): StudentAttendanceCounts {
    const message = createBaseStudentAttendanceCounts();
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    message.counts = (object.counts !== undefined && object.counts !== null)
      ? AttendanceCounts.fromPartial(object.counts)
      : undefined;
    return message;
  },
};

function createBaseStudentsAttendanceCountsResponse(): StudentsAttendanceCountsResponse {
  return { studentCounts: [] };
}

export const StudentsAttendanceCountsResponse: MessageFns<StudentsAttendanceCountsResponse> = {
  encode(message: StudentsAttendanceCountsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.studentCounts) {
      StudentAttendanceCounts.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentsAttendanceCountsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentsAttendanceCountsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.studentCounts.push(StudentAttendanceCounts.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentsAttendanceCountsResponse {
    return {
      studentCounts: globalThis.Array.isArray(object?.studentCounts)
        ? object.studentCounts.map((e: any) => StudentAttendanceCounts.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StudentsAttendanceCountsResponse): unknown {
    const obj: any = {};
    if (message.studentCounts?.length) {
      obj.studentCounts = message.studentCounts.map((e) => StudentAttendanceCounts.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentsAttendanceCountsResponse>, I>>(
    base?: I,
  ): StudentsAttendanceCountsResponse {
    return StudentsAttendanceCountsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentsAttendanceCountsResponse>, I>>(
    object: I,
  ): StudentsAttendanceCountsResponse {
    const message = createBaseStudentsAttendanceCountsResponse();
    message.studentCounts = object.studentCounts?.map((e) => StudentAttendanceCounts.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCoursesAttendanceOverviewRequest(): GetCoursesAttendanceOverviewRequest {
  return { context: undefined, date: "", showAllClasses: false };
}

export const GetCoursesAttendanceOverviewRequest: MessageFns<GetCoursesAttendanceOverviewRequest> = {
  encode(message: GetCoursesAttendanceOverviewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.showAllClasses !== false) {
      writer.uint32(24).bool(message.showAllClasses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCoursesAttendanceOverviewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCoursesAttendanceOverviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.showAllClasses = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCoursesAttendanceOverviewRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      showAllClasses: isSet(object.showAllClasses) ? globalThis.Boolean(object.showAllClasses) : false,
    };
  },

  toJSON(message: GetCoursesAttendanceOverviewRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.showAllClasses !== false) {
      obj.showAllClasses = message.showAllClasses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCoursesAttendanceOverviewRequest>, I>>(
    base?: I,
  ): GetCoursesAttendanceOverviewRequest {
    return GetCoursesAttendanceOverviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCoursesAttendanceOverviewRequest>, I>>(
    object: I,
  ): GetCoursesAttendanceOverviewRequest {
    const message = createBaseGetCoursesAttendanceOverviewRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.date = object.date ?? "";
    message.showAllClasses = object.showAllClasses ?? false;
    return message;
  },
};

function createBaseGetCoursesAttendanceOverviewResponse(): GetCoursesAttendanceOverviewResponse {
  return { courses: [], teachers: [], entryStatus: [] };
}

export const GetCoursesAttendanceOverviewResponse: MessageFns<GetCoursesAttendanceOverviewResponse> = {
  encode(message: GetCoursesAttendanceOverviewResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.courses) {
      Course.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.teachers) {
      TeacherBasic.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.entryStatus) {
      CourseEntryStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCoursesAttendanceOverviewResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCoursesAttendanceOverviewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.courses.push(Course.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teachers.push(TeacherBasic.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryStatus.push(CourseEntryStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCoursesAttendanceOverviewResponse {
    return {
      courses: globalThis.Array.isArray(object?.courses) ? object.courses.map((e: any) => Course.fromJSON(e)) : [],
      teachers: globalThis.Array.isArray(object?.teachers)
        ? object.teachers.map((e: any) => TeacherBasic.fromJSON(e))
        : [],
      entryStatus: globalThis.Array.isArray(object?.entryStatus)
        ? object.entryStatus.map((e: any) => CourseEntryStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCoursesAttendanceOverviewResponse): unknown {
    const obj: any = {};
    if (message.courses?.length) {
      obj.courses = message.courses.map((e) => Course.toJSON(e));
    }
    if (message.teachers?.length) {
      obj.teachers = message.teachers.map((e) => TeacherBasic.toJSON(e));
    }
    if (message.entryStatus?.length) {
      obj.entryStatus = message.entryStatus.map((e) => CourseEntryStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCoursesAttendanceOverviewResponse>, I>>(
    base?: I,
  ): GetCoursesAttendanceOverviewResponse {
    return GetCoursesAttendanceOverviewResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCoursesAttendanceOverviewResponse>, I>>(
    object: I,
  ): GetCoursesAttendanceOverviewResponse {
    const message = createBaseGetCoursesAttendanceOverviewResponse();
    message.courses = object.courses?.map((e) => Course.fromPartial(e)) || [];
    message.teachers = object.teachers?.map((e) => TeacherBasic.fromPartial(e)) || [];
    message.entryStatus = object.entryStatus?.map((e) => CourseEntryStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCourseEntryStatus(): CourseEntryStatus {
  return { courseId: undefined, isComplete: false };
}

export const CourseEntryStatus: MessageFns<CourseEntryStatus> = {
  encode(message: CourseEntryStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(10).fork()).join();
    }
    if (message.isComplete !== false) {
      writer.uint32(16).bool(message.isComplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CourseEntryStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCourseEntryStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isComplete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CourseEntryStatus {
    return {
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      isComplete: isSet(object.isComplete) ? globalThis.Boolean(object.isComplete) : false,
    };
  },

  toJSON(message: CourseEntryStatus): unknown {
    const obj: any = {};
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.isComplete !== false) {
      obj.isComplete = message.isComplete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CourseEntryStatus>, I>>(base?: I): CourseEntryStatus {
    return CourseEntryStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CourseEntryStatus>, I>>(object: I): CourseEntryStatus {
    const message = createBaseCourseEntryStatus();
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.isComplete = object.isComplete ?? false;
    return message;
  },
};

function createBaseGetHomeroomsAttendanceOverviewRequest(): GetHomeroomsAttendanceOverviewRequest {
  return { context: undefined, date: "", showAllClasses: false };
}

export const GetHomeroomsAttendanceOverviewRequest: MessageFns<GetHomeroomsAttendanceOverviewRequest> = {
  encode(message: GetHomeroomsAttendanceOverviewRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    if (message.showAllClasses !== false) {
      writer.uint32(24).bool(message.showAllClasses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHomeroomsAttendanceOverviewRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHomeroomsAttendanceOverviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.showAllClasses = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHomeroomsAttendanceOverviewRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      showAllClasses: isSet(object.showAllClasses) ? globalThis.Boolean(object.showAllClasses) : false,
    };
  },

  toJSON(message: GetHomeroomsAttendanceOverviewRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.showAllClasses !== false) {
      obj.showAllClasses = message.showAllClasses;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHomeroomsAttendanceOverviewRequest>, I>>(
    base?: I,
  ): GetHomeroomsAttendanceOverviewRequest {
    return GetHomeroomsAttendanceOverviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHomeroomsAttendanceOverviewRequest>, I>>(
    object: I,
  ): GetHomeroomsAttendanceOverviewRequest {
    const message = createBaseGetHomeroomsAttendanceOverviewRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.date = object.date ?? "";
    message.showAllClasses = object.showAllClasses ?? false;
    return message;
  },
};

function createBaseGetHomeroomsAttendanceOverviewResponse(): GetHomeroomsAttendanceOverviewResponse {
  return { homerooms: [], teachers: [], entryStatus: [] };
}

export const GetHomeroomsAttendanceOverviewResponse: MessageFns<GetHomeroomsAttendanceOverviewResponse> = {
  encode(message: GetHomeroomsAttendanceOverviewResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.homerooms) {
      Homeroom.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.teachers) {
      TeacherBasic.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.entryStatus) {
      HomeroomEntryStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHomeroomsAttendanceOverviewResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHomeroomsAttendanceOverviewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.homerooms.push(Homeroom.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teachers.push(TeacherBasic.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryStatus.push(HomeroomEntryStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHomeroomsAttendanceOverviewResponse {
    return {
      homerooms: globalThis.Array.isArray(object?.homerooms)
        ? object.homerooms.map((e: any) => Homeroom.fromJSON(e))
        : [],
      teachers: globalThis.Array.isArray(object?.teachers)
        ? object.teachers.map((e: any) => TeacherBasic.fromJSON(e))
        : [],
      entryStatus: globalThis.Array.isArray(object?.entryStatus)
        ? object.entryStatus.map((e: any) => HomeroomEntryStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetHomeroomsAttendanceOverviewResponse): unknown {
    const obj: any = {};
    if (message.homerooms?.length) {
      obj.homerooms = message.homerooms.map((e) => Homeroom.toJSON(e));
    }
    if (message.teachers?.length) {
      obj.teachers = message.teachers.map((e) => TeacherBasic.toJSON(e));
    }
    if (message.entryStatus?.length) {
      obj.entryStatus = message.entryStatus.map((e) => HomeroomEntryStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHomeroomsAttendanceOverviewResponse>, I>>(
    base?: I,
  ): GetHomeroomsAttendanceOverviewResponse {
    return GetHomeroomsAttendanceOverviewResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHomeroomsAttendanceOverviewResponse>, I>>(
    object: I,
  ): GetHomeroomsAttendanceOverviewResponse {
    const message = createBaseGetHomeroomsAttendanceOverviewResponse();
    message.homerooms = object.homerooms?.map((e) => Homeroom.fromPartial(e)) || [];
    message.teachers = object.teachers?.map((e) => TeacherBasic.fromPartial(e)) || [];
    message.entryStatus = object.entryStatus?.map((e) => HomeroomEntryStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHomeroomEntryStatus(): HomeroomEntryStatus {
  return { homeroomId: undefined, isComplete: false };
}

export const HomeroomEntryStatus: MessageFns<HomeroomEntryStatus> = {
  encode(message: HomeroomEntryStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(10).fork()).join();
    }
    if (message.isComplete !== false) {
      writer.uint32(16).bool(message.isComplete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HomeroomEntryStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHomeroomEntryStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isComplete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HomeroomEntryStatus {
    return {
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
      isComplete: isSet(object.isComplete) ? globalThis.Boolean(object.isComplete) : false,
    };
  },

  toJSON(message: HomeroomEntryStatus): unknown {
    const obj: any = {};
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    if (message.isComplete !== false) {
      obj.isComplete = message.isComplete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HomeroomEntryStatus>, I>>(base?: I): HomeroomEntryStatus {
    return HomeroomEntryStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HomeroomEntryStatus>, I>>(object: I): HomeroomEntryStatus {
    const message = createBaseHomeroomEntryStatus();
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    message.isComplete = object.isComplete ?? false;
    return message;
  },
};

function createBaseGetHomeroomAttendanceDetailsRequest(): GetHomeroomAttendanceDetailsRequest {
  return { context: undefined, homeroomId: undefined, date: "", periodNumber: 0 };
}

export const GetHomeroomAttendanceDetailsRequest: MessageFns<GetHomeroomAttendanceDetailsRequest> = {
  encode(message: GetHomeroomAttendanceDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(18).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.periodNumber !== 0) {
      writer.uint32(32).uint32(message.periodNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHomeroomAttendanceDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHomeroomAttendanceDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.periodNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHomeroomAttendanceDetailsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      periodNumber: isSet(object.periodNumber) ? globalThis.Number(object.periodNumber) : 0,
    };
  },

  toJSON(message: GetHomeroomAttendanceDetailsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.periodNumber !== 0) {
      obj.periodNumber = Math.round(message.periodNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHomeroomAttendanceDetailsRequest>, I>>(
    base?: I,
  ): GetHomeroomAttendanceDetailsRequest {
    return GetHomeroomAttendanceDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHomeroomAttendanceDetailsRequest>, I>>(
    object: I,
  ): GetHomeroomAttendanceDetailsRequest {
    const message = createBaseGetHomeroomAttendanceDetailsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    message.date = object.date ?? "";
    message.periodNumber = object.periodNumber ?? 0;
    return message;
  },
};

function createBaseGetHomeroomAttendanceDetailsResponse(): GetHomeroomAttendanceDetailsResponse {
  return { homeroom: undefined, students: [], attendanceEntries: [] };
}

export const GetHomeroomAttendanceDetailsResponse: MessageFns<GetHomeroomAttendanceDetailsResponse> = {
  encode(message: GetHomeroomAttendanceDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.homeroom !== undefined) {
      Homeroom.encode(message.homeroom, writer.uint32(10).fork()).join();
    }
    for (const v of message.students) {
      Student.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.attendanceEntries) {
      Attendance.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHomeroomAttendanceDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHomeroomAttendanceDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.homeroom = Homeroom.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.students.push(Student.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attendanceEntries.push(Attendance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHomeroomAttendanceDetailsResponse {
    return {
      homeroom: isSet(object.homeroom) ? Homeroom.fromJSON(object.homeroom) : undefined,
      students: globalThis.Array.isArray(object?.students) ? object.students.map((e: any) => Student.fromJSON(e)) : [],
      attendanceEntries: globalThis.Array.isArray(object?.attendanceEntries)
        ? object.attendanceEntries.map((e: any) => Attendance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetHomeroomAttendanceDetailsResponse): unknown {
    const obj: any = {};
    if (message.homeroom !== undefined) {
      obj.homeroom = Homeroom.toJSON(message.homeroom);
    }
    if (message.students?.length) {
      obj.students = message.students.map((e) => Student.toJSON(e));
    }
    if (message.attendanceEntries?.length) {
      obj.attendanceEntries = message.attendanceEntries.map((e) => Attendance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHomeroomAttendanceDetailsResponse>, I>>(
    base?: I,
  ): GetHomeroomAttendanceDetailsResponse {
    return GetHomeroomAttendanceDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHomeroomAttendanceDetailsResponse>, I>>(
    object: I,
  ): GetHomeroomAttendanceDetailsResponse {
    const message = createBaseGetHomeroomAttendanceDetailsResponse();
    message.homeroom = (object.homeroom !== undefined && object.homeroom !== null)
      ? Homeroom.fromPartial(object.homeroom)
      : undefined;
    message.students = object.students?.map((e) => Student.fromPartial(e)) || [];
    message.attendanceEntries = object.attendanceEntries?.map((e) => Attendance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSingleStudentHomeroomAttendanceEntryRequest(): GetSingleStudentHomeroomAttendanceEntryRequest {
  return { context: undefined, studentId: undefined, homeroomId: undefined, date: "" };
}

export const GetSingleStudentHomeroomAttendanceEntryRequest: MessageFns<
  GetSingleStudentHomeroomAttendanceEntryRequest
> = {
  encode(
    message: GetSingleStudentHomeroomAttendanceEntryRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    if (message.homeroomId !== undefined) {
      ObjectId.encode(message.homeroomId, writer.uint32(26).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(34).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSingleStudentHomeroomAttendanceEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSingleStudentHomeroomAttendanceEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.homeroomId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.date = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSingleStudentHomeroomAttendanceEntryRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
      homeroomId: isSet(object.homeroomId) ? ObjectId.fromJSON(object.homeroomId) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
    };
  },

  toJSON(message: GetSingleStudentHomeroomAttendanceEntryRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    if (message.homeroomId !== undefined) {
      obj.homeroomId = ObjectId.toJSON(message.homeroomId);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSingleStudentHomeroomAttendanceEntryRequest>, I>>(
    base?: I,
  ): GetSingleStudentHomeroomAttendanceEntryRequest {
    return GetSingleStudentHomeroomAttendanceEntryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSingleStudentHomeroomAttendanceEntryRequest>, I>>(
    object: I,
  ): GetSingleStudentHomeroomAttendanceEntryRequest {
    const message = createBaseGetSingleStudentHomeroomAttendanceEntryRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    message.homeroomId = (object.homeroomId !== undefined && object.homeroomId !== null)
      ? ObjectId.fromPartial(object.homeroomId)
      : undefined;
    message.date = object.date ?? "";
    return message;
  },
};

function createBaseGetSingleStudentHomeroomAttendanceEntryResponse(): GetSingleStudentHomeroomAttendanceEntryResponse {
  return { student: undefined, attendanceEntry: undefined, homeroom: undefined };
}

export const GetSingleStudentHomeroomAttendanceEntryResponse: MessageFns<
  GetSingleStudentHomeroomAttendanceEntryResponse
> = {
  encode(
    message: GetSingleStudentHomeroomAttendanceEntryResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.student !== undefined) {
      Student.encode(message.student, writer.uint32(10).fork()).join();
    }
    if (message.attendanceEntry !== undefined) {
      Attendance.encode(message.attendanceEntry, writer.uint32(18).fork()).join();
    }
    if (message.homeroom !== undefined) {
      Homeroom.encode(message.homeroom, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSingleStudentHomeroomAttendanceEntryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSingleStudentHomeroomAttendanceEntryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.student = Student.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attendanceEntry = Attendance.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.homeroom = Homeroom.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSingleStudentHomeroomAttendanceEntryResponse {
    return {
      student: isSet(object.student) ? Student.fromJSON(object.student) : undefined,
      attendanceEntry: isSet(object.attendanceEntry) ? Attendance.fromJSON(object.attendanceEntry) : undefined,
      homeroom: isSet(object.homeroom) ? Homeroom.fromJSON(object.homeroom) : undefined,
    };
  },

  toJSON(message: GetSingleStudentHomeroomAttendanceEntryResponse): unknown {
    const obj: any = {};
    if (message.student !== undefined) {
      obj.student = Student.toJSON(message.student);
    }
    if (message.attendanceEntry !== undefined) {
      obj.attendanceEntry = Attendance.toJSON(message.attendanceEntry);
    }
    if (message.homeroom !== undefined) {
      obj.homeroom = Homeroom.toJSON(message.homeroom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSingleStudentHomeroomAttendanceEntryResponse>, I>>(
    base?: I,
  ): GetSingleStudentHomeroomAttendanceEntryResponse {
    return GetSingleStudentHomeroomAttendanceEntryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSingleStudentHomeroomAttendanceEntryResponse>, I>>(
    object: I,
  ): GetSingleStudentHomeroomAttendanceEntryResponse {
    const message = createBaseGetSingleStudentHomeroomAttendanceEntryResponse();
    message.student = (object.student !== undefined && object.student !== null)
      ? Student.fromPartial(object.student)
      : undefined;
    message.attendanceEntry = (object.attendanceEntry !== undefined && object.attendanceEntry !== null)
      ? Attendance.fromPartial(object.attendanceEntry)
      : undefined;
    message.homeroom = (object.homeroom !== undefined && object.homeroom !== null)
      ? Homeroom.fromPartial(object.homeroom)
      : undefined;
    return message;
  },
};

function createBaseGetAttendanceDateMapRequest(): GetAttendanceDateMapRequest {
  return { context: undefined, classRef: undefined, startDate: "", endDate: "" };
}

export const GetAttendanceDateMapRequest: MessageFns<GetAttendanceDateMapRequest> = {
  encode(message: GetAttendanceDateMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.classRef !== undefined) {
      ClassRef.encode(message.classRef, writer.uint32(18).fork()).join();
    }
    if (message.startDate !== "") {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(34).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttendanceDateMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttendanceDateMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classRef = ClassRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttendanceDateMapRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      classRef: isSet(object.classRef) ? ClassRef.fromJSON(object.classRef) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: GetAttendanceDateMapRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.classRef !== undefined) {
      obj.classRef = ClassRef.toJSON(message.classRef);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttendanceDateMapRequest>, I>>(base?: I): GetAttendanceDateMapRequest {
    return GetAttendanceDateMapRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttendanceDateMapRequest>, I>>(object: I): GetAttendanceDateMapRequest {
    const message = createBaseGetAttendanceDateMapRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.classRef = (object.classRef !== undefined && object.classRef !== null)
      ? ClassRef.fromPartial(object.classRef)
      : undefined;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseGetAttendanceDateMapResponse(): GetAttendanceDateMapResponse {
  return { entries: [] };
}

export const GetAttendanceDateMapResponse: MessageFns<GetAttendanceDateMapResponse> = {
  encode(message: GetAttendanceDateMapResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      AttendanceDateMapEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttendanceDateMapResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttendanceDateMapResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(AttendanceDateMapEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttendanceDateMapResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => AttendanceDateMapEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAttendanceDateMapResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => AttendanceDateMapEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttendanceDateMapResponse>, I>>(base?: I): GetAttendanceDateMapResponse {
    return GetAttendanceDateMapResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttendanceDateMapResponse>, I>>(object: I): GetAttendanceDateMapResponse {
    const message = createBaseGetAttendanceDateMapResponse();
    message.entries = object.entries?.map((e) => AttendanceDateMapEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttendanceDateMapEntry(): AttendanceDateMapEntry {
  return { date: "", completionStatus: AttendanceCompletionStatus.EMPTY };
}

export const AttendanceDateMapEntry: MessageFns<AttendanceDateMapEntry> = {
  encode(message: AttendanceDateMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.completionStatus !== AttendanceCompletionStatus.EMPTY) {
      writer.uint32(16).int32(attendanceCompletionStatusToNumber(message.completionStatus));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttendanceDateMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttendanceDateMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionStatus = attendanceCompletionStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttendanceDateMapEntry {
    return {
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      completionStatus: isSet(object.completionStatus)
        ? attendanceCompletionStatusFromJSON(object.completionStatus)
        : AttendanceCompletionStatus.EMPTY,
    };
  },

  toJSON(message: AttendanceDateMapEntry): unknown {
    const obj: any = {};
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.completionStatus !== AttendanceCompletionStatus.EMPTY) {
      obj.completionStatus = attendanceCompletionStatusToJSON(message.completionStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttendanceDateMapEntry>, I>>(base?: I): AttendanceDateMapEntry {
    return AttendanceDateMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttendanceDateMapEntry>, I>>(object: I): AttendanceDateMapEntry {
    const message = createBaseAttendanceDateMapEntry();
    message.date = object.date ?? "";
    message.completionStatus = object.completionStatus ?? AttendanceCompletionStatus.EMPTY;
    return message;
  },
};

function createBaseGetAttendanceCsvDataRequest(): GetAttendanceCsvDataRequest {
  return { context: undefined, classRef: undefined, startDate: "", endDate: "" };
}

export const GetAttendanceCsvDataRequest: MessageFns<GetAttendanceCsvDataRequest> = {
  encode(message: GetAttendanceCsvDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.classRef !== undefined) {
      ClassRef.encode(message.classRef, writer.uint32(18).fork()).join();
    }
    if (message.startDate !== "") {
      writer.uint32(26).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(34).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttendanceCsvDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttendanceCsvDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classRef = ClassRef.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttendanceCsvDataRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      classRef: isSet(object.classRef) ? ClassRef.fromJSON(object.classRef) : undefined,
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: GetAttendanceCsvDataRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.classRef !== undefined) {
      obj.classRef = ClassRef.toJSON(message.classRef);
    }
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttendanceCsvDataRequest>, I>>(base?: I): GetAttendanceCsvDataRequest {
    return GetAttendanceCsvDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttendanceCsvDataRequest>, I>>(object: I): GetAttendanceCsvDataRequest {
    const message = createBaseGetAttendanceCsvDataRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.classRef = (object.classRef !== undefined && object.classRef !== null)
      ? ClassRef.fromPartial(object.classRef)
      : undefined;
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseGetAttendanceCsvDataResponse(): GetAttendanceCsvDataResponse {
  return { csvData: "", filename: "" };
}

export const GetAttendanceCsvDataResponse: MessageFns<GetAttendanceCsvDataResponse> = {
  encode(message: GetAttendanceCsvDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.csvData !== "") {
      writer.uint32(10).string(message.csvData);
    }
    if (message.filename !== "") {
      writer.uint32(18).string(message.filename);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttendanceCsvDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttendanceCsvDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.csvData = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttendanceCsvDataResponse {
    return {
      csvData: isSet(object.csvData) ? globalThis.String(object.csvData) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
    };
  },

  toJSON(message: GetAttendanceCsvDataResponse): unknown {
    const obj: any = {};
    if (message.csvData !== "") {
      obj.csvData = message.csvData;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAttendanceCsvDataResponse>, I>>(base?: I): GetAttendanceCsvDataResponse {
    return GetAttendanceCsvDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAttendanceCsvDataResponse>, I>>(object: I): GetAttendanceCsvDataResponse {
    const message = createBaseGetAttendanceCsvDataResponse();
    message.csvData = object.csvData ?? "";
    message.filename = object.filename ?? "";
    return message;
  },
};

function createBaseGetCourseAttendanceDetailsRequest(): GetCourseAttendanceDetailsRequest {
  return { context: undefined, courseId: undefined, date: "", periodNumber: 0 };
}

export const GetCourseAttendanceDetailsRequest: MessageFns<GetCourseAttendanceDetailsRequest> = {
  encode(message: GetCourseAttendanceDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(18).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.periodNumber !== 0) {
      writer.uint32(32).uint32(message.periodNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCourseAttendanceDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCourseAttendanceDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.periodNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCourseAttendanceDetailsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      periodNumber: isSet(object.periodNumber) ? globalThis.Number(object.periodNumber) : 0,
    };
  },

  toJSON(message: GetCourseAttendanceDetailsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.periodNumber !== 0) {
      obj.periodNumber = Math.round(message.periodNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCourseAttendanceDetailsRequest>, I>>(
    base?: I,
  ): GetCourseAttendanceDetailsRequest {
    return GetCourseAttendanceDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCourseAttendanceDetailsRequest>, I>>(
    object: I,
  ): GetCourseAttendanceDetailsRequest {
    const message = createBaseGetCourseAttendanceDetailsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.date = object.date ?? "";
    message.periodNumber = object.periodNumber ?? 0;
    return message;
  },
};

function createBaseGetCourseAttendanceDetailsResponse(): GetCourseAttendanceDetailsResponse {
  return { course: undefined, students: [], attendanceEntries: [] };
}

export const GetCourseAttendanceDetailsResponse: MessageFns<GetCourseAttendanceDetailsResponse> = {
  encode(message: GetCourseAttendanceDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.course !== undefined) {
      Course.encode(message.course, writer.uint32(10).fork()).join();
    }
    for (const v of message.students) {
      Student.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.attendanceEntries) {
      Attendance.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCourseAttendanceDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCourseAttendanceDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.course = Course.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.students.push(Student.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attendanceEntries.push(Attendance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCourseAttendanceDetailsResponse {
    return {
      course: isSet(object.course) ? Course.fromJSON(object.course) : undefined,
      students: globalThis.Array.isArray(object?.students) ? object.students.map((e: any) => Student.fromJSON(e)) : [],
      attendanceEntries: globalThis.Array.isArray(object?.attendanceEntries)
        ? object.attendanceEntries.map((e: any) => Attendance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetCourseAttendanceDetailsResponse): unknown {
    const obj: any = {};
    if (message.course !== undefined) {
      obj.course = Course.toJSON(message.course);
    }
    if (message.students?.length) {
      obj.students = message.students.map((e) => Student.toJSON(e));
    }
    if (message.attendanceEntries?.length) {
      obj.attendanceEntries = message.attendanceEntries.map((e) => Attendance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCourseAttendanceDetailsResponse>, I>>(
    base?: I,
  ): GetCourseAttendanceDetailsResponse {
    return GetCourseAttendanceDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCourseAttendanceDetailsResponse>, I>>(
    object: I,
  ): GetCourseAttendanceDetailsResponse {
    const message = createBaseGetCourseAttendanceDetailsResponse();
    message.course = (object.course !== undefined && object.course !== null)
      ? Course.fromPartial(object.course)
      : undefined;
    message.students = object.students?.map((e) => Student.fromPartial(e)) || [];
    message.attendanceEntries = object.attendanceEntries?.map((e) => Attendance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSingleStudentCourseAttendanceEntryRequest(): GetSingleStudentCourseAttendanceEntryRequest {
  return { context: undefined, studentId: undefined, courseId: undefined, date: "", periodNumber: 0 };
}

export const GetSingleStudentCourseAttendanceEntryRequest: MessageFns<GetSingleStudentCourseAttendanceEntryRequest> = {
  encode(
    message: GetSingleStudentCourseAttendanceEntryRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    if (message.courseId !== undefined) {
      ObjectId.encode(message.courseId, writer.uint32(26).fork()).join();
    }
    if (message.date !== "") {
      writer.uint32(34).string(message.date);
    }
    if (message.periodNumber !== 0) {
      writer.uint32(40).uint32(message.periodNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSingleStudentCourseAttendanceEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSingleStudentCourseAttendanceEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.courseId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.date = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.periodNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSingleStudentCourseAttendanceEntryRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
      courseId: isSet(object.courseId) ? ObjectId.fromJSON(object.courseId) : undefined,
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      periodNumber: isSet(object.periodNumber) ? globalThis.Number(object.periodNumber) : 0,
    };
  },

  toJSON(message: GetSingleStudentCourseAttendanceEntryRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    if (message.courseId !== undefined) {
      obj.courseId = ObjectId.toJSON(message.courseId);
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.periodNumber !== 0) {
      obj.periodNumber = Math.round(message.periodNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSingleStudentCourseAttendanceEntryRequest>, I>>(
    base?: I,
  ): GetSingleStudentCourseAttendanceEntryRequest {
    return GetSingleStudentCourseAttendanceEntryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSingleStudentCourseAttendanceEntryRequest>, I>>(
    object: I,
  ): GetSingleStudentCourseAttendanceEntryRequest {
    const message = createBaseGetSingleStudentCourseAttendanceEntryRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    message.courseId = (object.courseId !== undefined && object.courseId !== null)
      ? ObjectId.fromPartial(object.courseId)
      : undefined;
    message.date = object.date ?? "";
    message.periodNumber = object.periodNumber ?? 0;
    return message;
  },
};

function createBaseGetSingleStudentCourseAttendanceEntryResponse(): GetSingleStudentCourseAttendanceEntryResponse {
  return { student: undefined, attendanceEntry: undefined, course: undefined };
}

export const GetSingleStudentCourseAttendanceEntryResponse: MessageFns<GetSingleStudentCourseAttendanceEntryResponse> =
  {
    encode(
      message: GetSingleStudentCourseAttendanceEntryResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.student !== undefined) {
        Student.encode(message.student, writer.uint32(10).fork()).join();
      }
      if (message.attendanceEntry !== undefined) {
        Attendance.encode(message.attendanceEntry, writer.uint32(18).fork()).join();
      }
      if (message.course !== undefined) {
        Course.encode(message.course, writer.uint32(26).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetSingleStudentCourseAttendanceEntryResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetSingleStudentCourseAttendanceEntryResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.student = Student.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.attendanceEntry = Attendance.decode(reader, reader.uint32());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.course = Course.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetSingleStudentCourseAttendanceEntryResponse {
      return {
        student: isSet(object.student) ? Student.fromJSON(object.student) : undefined,
        attendanceEntry: isSet(object.attendanceEntry) ? Attendance.fromJSON(object.attendanceEntry) : undefined,
        course: isSet(object.course) ? Course.fromJSON(object.course) : undefined,
      };
    },

    toJSON(message: GetSingleStudentCourseAttendanceEntryResponse): unknown {
      const obj: any = {};
      if (message.student !== undefined) {
        obj.student = Student.toJSON(message.student);
      }
      if (message.attendanceEntry !== undefined) {
        obj.attendanceEntry = Attendance.toJSON(message.attendanceEntry);
      }
      if (message.course !== undefined) {
        obj.course = Course.toJSON(message.course);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetSingleStudentCourseAttendanceEntryResponse>, I>>(
      base?: I,
    ): GetSingleStudentCourseAttendanceEntryResponse {
      return GetSingleStudentCourseAttendanceEntryResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetSingleStudentCourseAttendanceEntryResponse>, I>>(
      object: I,
    ): GetSingleStudentCourseAttendanceEntryResponse {
      const message = createBaseGetSingleStudentCourseAttendanceEntryResponse();
      message.student = (object.student !== undefined && object.student !== null)
        ? Student.fromPartial(object.student)
        : undefined;
      message.attendanceEntry = (object.attendanceEntry !== undefined && object.attendanceEntry !== null)
        ? Attendance.fromPartial(object.attendanceEntry)
        : undefined;
      message.course = (object.course !== undefined && object.course !== null)
        ? Course.fromPartial(object.course)
        : undefined;
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

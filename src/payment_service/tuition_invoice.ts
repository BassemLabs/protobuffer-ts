// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/tuition_invoice.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ObjectId } from "../utils/object_id";
import {
  PaymentInstallment,
  PaymentScheduleType,
  paymentScheduleTypeFromJSON,
  paymentScheduleTypeToJSON,
  paymentScheduleTypeToNumber,
  Scope,
  scopeFromJSON,
  scopeToJSON,
  scopeToNumber,
} from "./tuition";

export const protobufPackage = "payment_service";

export enum LineType {
  BASE_RATE = "BASE_RATE",
  ADD_FEE = "ADD_FEE",
  DISCOUNT = "DISCOUNT",
  BASSEM_LABS_FEE = "BASSEM_LABS_FEE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function lineTypeFromJSON(object: any): LineType {
  switch (object) {
    case 1:
    case "BASE_RATE":
      return LineType.BASE_RATE;
    case 2:
    case "ADD_FEE":
      return LineType.ADD_FEE;
    case 3:
    case "DISCOUNT":
      return LineType.DISCOUNT;
    case 4:
    case "BASSEM_LABS_FEE":
      return LineType.BASSEM_LABS_FEE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LineType.UNRECOGNIZED;
  }
}

export function lineTypeToJSON(object: LineType): string {
  switch (object) {
    case LineType.BASE_RATE:
      return "BASE_RATE";
    case LineType.ADD_FEE:
      return "ADD_FEE";
    case LineType.DISCOUNT:
      return "DISCOUNT";
    case LineType.BASSEM_LABS_FEE:
      return "BASSEM_LABS_FEE";
    case LineType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function lineTypeToNumber(object: LineType): number {
  switch (object) {
    case LineType.BASE_RATE:
      return 1;
    case LineType.ADD_FEE:
      return 2;
    case LineType.DISCOUNT:
      return 3;
    case LineType.BASSEM_LABS_FEE:
      return 4;
    case LineType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TuitionPlanSnapshot {
  name: string;
  scheduleType: PaymentScheduleType;
  dayOfMonth?: number | undefined;
  installments: PaymentInstallment[];
}

export interface TuitionInvoiceLineItem {
  lineType: LineType;
  scope: Scope;
  /** present when scope = STUDENT_SCOPE */
  student?: ObjectId | undefined;
  name: string;
  /** might be negative for discounts */
  amount: number;
}

export interface TuitionInvoice {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  schoolYear: ObjectId | undefined;
  family: ObjectId | undefined;
  tuitionPlan: TuitionPlanSnapshot | undefined;
  lineItems: TuitionInvoiceLineItem[];
  totalGross: number;
  totalDiscounts: number;
  totalNet: number;
}

function createBaseTuitionPlanSnapshot(): TuitionPlanSnapshot {
  return { name: "", scheduleType: PaymentScheduleType.ONE_TIME, dayOfMonth: 0, installments: [] };
}

export const TuitionPlanSnapshot: MessageFns<TuitionPlanSnapshot> = {
  encode(message: TuitionPlanSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.scheduleType !== PaymentScheduleType.ONE_TIME) {
      writer.uint32(16).int32(paymentScheduleTypeToNumber(message.scheduleType));
    }
    if (message.dayOfMonth !== undefined && message.dayOfMonth !== 0) {
      writer.uint32(24).int32(message.dayOfMonth);
    }
    for (const v of message.installments) {
      PaymentInstallment.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionPlanSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionPlanSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scheduleType = paymentScheduleTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dayOfMonth = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.installments.push(PaymentInstallment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionPlanSnapshot {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      scheduleType: isSet(object.scheduleType)
        ? paymentScheduleTypeFromJSON(object.scheduleType)
        : PaymentScheduleType.ONE_TIME,
      dayOfMonth: isSet(object.dayOfMonth) ? globalThis.Number(object.dayOfMonth) : 0,
      installments: globalThis.Array.isArray(object?.installments)
        ? object.installments.map((e: any) => PaymentInstallment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TuitionPlanSnapshot): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.scheduleType !== PaymentScheduleType.ONE_TIME) {
      obj.scheduleType = paymentScheduleTypeToJSON(message.scheduleType);
    }
    if (message.dayOfMonth !== undefined && message.dayOfMonth !== 0) {
      obj.dayOfMonth = Math.round(message.dayOfMonth);
    }
    if (message.installments?.length) {
      obj.installments = message.installments.map((e) => PaymentInstallment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionPlanSnapshot>, I>>(base?: I): TuitionPlanSnapshot {
    return TuitionPlanSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionPlanSnapshot>, I>>(object: I): TuitionPlanSnapshot {
    const message = createBaseTuitionPlanSnapshot();
    message.name = object.name ?? "";
    message.scheduleType = object.scheduleType ?? PaymentScheduleType.ONE_TIME;
    message.dayOfMonth = object.dayOfMonth ?? 0;
    message.installments = object.installments?.map((e) => PaymentInstallment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTuitionInvoiceLineItem(): TuitionInvoiceLineItem {
  return { lineType: LineType.BASE_RATE, scope: Scope.STUDENT_SCOPE, student: undefined, name: "", amount: 0 };
}

export const TuitionInvoiceLineItem: MessageFns<TuitionInvoiceLineItem> = {
  encode(message: TuitionInvoiceLineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lineType !== LineType.BASE_RATE) {
      writer.uint32(8).int32(lineTypeToNumber(message.lineType));
    }
    if (message.scope !== Scope.STUDENT_SCOPE) {
      writer.uint32(16).int32(scopeToNumber(message.scope));
    }
    if (message.student !== undefined) {
      ObjectId.encode(message.student, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.amount !== 0) {
      writer.uint32(41).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionInvoiceLineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionInvoiceLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lineType = lineTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scope = scopeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.student = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionInvoiceLineItem {
    return {
      lineType: isSet(object.lineType) ? lineTypeFromJSON(object.lineType) : LineType.BASE_RATE,
      scope: isSet(object.scope) ? scopeFromJSON(object.scope) : Scope.STUDENT_SCOPE,
      student: isSet(object.student) ? ObjectId.fromJSON(object.student) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: TuitionInvoiceLineItem): unknown {
    const obj: any = {};
    if (message.lineType !== LineType.BASE_RATE) {
      obj.lineType = lineTypeToJSON(message.lineType);
    }
    if (message.scope !== Scope.STUDENT_SCOPE) {
      obj.scope = scopeToJSON(message.scope);
    }
    if (message.student !== undefined) {
      obj.student = ObjectId.toJSON(message.student);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionInvoiceLineItem>, I>>(base?: I): TuitionInvoiceLineItem {
    return TuitionInvoiceLineItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionInvoiceLineItem>, I>>(object: I): TuitionInvoiceLineItem {
    const message = createBaseTuitionInvoiceLineItem();
    message.lineType = object.lineType ?? LineType.BASE_RATE;
    message.scope = object.scope ?? Scope.STUDENT_SCOPE;
    message.student = (object.student !== undefined && object.student !== null)
      ? ObjectId.fromPartial(object.student)
      : undefined;
    message.name = object.name ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseTuitionInvoice(): TuitionInvoice {
  return {
    id: undefined,
    organization: undefined,
    schoolYear: undefined,
    family: undefined,
    tuitionPlan: undefined,
    lineItems: [],
    totalGross: 0,
    totalDiscounts: 0,
    totalNet: 0,
  };
}

export const TuitionInvoice: MessageFns<TuitionInvoice> = {
  encode(message: TuitionInvoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(26).fork()).join();
    }
    if (message.family !== undefined) {
      ObjectId.encode(message.family, writer.uint32(34).fork()).join();
    }
    if (message.tuitionPlan !== undefined) {
      TuitionPlanSnapshot.encode(message.tuitionPlan, writer.uint32(42).fork()).join();
    }
    for (const v of message.lineItems) {
      TuitionInvoiceLineItem.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.totalGross !== 0) {
      writer.uint32(57).double(message.totalGross);
    }
    if (message.totalDiscounts !== 0) {
      writer.uint32(65).double(message.totalDiscounts);
    }
    if (message.totalNet !== 0) {
      writer.uint32(73).double(message.totalNet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionInvoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionInvoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.family = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tuitionPlan = TuitionPlanSnapshot.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lineItems.push(TuitionInvoiceLineItem.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.totalGross = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.totalDiscounts = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.totalNet = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionInvoice {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
      family: isSet(object.family) ? ObjectId.fromJSON(object.family) : undefined,
      tuitionPlan: isSet(object.tuitionPlan) ? TuitionPlanSnapshot.fromJSON(object.tuitionPlan) : undefined,
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => TuitionInvoiceLineItem.fromJSON(e))
        : [],
      totalGross: isSet(object.totalGross) ? globalThis.Number(object.totalGross) : 0,
      totalDiscounts: isSet(object.totalDiscounts) ? globalThis.Number(object.totalDiscounts) : 0,
      totalNet: isSet(object.totalNet) ? globalThis.Number(object.totalNet) : 0,
    };
  },

  toJSON(message: TuitionInvoice): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    if (message.family !== undefined) {
      obj.family = ObjectId.toJSON(message.family);
    }
    if (message.tuitionPlan !== undefined) {
      obj.tuitionPlan = TuitionPlanSnapshot.toJSON(message.tuitionPlan);
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => TuitionInvoiceLineItem.toJSON(e));
    }
    if (message.totalGross !== 0) {
      obj.totalGross = message.totalGross;
    }
    if (message.totalDiscounts !== 0) {
      obj.totalDiscounts = message.totalDiscounts;
    }
    if (message.totalNet !== 0) {
      obj.totalNet = message.totalNet;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionInvoice>, I>>(base?: I): TuitionInvoice {
    return TuitionInvoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionInvoice>, I>>(object: I): TuitionInvoice {
    const message = createBaseTuitionInvoice();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? ObjectId.fromPartial(object.family)
      : undefined;
    message.tuitionPlan = (object.tuitionPlan !== undefined && object.tuitionPlan !== null)
      ? TuitionPlanSnapshot.fromPartial(object.tuitionPlan)
      : undefined;
    message.lineItems = object.lineItems?.map((e) => TuitionInvoiceLineItem.fromPartial(e)) || [];
    message.totalGross = object.totalGross ?? 0;
    message.totalDiscounts = object.totalDiscounts ?? 0;
    message.totalNet = object.totalNet ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

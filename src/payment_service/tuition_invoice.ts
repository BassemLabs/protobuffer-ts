// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/tuition_invoice.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  StudentStatus,
  studentStatusFromJSON,
  studentStatusToJSON,
  studentStatusToNumber,
} from "../user_service/student";
import { ObjectId } from "../utils/object_id";
import {
  PaymentInstallment,
  PaymentScheduleType,
  paymentScheduleTypeFromJSON,
  paymentScheduleTypeToJSON,
  paymentScheduleTypeToNumber,
  Scope,
  scopeFromJSON,
  scopeToJSON,
  scopeToNumber,
} from "./tuition";

export const protobufPackage = "payment_service";

export enum LineType {
  BASE_RATE = "BASE_RATE",
  ADD_FEE = "ADD_FEE",
  DISCOUNT = "DISCOUNT",
  BASSEM_LABS_FEE = "BASSEM_LABS_FEE",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function lineTypeFromJSON(object: any): LineType {
  switch (object) {
    case 1:
    case "BASE_RATE":
      return LineType.BASE_RATE;
    case 2:
    case "ADD_FEE":
      return LineType.ADD_FEE;
    case 3:
    case "DISCOUNT":
      return LineType.DISCOUNT;
    case 4:
    case "BASSEM_LABS_FEE":
      return LineType.BASSEM_LABS_FEE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LineType.UNRECOGNIZED;
  }
}

export function lineTypeToJSON(object: LineType): string {
  switch (object) {
    case LineType.BASE_RATE:
      return "BASE_RATE";
    case LineType.ADD_FEE:
      return "ADD_FEE";
    case LineType.DISCOUNT:
      return "DISCOUNT";
    case LineType.BASSEM_LABS_FEE:
      return "BASSEM_LABS_FEE";
    case LineType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function lineTypeToNumber(object: LineType): number {
  switch (object) {
    case LineType.BASE_RATE:
      return 1;
    case LineType.ADD_FEE:
      return 2;
    case LineType.DISCOUNT:
      return 3;
    case LineType.BASSEM_LABS_FEE:
      return 4;
    case LineType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum TuitionInvoiceStatus {
  NOT_GENERATED = "NOT_GENERATED",
  ON_TRACK = "ON_TRACK",
  OVERDUE = "OVERDUE",
  PAID = "PAID",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function tuitionInvoiceStatusFromJSON(object: any): TuitionInvoiceStatus {
  switch (object) {
    case 0:
    case "NOT_GENERATED":
      return TuitionInvoiceStatus.NOT_GENERATED;
    case 1:
    case "ON_TRACK":
      return TuitionInvoiceStatus.ON_TRACK;
    case 2:
    case "OVERDUE":
      return TuitionInvoiceStatus.OVERDUE;
    case 3:
    case "PAID":
      return TuitionInvoiceStatus.PAID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TuitionInvoiceStatus.UNRECOGNIZED;
  }
}

export function tuitionInvoiceStatusToJSON(object: TuitionInvoiceStatus): string {
  switch (object) {
    case TuitionInvoiceStatus.NOT_GENERATED:
      return "NOT_GENERATED";
    case TuitionInvoiceStatus.ON_TRACK:
      return "ON_TRACK";
    case TuitionInvoiceStatus.OVERDUE:
      return "OVERDUE";
    case TuitionInvoiceStatus.PAID:
      return "PAID";
    case TuitionInvoiceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function tuitionInvoiceStatusToNumber(object: TuitionInvoiceStatus): number {
  switch (object) {
    case TuitionInvoiceStatus.NOT_GENERATED:
      return 0;
    case TuitionInvoiceStatus.ON_TRACK:
      return 1;
    case TuitionInvoiceStatus.OVERDUE:
      return 2;
    case TuitionInvoiceStatus.PAID:
      return 3;
    case TuitionInvoiceStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface TuitionPlanSnapshot {
  name: string;
  schedule_type: PaymentScheduleType;
  day_of_month?: number | undefined;
  installments: PaymentInstallment[];
  start_date: Date | undefined;
  end_date: Date | undefined;
}

export interface TuitionInvoiceLineItem {
  line_type: LineType;
  scope: Scope;
  /** present when scope = STUDENT_SCOPE */
  student?: ObjectId | undefined;
  name: string;
  /** might be negative for discounts */
  amount: number;
  /** status at time of invoice creation */
  student_status?: StudentStatus | undefined;
}

export interface TuitionInvoice {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  school_year: ObjectId | undefined;
  family: ObjectId | undefined;
  tuition_plan: TuitionPlanSnapshot | undefined;
  line_items: TuitionInvoiceLineItem[];
  total_gross: number;
  total_discounts: number;
  total_net: number;
  /** Store the original plan ID for regeneration */
  tuition_plan_id:
    | ObjectId
    | undefined;
  /** Hypothetical totals if all admitted students were enrolled */
  total_net_if_all_enrolled?: number | undefined;
  total_gross_if_all_enrolled?: number | undefined;
  total_discounts_if_all_enrolled?: number | undefined;
}

function createBaseTuitionPlanSnapshot(): TuitionPlanSnapshot {
  return {
    name: "",
    schedule_type: PaymentScheduleType.ONE_TIME,
    day_of_month: 0,
    installments: [],
    start_date: undefined,
    end_date: undefined,
  };
}

export const TuitionPlanSnapshot: MessageFns<TuitionPlanSnapshot> = {
  encode(message: TuitionPlanSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schedule_type !== PaymentScheduleType.ONE_TIME) {
      writer.uint32(16).int32(paymentScheduleTypeToNumber(message.schedule_type));
    }
    if (message.day_of_month !== undefined && message.day_of_month !== 0) {
      writer.uint32(24).int32(message.day_of_month);
    }
    for (const v of message.installments) {
      PaymentInstallment.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.start_date !== undefined) {
      Timestamp.encode(toTimestamp(message.start_date), writer.uint32(42).fork()).join();
    }
    if (message.end_date !== undefined) {
      Timestamp.encode(toTimestamp(message.end_date), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionPlanSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionPlanSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.schedule_type = paymentScheduleTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.day_of_month = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.installments.push(PaymentInstallment.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.start_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.end_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionPlanSnapshot {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schedule_type: isSet(object.scheduleType)
        ? paymentScheduleTypeFromJSON(object.scheduleType)
        : PaymentScheduleType.ONE_TIME,
      day_of_month: isSet(object.dayOfMonth) ? globalThis.Number(object.dayOfMonth) : 0,
      installments: globalThis.Array.isArray(object?.installments)
        ? object.installments.map((e: any) => PaymentInstallment.fromJSON(e))
        : [],
      start_date: isSet(object.startDate) ? fromJsonTimestamp(object.startDate) : undefined,
      end_date: isSet(object.endDate) ? fromJsonTimestamp(object.endDate) : undefined,
    };
  },

  toJSON(message: TuitionPlanSnapshot): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schedule_type !== PaymentScheduleType.ONE_TIME) {
      obj.scheduleType = paymentScheduleTypeToJSON(message.schedule_type);
    }
    if (message.day_of_month !== undefined && message.day_of_month !== 0) {
      obj.dayOfMonth = Math.round(message.day_of_month);
    }
    if (message.installments?.length) {
      obj.installments = message.installments.map((e) => PaymentInstallment.toJSON(e));
    }
    if (message.start_date !== undefined) {
      obj.startDate = message.start_date.toISOString();
    }
    if (message.end_date !== undefined) {
      obj.endDate = message.end_date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionPlanSnapshot>, I>>(base?: I): TuitionPlanSnapshot {
    return TuitionPlanSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionPlanSnapshot>, I>>(object: I): TuitionPlanSnapshot {
    const message = createBaseTuitionPlanSnapshot();
    message.name = object.name ?? "";
    message.schedule_type = object.schedule_type ?? PaymentScheduleType.ONE_TIME;
    message.day_of_month = object.day_of_month ?? 0;
    message.installments = object.installments?.map((e) => PaymentInstallment.fromPartial(e)) || [];
    message.start_date = object.start_date ?? undefined;
    message.end_date = object.end_date ?? undefined;
    return message;
  },
};

function createBaseTuitionInvoiceLineItem(): TuitionInvoiceLineItem {
  return {
    line_type: LineType.BASE_RATE,
    scope: Scope.STUDENT_SCOPE,
    student: undefined,
    name: "",
    amount: 0,
    student_status: StudentStatus.WAITLIST,
  };
}

export const TuitionInvoiceLineItem: MessageFns<TuitionInvoiceLineItem> = {
  encode(message: TuitionInvoiceLineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line_type !== LineType.BASE_RATE) {
      writer.uint32(8).int32(lineTypeToNumber(message.line_type));
    }
    if (message.scope !== Scope.STUDENT_SCOPE) {
      writer.uint32(16).int32(scopeToNumber(message.scope));
    }
    if (message.student !== undefined) {
      ObjectId.encode(message.student, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.amount !== 0) {
      writer.uint32(41).double(message.amount);
    }
    if (message.student_status !== undefined && message.student_status !== StudentStatus.WAITLIST) {
      writer.uint32(48).int32(studentStatusToNumber(message.student_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionInvoiceLineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionInvoiceLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.line_type = lineTypeFromJSON(reader.int32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scope = scopeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.student = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.amount = reader.double();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.student_status = studentStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionInvoiceLineItem {
    return {
      line_type: isSet(object.lineType) ? lineTypeFromJSON(object.lineType) : LineType.BASE_RATE,
      scope: isSet(object.scope) ? scopeFromJSON(object.scope) : Scope.STUDENT_SCOPE,
      student: isSet(object.student) ? ObjectId.fromJSON(object.student) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      student_status: isSet(object.studentStatus)
        ? studentStatusFromJSON(object.studentStatus)
        : StudentStatus.WAITLIST,
    };
  },

  toJSON(message: TuitionInvoiceLineItem): unknown {
    const obj: any = {};
    if (message.line_type !== LineType.BASE_RATE) {
      obj.lineType = lineTypeToJSON(message.line_type);
    }
    if (message.scope !== Scope.STUDENT_SCOPE) {
      obj.scope = scopeToJSON(message.scope);
    }
    if (message.student !== undefined) {
      obj.student = ObjectId.toJSON(message.student);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.student_status !== undefined && message.student_status !== StudentStatus.WAITLIST) {
      obj.studentStatus = studentStatusToJSON(message.student_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionInvoiceLineItem>, I>>(base?: I): TuitionInvoiceLineItem {
    return TuitionInvoiceLineItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionInvoiceLineItem>, I>>(object: I): TuitionInvoiceLineItem {
    const message = createBaseTuitionInvoiceLineItem();
    message.line_type = object.line_type ?? LineType.BASE_RATE;
    message.scope = object.scope ?? Scope.STUDENT_SCOPE;
    message.student = (object.student !== undefined && object.student !== null)
      ? ObjectId.fromPartial(object.student)
      : undefined;
    message.name = object.name ?? "";
    message.amount = object.amount ?? 0;
    message.student_status = object.student_status ?? StudentStatus.WAITLIST;
    return message;
  },
};

function createBaseTuitionInvoice(): TuitionInvoice {
  return {
    id: undefined,
    organization: undefined,
    school_year: undefined,
    family: undefined,
    tuition_plan: undefined,
    line_items: [],
    total_gross: 0,
    total_discounts: 0,
    total_net: 0,
    tuition_plan_id: undefined,
    total_net_if_all_enrolled: 0,
    total_gross_if_all_enrolled: 0,
    total_discounts_if_all_enrolled: 0,
  };
}

export const TuitionInvoice: MessageFns<TuitionInvoice> = {
  encode(message: TuitionInvoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    if (message.family !== undefined) {
      ObjectId.encode(message.family, writer.uint32(34).fork()).join();
    }
    if (message.tuition_plan !== undefined) {
      TuitionPlanSnapshot.encode(message.tuition_plan, writer.uint32(42).fork()).join();
    }
    for (const v of message.line_items) {
      TuitionInvoiceLineItem.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.total_gross !== 0) {
      writer.uint32(57).double(message.total_gross);
    }
    if (message.total_discounts !== 0) {
      writer.uint32(65).double(message.total_discounts);
    }
    if (message.total_net !== 0) {
      writer.uint32(73).double(message.total_net);
    }
    if (message.tuition_plan_id !== undefined) {
      ObjectId.encode(message.tuition_plan_id, writer.uint32(82).fork()).join();
    }
    if (message.total_net_if_all_enrolled !== undefined && message.total_net_if_all_enrolled !== 0) {
      writer.uint32(89).double(message.total_net_if_all_enrolled);
    }
    if (message.total_gross_if_all_enrolled !== undefined && message.total_gross_if_all_enrolled !== 0) {
      writer.uint32(97).double(message.total_gross_if_all_enrolled);
    }
    if (message.total_discounts_if_all_enrolled !== undefined && message.total_discounts_if_all_enrolled !== 0) {
      writer.uint32(105).double(message.total_discounts_if_all_enrolled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuitionInvoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuitionInvoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.family = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tuition_plan = TuitionPlanSnapshot.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.line_items.push(TuitionInvoiceLineItem.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.total_gross = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.total_discounts = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.total_net = reader.double();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tuition_plan_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.total_net_if_all_enrolled = reader.double();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.total_gross_if_all_enrolled = reader.double();
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.total_discounts_if_all_enrolled = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuitionInvoice {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      school_year: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
      family: isSet(object.family) ? ObjectId.fromJSON(object.family) : undefined,
      tuition_plan: isSet(object.tuitionPlan) ? TuitionPlanSnapshot.fromJSON(object.tuitionPlan) : undefined,
      line_items: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => TuitionInvoiceLineItem.fromJSON(e))
        : [],
      total_gross: isSet(object.totalGross) ? globalThis.Number(object.totalGross) : 0,
      total_discounts: isSet(object.totalDiscounts) ? globalThis.Number(object.totalDiscounts) : 0,
      total_net: isSet(object.totalNet) ? globalThis.Number(object.totalNet) : 0,
      tuition_plan_id: isSet(object.tuitionPlanId) ? ObjectId.fromJSON(object.tuitionPlanId) : undefined,
      total_net_if_all_enrolled: isSet(object.totalNetIfAllEnrolled)
        ? globalThis.Number(object.totalNetIfAllEnrolled)
        : 0,
      total_gross_if_all_enrolled: isSet(object.totalGrossIfAllEnrolled)
        ? globalThis.Number(object.totalGrossIfAllEnrolled)
        : 0,
      total_discounts_if_all_enrolled: isSet(object.totalDiscountsIfAllEnrolled)
        ? globalThis.Number(object.totalDiscountsIfAllEnrolled)
        : 0,
    };
  },

  toJSON(message: TuitionInvoice): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.school_year !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.school_year);
    }
    if (message.family !== undefined) {
      obj.family = ObjectId.toJSON(message.family);
    }
    if (message.tuition_plan !== undefined) {
      obj.tuitionPlan = TuitionPlanSnapshot.toJSON(message.tuition_plan);
    }
    if (message.line_items?.length) {
      obj.lineItems = message.line_items.map((e) => TuitionInvoiceLineItem.toJSON(e));
    }
    if (message.total_gross !== 0) {
      obj.totalGross = message.total_gross;
    }
    if (message.total_discounts !== 0) {
      obj.totalDiscounts = message.total_discounts;
    }
    if (message.total_net !== 0) {
      obj.totalNet = message.total_net;
    }
    if (message.tuition_plan_id !== undefined) {
      obj.tuitionPlanId = ObjectId.toJSON(message.tuition_plan_id);
    }
    if (message.total_net_if_all_enrolled !== undefined && message.total_net_if_all_enrolled !== 0) {
      obj.totalNetIfAllEnrolled = message.total_net_if_all_enrolled;
    }
    if (message.total_gross_if_all_enrolled !== undefined && message.total_gross_if_all_enrolled !== 0) {
      obj.totalGrossIfAllEnrolled = message.total_gross_if_all_enrolled;
    }
    if (message.total_discounts_if_all_enrolled !== undefined && message.total_discounts_if_all_enrolled !== 0) {
      obj.totalDiscountsIfAllEnrolled = message.total_discounts_if_all_enrolled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TuitionInvoice>, I>>(base?: I): TuitionInvoice {
    return TuitionInvoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TuitionInvoice>, I>>(object: I): TuitionInvoice {
    const message = createBaseTuitionInvoice();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? ObjectId.fromPartial(object.family)
      : undefined;
    message.tuition_plan = (object.tuition_plan !== undefined && object.tuition_plan !== null)
      ? TuitionPlanSnapshot.fromPartial(object.tuition_plan)
      : undefined;
    message.line_items = object.line_items?.map((e) => TuitionInvoiceLineItem.fromPartial(e)) || [];
    message.total_gross = object.total_gross ?? 0;
    message.total_discounts = object.total_discounts ?? 0;
    message.total_net = object.total_net ?? 0;
    message.tuition_plan_id = (object.tuition_plan_id !== undefined && object.tuition_plan_id !== null)
      ? ObjectId.fromPartial(object.tuition_plan_id)
      : undefined;
    message.total_net_if_all_enrolled = object.total_net_if_all_enrolled ?? 0;
    message.total_gross_if_all_enrolled = object.total_gross_if_all_enrolled ?? 0;
    message.total_discounts_if_all_enrolled = object.total_discounts_if_all_enrolled ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

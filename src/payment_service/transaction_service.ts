// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/transaction_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Currency, currencyFromJSON, currencyToJSON, currencyToNumber } from "../organization_service/organization";
import { ObjectId } from "../utils/object_id";
import { RequestContext } from "../utils/request_context";
import { PaymentType, paymentTypeFromJSON, paymentTypeToJSON, paymentTypeToNumber, Transaction } from "./transaction";

export const protobufPackage = "payment_service_transaction";

export interface NewModelRequest {
  context: RequestContext | undefined;
  currency: Currency;
  paymentType: PaymentType;
  invoiceId: ObjectId | undefined;
  amount: number;
}

export interface HandlePaymentProcessingRequest {
  context: RequestContext | undefined;
  stripePaymentIntentId: string;
}

export interface HandlePaymentSuccessRequest {
  context: RequestContext | undefined;
  stripePaymentIntentId: string;
  amountReceived: number;
}

export interface HandlePaymentFailedRequest {
  context: RequestContext | undefined;
  stripePaymentIntentId: string;
}

export interface GetPaidTransactionRequest {
  context: RequestContext | undefined;
  user: ObjectId | undefined;
  description: string;
}

export interface GetTransactionsRequest {
  context: RequestContext | undefined;
  user: ObjectId | undefined;
}

export interface GetTransactionsResponse {
  transactions: Transaction[];
}

export interface CreateStripeTransactionRequest {
  context: RequestContext | undefined;
  paymentType: PaymentType;
  currency: Currency;
  invoiceId: ObjectId | undefined;
  amount: number;
  stripePaymentIntentId: string;
}

export interface CreateManualTransactionRequest {
  context: RequestContext | undefined;
  paymentType: PaymentType;
  invoiceId: ObjectId | undefined;
  amount: number;
}

export interface NewPaymentRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
  paymentType: PaymentType;
  amount: number;
}

export interface NewPaymentResponse {
  clientSecret: string;
}

export interface OnboardOrganizationStripeAccountRequest {
  context: RequestContext | undefined;
}

export interface OnboardOrganizationStripeAccountResponse {
  accountLink: string;
}

function createBaseNewModelRequest(): NewModelRequest {
  return {
    context: undefined,
    currency: Currency.USD,
    paymentType: PaymentType.Stripe,
    invoiceId: undefined,
    amount: 0,
  };
}

export const NewModelRequest: MessageFns<NewModelRequest> = {
  encode(message: NewModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.currency !== Currency.USD) {
      writer.uint32(16).int32(currencyToNumber(message.currency));
    }
    if (message.paymentType !== PaymentType.Stripe) {
      writer.uint32(24).int32(paymentTypeToNumber(message.paymentType));
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(34).fork()).join();
    }
    if (message.amount !== 0) {
      writer.uint32(41).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.currency = currencyFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.paymentType = paymentTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewModelRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : Currency.USD,
      paymentType: isSet(object.paymentType) ? paymentTypeFromJSON(object.paymentType) : PaymentType.Stripe,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: NewModelRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.currency !== Currency.USD) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.paymentType !== PaymentType.Stripe) {
      obj.paymentType = paymentTypeToJSON(message.paymentType);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewModelRequest>, I>>(base?: I): NewModelRequest {
    return NewModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewModelRequest>, I>>(object: I): NewModelRequest {
    const message = createBaseNewModelRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.currency = object.currency ?? Currency.USD;
    message.paymentType = object.paymentType ?? PaymentType.Stripe;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseHandlePaymentProcessingRequest(): HandlePaymentProcessingRequest {
  return { context: undefined, stripePaymentIntentId: "" };
}

export const HandlePaymentProcessingRequest: MessageFns<HandlePaymentProcessingRequest> = {
  encode(message: HandlePaymentProcessingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.stripePaymentIntentId !== "") {
      writer.uint32(18).string(message.stripePaymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandlePaymentProcessingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandlePaymentProcessingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stripePaymentIntentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandlePaymentProcessingRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      stripePaymentIntentId: isSet(object.stripePaymentIntentId) ? globalThis.String(object.stripePaymentIntentId) : "",
    };
  },

  toJSON(message: HandlePaymentProcessingRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.stripePaymentIntentId !== "") {
      obj.stripePaymentIntentId = message.stripePaymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandlePaymentProcessingRequest>, I>>(base?: I): HandlePaymentProcessingRequest {
    return HandlePaymentProcessingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandlePaymentProcessingRequest>, I>>(
    object: I,
  ): HandlePaymentProcessingRequest {
    const message = createBaseHandlePaymentProcessingRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.stripePaymentIntentId = object.stripePaymentIntentId ?? "";
    return message;
  },
};

function createBaseHandlePaymentSuccessRequest(): HandlePaymentSuccessRequest {
  return { context: undefined, stripePaymentIntentId: "", amountReceived: 0 };
}

export const HandlePaymentSuccessRequest: MessageFns<HandlePaymentSuccessRequest> = {
  encode(message: HandlePaymentSuccessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.stripePaymentIntentId !== "") {
      writer.uint32(18).string(message.stripePaymentIntentId);
    }
    if (message.amountReceived !== 0) {
      writer.uint32(25).double(message.amountReceived);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandlePaymentSuccessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandlePaymentSuccessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stripePaymentIntentId = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.amountReceived = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandlePaymentSuccessRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      stripePaymentIntentId: isSet(object.stripePaymentIntentId) ? globalThis.String(object.stripePaymentIntentId) : "",
      amountReceived: isSet(object.amountReceived) ? globalThis.Number(object.amountReceived) : 0,
    };
  },

  toJSON(message: HandlePaymentSuccessRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.stripePaymentIntentId !== "") {
      obj.stripePaymentIntentId = message.stripePaymentIntentId;
    }
    if (message.amountReceived !== 0) {
      obj.amountReceived = message.amountReceived;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandlePaymentSuccessRequest>, I>>(base?: I): HandlePaymentSuccessRequest {
    return HandlePaymentSuccessRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandlePaymentSuccessRequest>, I>>(object: I): HandlePaymentSuccessRequest {
    const message = createBaseHandlePaymentSuccessRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.stripePaymentIntentId = object.stripePaymentIntentId ?? "";
    message.amountReceived = object.amountReceived ?? 0;
    return message;
  },
};

function createBaseHandlePaymentFailedRequest(): HandlePaymentFailedRequest {
  return { context: undefined, stripePaymentIntentId: "" };
}

export const HandlePaymentFailedRequest: MessageFns<HandlePaymentFailedRequest> = {
  encode(message: HandlePaymentFailedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.stripePaymentIntentId !== "") {
      writer.uint32(18).string(message.stripePaymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandlePaymentFailedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandlePaymentFailedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stripePaymentIntentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandlePaymentFailedRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      stripePaymentIntentId: isSet(object.stripePaymentIntentId) ? globalThis.String(object.stripePaymentIntentId) : "",
    };
  },

  toJSON(message: HandlePaymentFailedRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.stripePaymentIntentId !== "") {
      obj.stripePaymentIntentId = message.stripePaymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandlePaymentFailedRequest>, I>>(base?: I): HandlePaymentFailedRequest {
    return HandlePaymentFailedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandlePaymentFailedRequest>, I>>(object: I): HandlePaymentFailedRequest {
    const message = createBaseHandlePaymentFailedRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.stripePaymentIntentId = object.stripePaymentIntentId ?? "";
    return message;
  },
};

function createBaseGetPaidTransactionRequest(): GetPaidTransactionRequest {
  return { context: undefined, user: undefined, description: "" };
}

export const GetPaidTransactionRequest: MessageFns<GetPaidTransactionRequest> = {
  encode(message: GetPaidTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      ObjectId.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPaidTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaidTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPaidTransactionRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      user: isSet(object.user) ? ObjectId.fromJSON(object.user) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: GetPaidTransactionRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.user !== undefined) {
      obj.user = ObjectId.toJSON(message.user);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPaidTransactionRequest>, I>>(base?: I): GetPaidTransactionRequest {
    return GetPaidTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPaidTransactionRequest>, I>>(object: I): GetPaidTransactionRequest {
    const message = createBaseGetPaidTransactionRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? ObjectId.fromPartial(object.user) : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGetTransactionsRequest(): GetTransactionsRequest {
  return { context: undefined, user: undefined };
}

export const GetTransactionsRequest: MessageFns<GetTransactionsRequest> = {
  encode(message: GetTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      ObjectId.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      user: isSet(object.user) ? ObjectId.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: GetTransactionsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.user !== undefined) {
      obj.user = ObjectId.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionsRequest>, I>>(base?: I): GetTransactionsRequest {
    return GetTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionsRequest>, I>>(object: I): GetTransactionsRequest {
    const message = createBaseGetTransactionsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? ObjectId.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetTransactionsResponse(): GetTransactionsResponse {
  return { transactions: [] };
}

export const GetTransactionsResponse: MessageFns<GetTransactionsResponse> = {
  encode(message: GetTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionsResponse>, I>>(base?: I): GetTransactionsResponse {
    return GetTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionsResponse>, I>>(object: I): GetTransactionsResponse {
    const message = createBaseGetTransactionsResponse();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateStripeTransactionRequest(): CreateStripeTransactionRequest {
  return {
    context: undefined,
    paymentType: PaymentType.Stripe,
    currency: Currency.USD,
    invoiceId: undefined,
    amount: 0,
    stripePaymentIntentId: "",
  };
}

export const CreateStripeTransactionRequest: MessageFns<CreateStripeTransactionRequest> = {
  encode(message: CreateStripeTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.paymentType !== PaymentType.Stripe) {
      writer.uint32(16).int32(paymentTypeToNumber(message.paymentType));
    }
    if (message.currency !== Currency.USD) {
      writer.uint32(24).int32(currencyToNumber(message.currency));
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(34).fork()).join();
    }
    if (message.amount !== 0) {
      writer.uint32(41).double(message.amount);
    }
    if (message.stripePaymentIntentId !== "") {
      writer.uint32(50).string(message.stripePaymentIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStripeTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStripeTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paymentType = paymentTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.currency = currencyFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.amount = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stripePaymentIntentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStripeTransactionRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      paymentType: isSet(object.paymentType) ? paymentTypeFromJSON(object.paymentType) : PaymentType.Stripe,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : Currency.USD,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      stripePaymentIntentId: isSet(object.stripePaymentIntentId) ? globalThis.String(object.stripePaymentIntentId) : "",
    };
  },

  toJSON(message: CreateStripeTransactionRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.paymentType !== PaymentType.Stripe) {
      obj.paymentType = paymentTypeToJSON(message.paymentType);
    }
    if (message.currency !== Currency.USD) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.stripePaymentIntentId !== "") {
      obj.stripePaymentIntentId = message.stripePaymentIntentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStripeTransactionRequest>, I>>(base?: I): CreateStripeTransactionRequest {
    return CreateStripeTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStripeTransactionRequest>, I>>(
    object: I,
  ): CreateStripeTransactionRequest {
    const message = createBaseCreateStripeTransactionRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.paymentType = object.paymentType ?? PaymentType.Stripe;
    message.currency = object.currency ?? Currency.USD;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    message.amount = object.amount ?? 0;
    message.stripePaymentIntentId = object.stripePaymentIntentId ?? "";
    return message;
  },
};

function createBaseCreateManualTransactionRequest(): CreateManualTransactionRequest {
  return { context: undefined, paymentType: PaymentType.Stripe, invoiceId: undefined, amount: 0 };
}

export const CreateManualTransactionRequest: MessageFns<CreateManualTransactionRequest> = {
  encode(message: CreateManualTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.paymentType !== PaymentType.Stripe) {
      writer.uint32(16).int32(paymentTypeToNumber(message.paymentType));
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(26).fork()).join();
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateManualTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateManualTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paymentType = paymentTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateManualTransactionRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      paymentType: isSet(object.paymentType) ? paymentTypeFromJSON(object.paymentType) : PaymentType.Stripe,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: CreateManualTransactionRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.paymentType !== PaymentType.Stripe) {
      obj.paymentType = paymentTypeToJSON(message.paymentType);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateManualTransactionRequest>, I>>(base?: I): CreateManualTransactionRequest {
    return CreateManualTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateManualTransactionRequest>, I>>(
    object: I,
  ): CreateManualTransactionRequest {
    const message = createBaseCreateManualTransactionRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.paymentType = object.paymentType ?? PaymentType.Stripe;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseNewPaymentRequest(): NewPaymentRequest {
  return { context: undefined, invoiceId: undefined, paymentType: PaymentType.Stripe, amount: 0 };
}

export const NewPaymentRequest: MessageFns<NewPaymentRequest> = {
  encode(message: NewPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    if (message.paymentType !== PaymentType.Stripe) {
      writer.uint32(24).int32(paymentTypeToNumber(message.paymentType));
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.paymentType = paymentTypeFromJSON(reader.int32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewPaymentRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      paymentType: isSet(object.paymentType) ? paymentTypeFromJSON(object.paymentType) : PaymentType.Stripe,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: NewPaymentRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    if (message.paymentType !== PaymentType.Stripe) {
      obj.paymentType = paymentTypeToJSON(message.paymentType);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewPaymentRequest>, I>>(base?: I): NewPaymentRequest {
    return NewPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewPaymentRequest>, I>>(object: I): NewPaymentRequest {
    const message = createBaseNewPaymentRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    message.paymentType = object.paymentType ?? PaymentType.Stripe;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseNewPaymentResponse(): NewPaymentResponse {
  return { clientSecret: "" };
}

export const NewPaymentResponse: MessageFns<NewPaymentResponse> = {
  encode(message: NewPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientSecret !== "") {
      writer.uint32(10).string(message.clientSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NewPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NewPaymentResponse {
    return { clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "" };
  },

  toJSON(message: NewPaymentResponse): unknown {
    const obj: any = {};
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NewPaymentResponse>, I>>(base?: I): NewPaymentResponse {
    return NewPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NewPaymentResponse>, I>>(object: I): NewPaymentResponse {
    const message = createBaseNewPaymentResponse();
    message.clientSecret = object.clientSecret ?? "";
    return message;
  },
};

function createBaseOnboardOrganizationStripeAccountRequest(): OnboardOrganizationStripeAccountRequest {
  return { context: undefined };
}

export const OnboardOrganizationStripeAccountRequest: MessageFns<OnboardOrganizationStripeAccountRequest> = {
  encode(message: OnboardOrganizationStripeAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnboardOrganizationStripeAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardOrganizationStripeAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardOrganizationStripeAccountRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: OnboardOrganizationStripeAccountRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardOrganizationStripeAccountRequest>, I>>(
    base?: I,
  ): OnboardOrganizationStripeAccountRequest {
    return OnboardOrganizationStripeAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardOrganizationStripeAccountRequest>, I>>(
    object: I,
  ): OnboardOrganizationStripeAccountRequest {
    const message = createBaseOnboardOrganizationStripeAccountRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseOnboardOrganizationStripeAccountResponse(): OnboardOrganizationStripeAccountResponse {
  return { accountLink: "" };
}

export const OnboardOrganizationStripeAccountResponse: MessageFns<OnboardOrganizationStripeAccountResponse> = {
  encode(message: OnboardOrganizationStripeAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountLink !== "") {
      writer.uint32(10).string(message.accountLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnboardOrganizationStripeAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnboardOrganizationStripeAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnboardOrganizationStripeAccountResponse {
    return { accountLink: isSet(object.accountLink) ? globalThis.String(object.accountLink) : "" };
  },

  toJSON(message: OnboardOrganizationStripeAccountResponse): unknown {
    const obj: any = {};
    if (message.accountLink !== "") {
      obj.accountLink = message.accountLink;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnboardOrganizationStripeAccountResponse>, I>>(
    base?: I,
  ): OnboardOrganizationStripeAccountResponse {
    return OnboardOrganizationStripeAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnboardOrganizationStripeAccountResponse>, I>>(
    object: I,
  ): OnboardOrganizationStripeAccountResponse {
    const message = createBaseOnboardOrganizationStripeAccountResponse();
    message.accountLink = object.accountLink ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/invoice_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";
import { ActionRequiredByParents } from "../user_service/action_required_by_parents";
import {
  StudentStatus,
  studentStatusFromJSON,
  studentStatusToJSON,
  studentStatusToNumber,
} from "../user_service/student";
import { ObjectId } from "../utils/object_id";
import { RequestContext } from "../utils/request_context";
import {
  AutoPaymentAttempt,
  AutoPaymentStatus,
  autoPaymentStatusFromJSON,
  autoPaymentStatusToJSON,
  autoPaymentStatusToNumber,
  Coupon,
  Invoice,
  InvoiceFilter,
  InvoiceItem,
  InvoiceResponse,
} from "./invoice";

export const protobufPackage = "payment_service";

/** Invoice messages */
export interface Invoices {
  invoices: Invoice[];
}

export interface GetInvoiceRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

export interface GetInvoiceByNumberRequest {
  context: RequestContext | undefined;
  invoice_number: number;
}

export interface GetUserInvoicesRequest {
  context: RequestContext | undefined;
  user_id: ObjectId | undefined;
}

export interface GetUserInvoicesResponse {
  invoices: InvoiceResponse[];
}

export interface GetFamilyInvoicesRequest {
  context: RequestContext | undefined;
  family_id: ObjectId | undefined;
}

export interface GetParentInvoicesRequest {
  context: RequestContext | undefined;
  parent_id: ObjectId | undefined;
  school_year?: ObjectId | undefined;
  title?: string | undefined;
}

export interface GetActionsRequiredByParentsRequest {
  context: RequestContext | undefined;
  student_id: ObjectId | undefined;
}

export interface GetActionsRequiredByParentsResponse {
  actions: ActionRequiredByParents[];
}

export interface StudentHasNoUnpaidInvoicesRequest {
  context: RequestContext | undefined;
  student_id: ObjectId | undefined;
}

export interface StudentHasNoUnpaidInvoicesResponse {
  has_no_unpaid_invoices: boolean;
}

export interface ListInvoicesRequest {
  context: RequestContext | undefined;
  filter: InvoiceFilter | undefined;
}

export interface AggregationResponse {
  invoices: Invoice[];
  invoices_count: number;
}

export interface PaginatedListInvoicesResponse {
  invoices: InvoiceResponse[];
  invoices_count: number;
}

export interface ListInvoicesResponse {
  invoices: InvoiceResponse[];
}

export interface IsInvoicePaidRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

export interface IsInvoicePaidResponse {
  is_paid: boolean;
}

export interface CreateInvoiceRequest {
  context: RequestContext | undefined;
  title: string;
  description: string;
  show_hst: boolean;
  disable_tax: boolean;
  users: ObjectId[];
  families: ObjectId[];
  items: InvoiceItem[];
  coupons: Coupon[];
  due_date?: Date | undefined;
  school_year: ObjectId | undefined;
  auto_pay_enabled?: boolean | undefined;
  charge_on_date?: Date | undefined;
  auto_payment_status?: AutoPaymentStatus | undefined;
  is_tuition?: boolean | undefined;
}

export interface CreateInvoicesResponse {
  invoices: InvoiceResponse[];
}

export interface CreateInvoiceForClassRequest {
  context: RequestContext | undefined;
  title: string;
  description: string;
  show_hst: boolean;
  disable_tax: boolean;
  homerooms: ObjectId[];
  courses: ObjectId[];
  items: InvoiceItem[];
  coupons: Coupon[];
  due_date?: Date | undefined;
  school_year: ObjectId | undefined;
  auto_pay_enabled?: boolean | undefined;
  charge_on_date?: Date | undefined;
  auto_payment_status?: AutoPaymentStatus | undefined;
}

export interface GenerateInterviewFeeInvoiceRequest {
  context: RequestContext | undefined;
  student_id: ObjectId | undefined;
  school_year: ObjectId | undefined;
}

export interface GenerateWaitlistFeeInvoiceRequest {
  context: RequestContext | undefined;
  student_id: ObjectId | undefined;
  school_year: ObjectId | undefined;
}

export interface GenerateRegistrationFeesInvoiceRequest {
  context: RequestContext | undefined;
  student_id: ObjectId | undefined;
  school_year: ObjectId | undefined;
}

export interface CreateInvoiceForClassResponse {
  invoices: InvoiceResponse[];
}

export interface UpdateInvoiceRequest {
  context: RequestContext | undefined;
  id: ObjectId | undefined;
  title: string;
  description: string;
  show_hst: boolean;
  disable_tax: boolean;
  items: InvoiceItem[];
  coupons: Coupon[];
  due_date?: Date | undefined;
}

export interface UpdateInvoiceAutoPaymentRequest {
  context: RequestContext | undefined;
  id: ObjectId | undefined;
  auto_pay_enabled: boolean;
  charge_on_date: Date | undefined;
}

export interface ArchiveInvoiceRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

export interface UnarchiveInvoiceRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

export interface GetAutoPayInvoicesReadyToChargeRequest {
  context: RequestContext | undefined;
}

export interface SetAutoPayInvoiceStatusRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
  auto_payment_status: AutoPaymentStatus;
}

export interface GetFamilyTuitionInvoicesRequest {
  context: RequestContext | undefined;
  family_id: ObjectId | undefined;
  school_year: ObjectId | undefined;
  start_date?: Date | undefined;
  end_date?: Date | undefined;
}

export interface GetStudentsWithUnpaidInvoicesRequest {
  context: RequestContext | undefined;
  student_statuses: StudentStatus[];
  school_year: ObjectId | undefined;
}

export interface GetStudentsWithUnpaidInvoicesResponse {
  student_ids: ObjectId[];
}

export interface GetStudentsWithReregistrationInvoicesRequest {
  context: RequestContext | undefined;
  school_year: ObjectId | undefined;
}

export interface GetStudentsWithReregistrationInvoicesResponse {
  student_ids: ObjectId[];
}

export interface GetOrgPaidBassemLabsFeesInPeriodRequest {
  context: RequestContext | undefined;
  organization_id: ObjectId | undefined;
  start_date: Date | undefined;
  end_date: Date | undefined;
}

export interface GetOrgPaidBassemLabsFeesInPeriodResponse {
  total_amount: number;
}

export interface UpsertOrganizationInvoiceRequest {
  context: RequestContext | undefined;
  organization_id: ObjectId | undefined;
  invoice_start_date: Date | undefined;
  invoice_end_date: Date | undefined;
  current_enrolled_students_count: number;
  is_in_trial_period: boolean;
}

export interface GetOrganizationInvoicesRequest {
  context: RequestContext | undefined;
}

export interface GetAllOrganizationInvoicesRequest {
  context: RequestContext | undefined;
}

/** Auto payment retry messages */
export interface GetFailedAutoPayInvoicesRequest {
  context: RequestContext | undefined;
}

export interface GetAutoPaymentAttemptsRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

export interface GetAutoPaymentAttemptsResponse {
  attempts: AutoPaymentAttempt[];
}

export interface ResetAutoPaymentForRetryRequest {
  context: RequestContext | undefined;
  invoice_id: ObjectId | undefined;
}

function createBaseInvoices(): Invoices {
  return { invoices: [] };
}

export const Invoices: MessageFns<Invoices> = {
  encode(message: Invoices, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      Invoice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invoices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(Invoice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invoices {
    return {
      invoices: globalThis.Array.isArray(object?.invoices) ? object.invoices.map((e: any) => Invoice.fromJSON(e)) : [],
    };
  },

  toJSON(message: Invoices): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => Invoice.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Invoices>, I>>(base?: I): Invoices {
    return Invoices.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Invoices>, I>>(object: I): Invoices {
    const message = createBaseInvoices();
    message.invoices = object.invoices?.map((e) => Invoice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInvoiceRequest(): GetInvoiceRequest {
  return { context: undefined, invoice_id: undefined };
}

export const GetInvoiceRequest: MessageFns<GetInvoiceRequest> = {
  encode(message: GetInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: GetInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvoiceRequest>, I>>(base?: I): GetInvoiceRequest {
    return GetInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvoiceRequest>, I>>(object: I): GetInvoiceRequest {
    const message = createBaseGetInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

function createBaseGetInvoiceByNumberRequest(): GetInvoiceByNumberRequest {
  return { context: undefined, invoice_number: 0 };
}

export const GetInvoiceByNumberRequest: MessageFns<GetInvoiceByNumberRequest> = {
  encode(message: GetInvoiceByNumberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_number !== 0) {
      writer.uint32(16).int32(message.invoice_number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvoiceByNumberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvoiceByNumberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoice_number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvoiceByNumberRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_number: isSet(object.invoice_number) ? globalThis.Number(object.invoice_number) : 0,
    };
  },

  toJSON(message: GetInvoiceByNumberRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_number !== 0) {
      obj.invoice_number = Math.round(message.invoice_number);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvoiceByNumberRequest>, I>>(base?: I): GetInvoiceByNumberRequest {
    return GetInvoiceByNumberRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvoiceByNumberRequest>, I>>(object: I): GetInvoiceByNumberRequest {
    const message = createBaseGetInvoiceByNumberRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_number = object.invoice_number ?? 0;
    return message;
  },
};

function createBaseGetUserInvoicesRequest(): GetUserInvoicesRequest {
  return { context: undefined, user_id: undefined };
}

export const GetUserInvoicesRequest: MessageFns<GetUserInvoicesRequest> = {
  encode(message: GetUserInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.user_id !== undefined) {
      ObjectId.encode(message.user_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      user_id: isSet(object.user_id) ? ObjectId.fromJSON(object.user_id) : undefined,
    };
  },

  toJSON(message: GetUserInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.user_id !== undefined) {
      obj.user_id = ObjectId.toJSON(message.user_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInvoicesRequest>, I>>(base?: I): GetUserInvoicesRequest {
    return GetUserInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInvoicesRequest>, I>>(object: I): GetUserInvoicesRequest {
    const message = createBaseGetUserInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.user_id = (object.user_id !== undefined && object.user_id !== null)
      ? ObjectId.fromPartial(object.user_id)
      : undefined;
    return message;
  },
};

function createBaseGetUserInvoicesResponse(): GetUserInvoicesResponse {
  return { invoices: [] };
}

export const GetUserInvoicesResponse: MessageFns<GetUserInvoicesResponse> = {
  encode(message: GetUserInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInvoicesResponse>, I>>(base?: I): GetUserInvoicesResponse {
    return GetUserInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInvoicesResponse>, I>>(object: I): GetUserInvoicesResponse {
    const message = createBaseGetUserInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetFamilyInvoicesRequest(): GetFamilyInvoicesRequest {
  return { context: undefined, family_id: undefined };
}

export const GetFamilyInvoicesRequest: MessageFns<GetFamilyInvoicesRequest> = {
  encode(message: GetFamilyInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.family_id !== undefined) {
      ObjectId.encode(message.family_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFamilyInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFamilyInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.family_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFamilyInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      family_id: isSet(object.family_id) ? ObjectId.fromJSON(object.family_id) : undefined,
    };
  },

  toJSON(message: GetFamilyInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.family_id !== undefined) {
      obj.family_id = ObjectId.toJSON(message.family_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFamilyInvoicesRequest>, I>>(base?: I): GetFamilyInvoicesRequest {
    return GetFamilyInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFamilyInvoicesRequest>, I>>(object: I): GetFamilyInvoicesRequest {
    const message = createBaseGetFamilyInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.family_id = (object.family_id !== undefined && object.family_id !== null)
      ? ObjectId.fromPartial(object.family_id)
      : undefined;
    return message;
  },
};

function createBaseGetParentInvoicesRequest(): GetParentInvoicesRequest {
  return { context: undefined, parent_id: undefined, school_year: undefined, title: "" };
}

export const GetParentInvoicesRequest: MessageFns<GetParentInvoicesRequest> = {
  encode(message: GetParentInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.parent_id !== undefined) {
      ObjectId.encode(message.parent_id, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    if (message.title !== undefined && message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParentInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      parent_id: isSet(object.parent_id) ? ObjectId.fromJSON(object.parent_id) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: GetParentInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.parent_id !== undefined) {
      obj.parent_id = ObjectId.toJSON(message.parent_id);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    if (message.title !== undefined && message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentInvoicesRequest>, I>>(base?: I): GetParentInvoicesRequest {
    return GetParentInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentInvoicesRequest>, I>>(object: I): GetParentInvoicesRequest {
    const message = createBaseGetParentInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.parent_id = (object.parent_id !== undefined && object.parent_id !== null)
      ? ObjectId.fromPartial(object.parent_id)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.title = object.title ?? "";
    return message;
  },
};

function createBaseGetActionsRequiredByParentsRequest(): GetActionsRequiredByParentsRequest {
  return { context: undefined, student_id: undefined };
}

export const GetActionsRequiredByParentsRequest: MessageFns<GetActionsRequiredByParentsRequest> = {
  encode(message: GetActionsRequiredByParentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.student_id !== undefined) {
      ObjectId.encode(message.student_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActionsRequiredByParentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequiredByParentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.student_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActionsRequiredByParentsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_id: isSet(object.student_id) ? ObjectId.fromJSON(object.student_id) : undefined,
    };
  },

  toJSON(message: GetActionsRequiredByParentsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_id !== undefined) {
      obj.student_id = ObjectId.toJSON(message.student_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActionsRequiredByParentsRequest>, I>>(
    base?: I,
  ): GetActionsRequiredByParentsRequest {
    return GetActionsRequiredByParentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActionsRequiredByParentsRequest>, I>>(
    object: I,
  ): GetActionsRequiredByParentsRequest {
    const message = createBaseGetActionsRequiredByParentsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_id = (object.student_id !== undefined && object.student_id !== null)
      ? ObjectId.fromPartial(object.student_id)
      : undefined;
    return message;
  },
};

function createBaseGetActionsRequiredByParentsResponse(): GetActionsRequiredByParentsResponse {
  return { actions: [] };
}

export const GetActionsRequiredByParentsResponse: MessageFns<GetActionsRequiredByParentsResponse> = {
  encode(message: GetActionsRequiredByParentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      ActionRequiredByParents.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActionsRequiredByParentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequiredByParentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(ActionRequiredByParents.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActionsRequiredByParentsResponse {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => ActionRequiredByParents.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetActionsRequiredByParentsResponse): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => ActionRequiredByParents.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActionsRequiredByParentsResponse>, I>>(
    base?: I,
  ): GetActionsRequiredByParentsResponse {
    return GetActionsRequiredByParentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActionsRequiredByParentsResponse>, I>>(
    object: I,
  ): GetActionsRequiredByParentsResponse {
    const message = createBaseGetActionsRequiredByParentsResponse();
    message.actions = object.actions?.map((e) => ActionRequiredByParents.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStudentHasNoUnpaidInvoicesRequest(): StudentHasNoUnpaidInvoicesRequest {
  return { context: undefined, student_id: undefined };
}

export const StudentHasNoUnpaidInvoicesRequest: MessageFns<StudentHasNoUnpaidInvoicesRequest> = {
  encode(message: StudentHasNoUnpaidInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.student_id !== undefined) {
      ObjectId.encode(message.student_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentHasNoUnpaidInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentHasNoUnpaidInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.student_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentHasNoUnpaidInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_id: isSet(object.student_id) ? ObjectId.fromJSON(object.student_id) : undefined,
    };
  },

  toJSON(message: StudentHasNoUnpaidInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_id !== undefined) {
      obj.student_id = ObjectId.toJSON(message.student_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesRequest>, I>>(
    base?: I,
  ): StudentHasNoUnpaidInvoicesRequest {
    return StudentHasNoUnpaidInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesRequest>, I>>(
    object: I,
  ): StudentHasNoUnpaidInvoicesRequest {
    const message = createBaseStudentHasNoUnpaidInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_id = (object.student_id !== undefined && object.student_id !== null)
      ? ObjectId.fromPartial(object.student_id)
      : undefined;
    return message;
  },
};

function createBaseStudentHasNoUnpaidInvoicesResponse(): StudentHasNoUnpaidInvoicesResponse {
  return { has_no_unpaid_invoices: false };
}

export const StudentHasNoUnpaidInvoicesResponse: MessageFns<StudentHasNoUnpaidInvoicesResponse> = {
  encode(message: StudentHasNoUnpaidInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.has_no_unpaid_invoices !== false) {
      writer.uint32(8).bool(message.has_no_unpaid_invoices);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentHasNoUnpaidInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentHasNoUnpaidInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.has_no_unpaid_invoices = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentHasNoUnpaidInvoicesResponse {
    return {
      has_no_unpaid_invoices: isSet(object.has_no_unpaid_invoices)
        ? globalThis.Boolean(object.has_no_unpaid_invoices)
        : false,
    };
  },

  toJSON(message: StudentHasNoUnpaidInvoicesResponse): unknown {
    const obj: any = {};
    if (message.has_no_unpaid_invoices !== false) {
      obj.has_no_unpaid_invoices = message.has_no_unpaid_invoices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesResponse>, I>>(
    base?: I,
  ): StudentHasNoUnpaidInvoicesResponse {
    return StudentHasNoUnpaidInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesResponse>, I>>(
    object: I,
  ): StudentHasNoUnpaidInvoicesResponse {
    const message = createBaseStudentHasNoUnpaidInvoicesResponse();
    message.has_no_unpaid_invoices = object.has_no_unpaid_invoices ?? false;
    return message;
  },
};

function createBaseListInvoicesRequest(): ListInvoicesRequest {
  return { context: undefined, filter: undefined };
}

export const ListInvoicesRequest: MessageFns<ListInvoicesRequest> = {
  encode(message: ListInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.filter !== undefined) {
      InvoiceFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = InvoiceFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      filter: isSet(object.filter) ? InvoiceFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: ListInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.filter !== undefined) {
      obj.filter = InvoiceFilter.toJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInvoicesRequest>, I>>(base?: I): ListInvoicesRequest {
    return ListInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInvoicesRequest>, I>>(object: I): ListInvoicesRequest {
    const message = createBaseListInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? InvoiceFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseAggregationResponse(): AggregationResponse {
  return { invoices: [], invoices_count: 0 };
}

export const AggregationResponse: MessageFns<AggregationResponse> = {
  encode(message: AggregationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      Invoice.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.invoices_count !== 0) {
      writer.uint32(16).int32(message.invoices_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(Invoice.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoices_count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices) ? object.invoices.map((e: any) => Invoice.fromJSON(e)) : [],
      invoices_count: isSet(object.invoices_count) ? globalThis.Number(object.invoices_count) : 0,
    };
  },

  toJSON(message: AggregationResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => Invoice.toJSON(e));
    }
    if (message.invoices_count !== 0) {
      obj.invoices_count = Math.round(message.invoices_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregationResponse>, I>>(base?: I): AggregationResponse {
    return AggregationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregationResponse>, I>>(object: I): AggregationResponse {
    const message = createBaseAggregationResponse();
    message.invoices = object.invoices?.map((e) => Invoice.fromPartial(e)) || [];
    message.invoices_count = object.invoices_count ?? 0;
    return message;
  },
};

function createBasePaginatedListInvoicesResponse(): PaginatedListInvoicesResponse {
  return { invoices: [], invoices_count: 0 };
}

export const PaginatedListInvoicesResponse: MessageFns<PaginatedListInvoicesResponse> = {
  encode(message: PaginatedListInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.invoices_count !== 0) {
      writer.uint32(16).int32(message.invoices_count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginatedListInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginatedListInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoices_count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginatedListInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
      invoices_count: isSet(object.invoices_count) ? globalThis.Number(object.invoices_count) : 0,
    };
  },

  toJSON(message: PaginatedListInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    if (message.invoices_count !== 0) {
      obj.invoices_count = Math.round(message.invoices_count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginatedListInvoicesResponse>, I>>(base?: I): PaginatedListInvoicesResponse {
    return PaginatedListInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginatedListInvoicesResponse>, I>>(
    object: I,
  ): PaginatedListInvoicesResponse {
    const message = createBasePaginatedListInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    message.invoices_count = object.invoices_count ?? 0;
    return message;
  },
};

function createBaseListInvoicesResponse(): ListInvoicesResponse {
  return { invoices: [] };
}

export const ListInvoicesResponse: MessageFns<ListInvoicesResponse> = {
  encode(message: ListInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInvoicesResponse>, I>>(base?: I): ListInvoicesResponse {
    return ListInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInvoicesResponse>, I>>(object: I): ListInvoicesResponse {
    const message = createBaseListInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIsInvoicePaidRequest(): IsInvoicePaidRequest {
  return { context: undefined, invoice_id: undefined };
}

export const IsInvoicePaidRequest: MessageFns<IsInvoicePaidRequest> = {
  encode(message: IsInvoicePaidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsInvoicePaidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsInvoicePaidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsInvoicePaidRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: IsInvoicePaidRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsInvoicePaidRequest>, I>>(base?: I): IsInvoicePaidRequest {
    return IsInvoicePaidRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsInvoicePaidRequest>, I>>(object: I): IsInvoicePaidRequest {
    const message = createBaseIsInvoicePaidRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

function createBaseIsInvoicePaidResponse(): IsInvoicePaidResponse {
  return { is_paid: false };
}

export const IsInvoicePaidResponse: MessageFns<IsInvoicePaidResponse> = {
  encode(message: IsInvoicePaidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.is_paid !== false) {
      writer.uint32(8).bool(message.is_paid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsInvoicePaidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsInvoicePaidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.is_paid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsInvoicePaidResponse {
    return { is_paid: isSet(object.is_paid) ? globalThis.Boolean(object.is_paid) : false };
  },

  toJSON(message: IsInvoicePaidResponse): unknown {
    const obj: any = {};
    if (message.is_paid !== false) {
      obj.is_paid = message.is_paid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsInvoicePaidResponse>, I>>(base?: I): IsInvoicePaidResponse {
    return IsInvoicePaidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsInvoicePaidResponse>, I>>(object: I): IsInvoicePaidResponse {
    const message = createBaseIsInvoicePaidResponse();
    message.is_paid = object.is_paid ?? false;
    return message;
  },
};

function createBaseCreateInvoiceRequest(): CreateInvoiceRequest {
  return {
    context: undefined,
    title: "",
    description: "",
    show_hst: false,
    disable_tax: false,
    users: [],
    families: [],
    items: [],
    coupons: [],
    due_date: undefined,
    school_year: undefined,
    auto_pay_enabled: false,
    charge_on_date: undefined,
    auto_payment_status: AutoPaymentStatus.AutoPayPending,
    is_tuition: false,
  };
}

export const CreateInvoiceRequest: MessageFns<CreateInvoiceRequest> = {
  encode(message: CreateInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.show_hst !== false) {
      writer.uint32(32).bool(message.show_hst);
    }
    if (message.disable_tax !== false) {
      writer.uint32(40).bool(message.disable_tax);
    }
    for (const v of message.users) {
      ObjectId.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.families) {
      ObjectId.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.due_date !== undefined) {
      Timestamp.encode(toTimestamp(message.due_date), writer.uint32(82).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(90).fork()).join();
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      writer.uint32(96).bool(message.auto_pay_enabled);
    }
    if (message.charge_on_date !== undefined) {
      Timestamp.encode(toTimestamp(message.charge_on_date), writer.uint32(106).fork()).join();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(112).int32(autoPaymentStatusToNumber(message.auto_payment_status));
    }
    if (message.is_tuition !== undefined && message.is_tuition !== false) {
      writer.uint32(120).bool(message.is_tuition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.show_hst = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disable_tax = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.users.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.families.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.due_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.auto_pay_enabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.charge_on_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.auto_payment_status = autoPaymentStatusFromJSON(reader.int32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.is_tuition = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      show_hst: isSet(object.show_hst) ? globalThis.Boolean(object.show_hst) : false,
      disable_tax: isSet(object.disable_tax) ? globalThis.Boolean(object.disable_tax) : false,
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => ObjectId.fromJSON(e)) : [],
      families: globalThis.Array.isArray(object?.families) ? object.families.map((e: any) => ObjectId.fromJSON(e)) : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      due_date: isSet(object.due_date) ? fromJsonTimestamp(object.due_date) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
      auto_pay_enabled: isSet(object.auto_pay_enabled) ? globalThis.Boolean(object.auto_pay_enabled) : false,
      charge_on_date: isSet(object.charge_on_date) ? fromJsonTimestamp(object.charge_on_date) : undefined,
      auto_payment_status: isSet(object.auto_payment_status)
        ? autoPaymentStatusFromJSON(object.auto_payment_status)
        : AutoPaymentStatus.AutoPayPending,
      is_tuition: isSet(object.is_tuition) ? globalThis.Boolean(object.is_tuition) : false,
    };
  },

  toJSON(message: CreateInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.show_hst !== false) {
      obj.show_hst = message.show_hst;
    }
    if (message.disable_tax !== false) {
      obj.disable_tax = message.disable_tax;
    }
    if (message.users?.length) {
      obj.users = message.users.map((e) => ObjectId.toJSON(e));
    }
    if (message.families?.length) {
      obj.families = message.families.map((e) => ObjectId.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.due_date !== undefined) {
      obj.due_date = message.due_date.toISOString();
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      obj.auto_pay_enabled = message.auto_pay_enabled;
    }
    if (message.charge_on_date !== undefined) {
      obj.charge_on_date = message.charge_on_date.toISOString();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      obj.auto_payment_status = autoPaymentStatusToJSON(message.auto_payment_status);
    }
    if (message.is_tuition !== undefined && message.is_tuition !== false) {
      obj.is_tuition = message.is_tuition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(base?: I): CreateInvoiceRequest {
    return CreateInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(object: I): CreateInvoiceRequest {
    const message = createBaseCreateInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.show_hst = object.show_hst ?? false;
    message.disable_tax = object.disable_tax ?? false;
    message.users = object.users?.map((e) => ObjectId.fromPartial(e)) || [];
    message.families = object.families?.map((e) => ObjectId.fromPartial(e)) || [];
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.due_date = object.due_date ?? undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.auto_pay_enabled = object.auto_pay_enabled ?? false;
    message.charge_on_date = object.charge_on_date ?? undefined;
    message.auto_payment_status = object.auto_payment_status ?? AutoPaymentStatus.AutoPayPending;
    message.is_tuition = object.is_tuition ?? false;
    return message;
  },
};

function createBaseCreateInvoicesResponse(): CreateInvoicesResponse {
  return { invoices: [] };
}

export const CreateInvoicesResponse: MessageFns<CreateInvoicesResponse> = {
  encode(message: CreateInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoicesResponse>, I>>(base?: I): CreateInvoicesResponse {
    return CreateInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoicesResponse>, I>>(object: I): CreateInvoicesResponse {
    const message = createBaseCreateInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateInvoiceForClassRequest(): CreateInvoiceForClassRequest {
  return {
    context: undefined,
    title: "",
    description: "",
    show_hst: false,
    disable_tax: false,
    homerooms: [],
    courses: [],
    items: [],
    coupons: [],
    due_date: undefined,
    school_year: undefined,
    auto_pay_enabled: false,
    charge_on_date: undefined,
    auto_payment_status: AutoPaymentStatus.AutoPayPending,
  };
}

export const CreateInvoiceForClassRequest: MessageFns<CreateInvoiceForClassRequest> = {
  encode(message: CreateInvoiceForClassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.show_hst !== false) {
      writer.uint32(32).bool(message.show_hst);
    }
    if (message.disable_tax !== false) {
      writer.uint32(40).bool(message.disable_tax);
    }
    for (const v of message.homerooms) {
      ObjectId.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.courses) {
      ObjectId.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.due_date !== undefined) {
      Timestamp.encode(toTimestamp(message.due_date), writer.uint32(82).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(90).fork()).join();
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      writer.uint32(96).bool(message.auto_pay_enabled);
    }
    if (message.charge_on_date !== undefined) {
      Timestamp.encode(toTimestamp(message.charge_on_date), writer.uint32(106).fork()).join();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(112).int32(autoPaymentStatusToNumber(message.auto_payment_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceForClassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceForClassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.show_hst = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disable_tax = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.homerooms.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.courses.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.due_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.auto_pay_enabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.charge_on_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.auto_payment_status = autoPaymentStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceForClassRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      show_hst: isSet(object.show_hst) ? globalThis.Boolean(object.show_hst) : false,
      disable_tax: isSet(object.disable_tax) ? globalThis.Boolean(object.disable_tax) : false,
      homerooms: globalThis.Array.isArray(object?.homerooms)
        ? object.homerooms.map((e: any) => ObjectId.fromJSON(e))
        : [],
      courses: globalThis.Array.isArray(object?.courses) ? object.courses.map((e: any) => ObjectId.fromJSON(e)) : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      due_date: isSet(object.due_date) ? fromJsonTimestamp(object.due_date) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
      auto_pay_enabled: isSet(object.auto_pay_enabled) ? globalThis.Boolean(object.auto_pay_enabled) : false,
      charge_on_date: isSet(object.charge_on_date) ? fromJsonTimestamp(object.charge_on_date) : undefined,
      auto_payment_status: isSet(object.auto_payment_status)
        ? autoPaymentStatusFromJSON(object.auto_payment_status)
        : AutoPaymentStatus.AutoPayPending,
    };
  },

  toJSON(message: CreateInvoiceForClassRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.show_hst !== false) {
      obj.show_hst = message.show_hst;
    }
    if (message.disable_tax !== false) {
      obj.disable_tax = message.disable_tax;
    }
    if (message.homerooms?.length) {
      obj.homerooms = message.homerooms.map((e) => ObjectId.toJSON(e));
    }
    if (message.courses?.length) {
      obj.courses = message.courses.map((e) => ObjectId.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.due_date !== undefined) {
      obj.due_date = message.due_date.toISOString();
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      obj.auto_pay_enabled = message.auto_pay_enabled;
    }
    if (message.charge_on_date !== undefined) {
      obj.charge_on_date = message.charge_on_date.toISOString();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      obj.auto_payment_status = autoPaymentStatusToJSON(message.auto_payment_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceForClassRequest>, I>>(base?: I): CreateInvoiceForClassRequest {
    return CreateInvoiceForClassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceForClassRequest>, I>>(object: I): CreateInvoiceForClassRequest {
    const message = createBaseCreateInvoiceForClassRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.show_hst = object.show_hst ?? false;
    message.disable_tax = object.disable_tax ?? false;
    message.homerooms = object.homerooms?.map((e) => ObjectId.fromPartial(e)) || [];
    message.courses = object.courses?.map((e) => ObjectId.fromPartial(e)) || [];
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.due_date = object.due_date ?? undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.auto_pay_enabled = object.auto_pay_enabled ?? false;
    message.charge_on_date = object.charge_on_date ?? undefined;
    message.auto_payment_status = object.auto_payment_status ?? AutoPaymentStatus.AutoPayPending;
    return message;
  },
};

function createBaseGenerateInterviewFeeInvoiceRequest(): GenerateInterviewFeeInvoiceRequest {
  return { context: undefined, student_id: undefined, school_year: undefined };
}

export const GenerateInterviewFeeInvoiceRequest: MessageFns<GenerateInterviewFeeInvoiceRequest> = {
  encode(message: GenerateInterviewFeeInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.student_id !== undefined) {
      ObjectId.encode(message.student_id, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateInterviewFeeInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateInterviewFeeInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.student_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateInterviewFeeInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_id: isSet(object.student_id) ? ObjectId.fromJSON(object.student_id) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
    };
  },

  toJSON(message: GenerateInterviewFeeInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_id !== undefined) {
      obj.student_id = ObjectId.toJSON(message.student_id);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateInterviewFeeInvoiceRequest>, I>>(
    base?: I,
  ): GenerateInterviewFeeInvoiceRequest {
    return GenerateInterviewFeeInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateInterviewFeeInvoiceRequest>, I>>(
    object: I,
  ): GenerateInterviewFeeInvoiceRequest {
    const message = createBaseGenerateInterviewFeeInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_id = (object.student_id !== undefined && object.student_id !== null)
      ? ObjectId.fromPartial(object.student_id)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseGenerateWaitlistFeeInvoiceRequest(): GenerateWaitlistFeeInvoiceRequest {
  return { context: undefined, student_id: undefined, school_year: undefined };
}

export const GenerateWaitlistFeeInvoiceRequest: MessageFns<GenerateWaitlistFeeInvoiceRequest> = {
  encode(message: GenerateWaitlistFeeInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.student_id !== undefined) {
      ObjectId.encode(message.student_id, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateWaitlistFeeInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateWaitlistFeeInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.student_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateWaitlistFeeInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_id: isSet(object.student_id) ? ObjectId.fromJSON(object.student_id) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
    };
  },

  toJSON(message: GenerateWaitlistFeeInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_id !== undefined) {
      obj.student_id = ObjectId.toJSON(message.student_id);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateWaitlistFeeInvoiceRequest>, I>>(
    base?: I,
  ): GenerateWaitlistFeeInvoiceRequest {
    return GenerateWaitlistFeeInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateWaitlistFeeInvoiceRequest>, I>>(
    object: I,
  ): GenerateWaitlistFeeInvoiceRequest {
    const message = createBaseGenerateWaitlistFeeInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_id = (object.student_id !== undefined && object.student_id !== null)
      ? ObjectId.fromPartial(object.student_id)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseGenerateRegistrationFeesInvoiceRequest(): GenerateRegistrationFeesInvoiceRequest {
  return { context: undefined, student_id: undefined, school_year: undefined };
}

export const GenerateRegistrationFeesInvoiceRequest: MessageFns<GenerateRegistrationFeesInvoiceRequest> = {
  encode(message: GenerateRegistrationFeesInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.student_id !== undefined) {
      ObjectId.encode(message.student_id, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRegistrationFeesInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRegistrationFeesInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.student_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRegistrationFeesInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_id: isSet(object.student_id) ? ObjectId.fromJSON(object.student_id) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
    };
  },

  toJSON(message: GenerateRegistrationFeesInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_id !== undefined) {
      obj.student_id = ObjectId.toJSON(message.student_id);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateRegistrationFeesInvoiceRequest>, I>>(
    base?: I,
  ): GenerateRegistrationFeesInvoiceRequest {
    return GenerateRegistrationFeesInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateRegistrationFeesInvoiceRequest>, I>>(
    object: I,
  ): GenerateRegistrationFeesInvoiceRequest {
    const message = createBaseGenerateRegistrationFeesInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_id = (object.student_id !== undefined && object.student_id !== null)
      ? ObjectId.fromPartial(object.student_id)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseCreateInvoiceForClassResponse(): CreateInvoiceForClassResponse {
  return { invoices: [] };
}

export const CreateInvoiceForClassResponse: MessageFns<CreateInvoiceForClassResponse> = {
  encode(message: CreateInvoiceForClassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceForClassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceForClassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceForClassResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateInvoiceForClassResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceForClassResponse>, I>>(base?: I): CreateInvoiceForClassResponse {
    return CreateInvoiceForClassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceForClassResponse>, I>>(
    object: I,
  ): CreateInvoiceForClassResponse {
    const message = createBaseCreateInvoiceForClassResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateInvoiceRequest(): UpdateInvoiceRequest {
  return {
    context: undefined,
    id: undefined,
    title: "",
    description: "",
    show_hst: false,
    disable_tax: false,
    items: [],
    coupons: [],
    due_date: undefined,
  };
}

export const UpdateInvoiceRequest: MessageFns<UpdateInvoiceRequest> = {
  encode(message: UpdateInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.show_hst !== false) {
      writer.uint32(40).bool(message.show_hst);
    }
    if (message.disable_tax !== false) {
      writer.uint32(48).bool(message.disable_tax);
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.due_date !== undefined) {
      Timestamp.encode(toTimestamp(message.due_date), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.show_hst = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.disable_tax = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.due_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      show_hst: isSet(object.show_hst) ? globalThis.Boolean(object.show_hst) : false,
      disable_tax: isSet(object.disable_tax) ? globalThis.Boolean(object.disable_tax) : false,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      due_date: isSet(object.due_date) ? fromJsonTimestamp(object.due_date) : undefined,
    };
  },

  toJSON(message: UpdateInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.show_hst !== false) {
      obj.show_hst = message.show_hst;
    }
    if (message.disable_tax !== false) {
      obj.disable_tax = message.disable_tax;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.due_date !== undefined) {
      obj.due_date = message.due_date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInvoiceRequest>, I>>(base?: I): UpdateInvoiceRequest {
    return UpdateInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInvoiceRequest>, I>>(object: I): UpdateInvoiceRequest {
    const message = createBaseUpdateInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.show_hst = object.show_hst ?? false;
    message.disable_tax = object.disable_tax ?? false;
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.due_date = object.due_date ?? undefined;
    return message;
  },
};

function createBaseUpdateInvoiceAutoPaymentRequest(): UpdateInvoiceAutoPaymentRequest {
  return { context: undefined, id: undefined, auto_pay_enabled: false, charge_on_date: undefined };
}

export const UpdateInvoiceAutoPaymentRequest: MessageFns<UpdateInvoiceAutoPaymentRequest> = {
  encode(message: UpdateInvoiceAutoPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.auto_pay_enabled !== false) {
      writer.uint32(24).bool(message.auto_pay_enabled);
    }
    if (message.charge_on_date !== undefined) {
      Timestamp.encode(toTimestamp(message.charge_on_date), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvoiceAutoPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvoiceAutoPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.auto_pay_enabled = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.charge_on_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvoiceAutoPaymentRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      auto_pay_enabled: isSet(object.auto_pay_enabled) ? globalThis.Boolean(object.auto_pay_enabled) : false,
      charge_on_date: isSet(object.charge_on_date) ? fromJsonTimestamp(object.charge_on_date) : undefined,
    };
  },

  toJSON(message: UpdateInvoiceAutoPaymentRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.auto_pay_enabled !== false) {
      obj.auto_pay_enabled = message.auto_pay_enabled;
    }
    if (message.charge_on_date !== undefined) {
      obj.charge_on_date = message.charge_on_date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInvoiceAutoPaymentRequest>, I>>(base?: I): UpdateInvoiceAutoPaymentRequest {
    return UpdateInvoiceAutoPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInvoiceAutoPaymentRequest>, I>>(
    object: I,
  ): UpdateInvoiceAutoPaymentRequest {
    const message = createBaseUpdateInvoiceAutoPaymentRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.auto_pay_enabled = object.auto_pay_enabled ?? false;
    message.charge_on_date = object.charge_on_date ?? undefined;
    return message;
  },
};

function createBaseArchiveInvoiceRequest(): ArchiveInvoiceRequest {
  return { context: undefined, invoice_id: undefined };
}

export const ArchiveInvoiceRequest: MessageFns<ArchiveInvoiceRequest> = {
  encode(message: ArchiveInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArchiveInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArchiveInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: ArchiveInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArchiveInvoiceRequest>, I>>(base?: I): ArchiveInvoiceRequest {
    return ArchiveInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArchiveInvoiceRequest>, I>>(object: I): ArchiveInvoiceRequest {
    const message = createBaseArchiveInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

function createBaseUnarchiveInvoiceRequest(): UnarchiveInvoiceRequest {
  return { context: undefined, invoice_id: undefined };
}

export const UnarchiveInvoiceRequest: MessageFns<UnarchiveInvoiceRequest> = {
  encode(message: UnarchiveInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnarchiveInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnarchiveInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnarchiveInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: UnarchiveInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnarchiveInvoiceRequest>, I>>(base?: I): UnarchiveInvoiceRequest {
    return UnarchiveInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnarchiveInvoiceRequest>, I>>(object: I): UnarchiveInvoiceRequest {
    const message = createBaseUnarchiveInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

function createBaseGetAutoPayInvoicesReadyToChargeRequest(): GetAutoPayInvoicesReadyToChargeRequest {
  return { context: undefined };
}

export const GetAutoPayInvoicesReadyToChargeRequest: MessageFns<GetAutoPayInvoicesReadyToChargeRequest> = {
  encode(message: GetAutoPayInvoicesReadyToChargeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutoPayInvoicesReadyToChargeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoPayInvoicesReadyToChargeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoPayInvoicesReadyToChargeRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetAutoPayInvoicesReadyToChargeRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAutoPayInvoicesReadyToChargeRequest>, I>>(
    base?: I,
  ): GetAutoPayInvoicesReadyToChargeRequest {
    return GetAutoPayInvoicesReadyToChargeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAutoPayInvoicesReadyToChargeRequest>, I>>(
    object: I,
  ): GetAutoPayInvoicesReadyToChargeRequest {
    const message = createBaseGetAutoPayInvoicesReadyToChargeRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseSetAutoPayInvoiceStatusRequest(): SetAutoPayInvoiceStatusRequest {
  return { context: undefined, invoice_id: undefined, auto_payment_status: AutoPaymentStatus.AutoPayPending };
}

export const SetAutoPayInvoiceStatusRequest: MessageFns<SetAutoPayInvoiceStatusRequest> = {
  encode(message: SetAutoPayInvoiceStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    if (message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(24).int32(autoPaymentStatusToNumber(message.auto_payment_status));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAutoPayInvoiceStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAutoPayInvoiceStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.auto_payment_status = autoPaymentStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAutoPayInvoiceStatusRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
      auto_payment_status: isSet(object.auto_payment_status)
        ? autoPaymentStatusFromJSON(object.auto_payment_status)
        : AutoPaymentStatus.AutoPayPending,
    };
  },

  toJSON(message: SetAutoPayInvoiceStatusRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    if (message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      obj.auto_payment_status = autoPaymentStatusToJSON(message.auto_payment_status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAutoPayInvoiceStatusRequest>, I>>(base?: I): SetAutoPayInvoiceStatusRequest {
    return SetAutoPayInvoiceStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAutoPayInvoiceStatusRequest>, I>>(
    object: I,
  ): SetAutoPayInvoiceStatusRequest {
    const message = createBaseSetAutoPayInvoiceStatusRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    message.auto_payment_status = object.auto_payment_status ?? AutoPaymentStatus.AutoPayPending;
    return message;
  },
};

function createBaseGetFamilyTuitionInvoicesRequest(): GetFamilyTuitionInvoicesRequest {
  return {
    context: undefined,
    family_id: undefined,
    school_year: undefined,
    start_date: undefined,
    end_date: undefined,
  };
}

export const GetFamilyTuitionInvoicesRequest: MessageFns<GetFamilyTuitionInvoicesRequest> = {
  encode(message: GetFamilyTuitionInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.family_id !== undefined) {
      ObjectId.encode(message.family_id, writer.uint32(18).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    if (message.start_date !== undefined) {
      Timestamp.encode(toTimestamp(message.start_date), writer.uint32(34).fork()).join();
    }
    if (message.end_date !== undefined) {
      Timestamp.encode(toTimestamp(message.end_date), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFamilyTuitionInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFamilyTuitionInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.family_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.start_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.end_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFamilyTuitionInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      family_id: isSet(object.family_id) ? ObjectId.fromJSON(object.family_id) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
      start_date: isSet(object.start_date) ? fromJsonTimestamp(object.start_date) : undefined,
      end_date: isSet(object.end_date) ? fromJsonTimestamp(object.end_date) : undefined,
    };
  },

  toJSON(message: GetFamilyTuitionInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.family_id !== undefined) {
      obj.family_id = ObjectId.toJSON(message.family_id);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    if (message.start_date !== undefined) {
      obj.start_date = message.start_date.toISOString();
    }
    if (message.end_date !== undefined) {
      obj.end_date = message.end_date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFamilyTuitionInvoicesRequest>, I>>(base?: I): GetFamilyTuitionInvoicesRequest {
    return GetFamilyTuitionInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFamilyTuitionInvoicesRequest>, I>>(
    object: I,
  ): GetFamilyTuitionInvoicesRequest {
    const message = createBaseGetFamilyTuitionInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.family_id = (object.family_id !== undefined && object.family_id !== null)
      ? ObjectId.fromPartial(object.family_id)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.start_date = object.start_date ?? undefined;
    message.end_date = object.end_date ?? undefined;
    return message;
  },
};

function createBaseGetStudentsWithUnpaidInvoicesRequest(): GetStudentsWithUnpaidInvoicesRequest {
  return { context: undefined, student_statuses: [], school_year: undefined };
}

export const GetStudentsWithUnpaidInvoicesRequest: MessageFns<GetStudentsWithUnpaidInvoicesRequest> = {
  encode(message: GetStudentsWithUnpaidInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.student_statuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithUnpaidInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithUnpaidInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.student_statuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.student_statuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithUnpaidInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      student_statuses: globalThis.Array.isArray(object?.student_statuses)
        ? object.student_statuses.map((e: any) => studentStatusFromJSON(e))
        : [],
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
    };
  },

  toJSON(message: GetStudentsWithUnpaidInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.student_statuses?.length) {
      obj.student_statuses = message.student_statuses.map((e) => studentStatusToJSON(e));
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesRequest>, I>>(
    base?: I,
  ): GetStudentsWithUnpaidInvoicesRequest {
    return GetStudentsWithUnpaidInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesRequest>, I>>(
    object: I,
  ): GetStudentsWithUnpaidInvoicesRequest {
    const message = createBaseGetStudentsWithUnpaidInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.student_statuses = object.student_statuses?.map((e) => e) || [];
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseGetStudentsWithUnpaidInvoicesResponse(): GetStudentsWithUnpaidInvoicesResponse {
  return { student_ids: [] };
}

export const GetStudentsWithUnpaidInvoicesResponse: MessageFns<GetStudentsWithUnpaidInvoicesResponse> = {
  encode(message: GetStudentsWithUnpaidInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.student_ids) {
      ObjectId.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithUnpaidInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithUnpaidInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.student_ids.push(ObjectId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithUnpaidInvoicesResponse {
    return {
      student_ids: globalThis.Array.isArray(object?.student_ids)
        ? object.student_ids.map((e: any) => ObjectId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetStudentsWithUnpaidInvoicesResponse): unknown {
    const obj: any = {};
    if (message.student_ids?.length) {
      obj.student_ids = message.student_ids.map((e) => ObjectId.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesResponse>, I>>(
    base?: I,
  ): GetStudentsWithUnpaidInvoicesResponse {
    return GetStudentsWithUnpaidInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesResponse>, I>>(
    object: I,
  ): GetStudentsWithUnpaidInvoicesResponse {
    const message = createBaseGetStudentsWithUnpaidInvoicesResponse();
    message.student_ids = object.student_ids?.map((e) => ObjectId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStudentsWithReregistrationInvoicesRequest(): GetStudentsWithReregistrationInvoicesRequest {
  return { context: undefined, school_year: undefined };
}

export const GetStudentsWithReregistrationInvoicesRequest: MessageFns<GetStudentsWithReregistrationInvoicesRequest> = {
  encode(
    message: GetStudentsWithReregistrationInvoicesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithReregistrationInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithReregistrationInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithReregistrationInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      school_year: isSet(object.school_year) ? ObjectId.fromJSON(object.school_year) : undefined,
    };
  },

  toJSON(message: GetStudentsWithReregistrationInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.school_year !== undefined) {
      obj.school_year = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesRequest>, I>>(
    base?: I,
  ): GetStudentsWithReregistrationInvoicesRequest {
    return GetStudentsWithReregistrationInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesRequest>, I>>(
    object: I,
  ): GetStudentsWithReregistrationInvoicesRequest {
    const message = createBaseGetStudentsWithReregistrationInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseGetStudentsWithReregistrationInvoicesResponse(): GetStudentsWithReregistrationInvoicesResponse {
  return { student_ids: [] };
}

export const GetStudentsWithReregistrationInvoicesResponse: MessageFns<GetStudentsWithReregistrationInvoicesResponse> =
  {
    encode(
      message: GetStudentsWithReregistrationInvoicesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.student_ids) {
        ObjectId.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithReregistrationInvoicesResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetStudentsWithReregistrationInvoicesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.student_ids.push(ObjectId.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetStudentsWithReregistrationInvoicesResponse {
      return {
        student_ids: globalThis.Array.isArray(object?.student_ids)
          ? object.student_ids.map((e: any) => ObjectId.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetStudentsWithReregistrationInvoicesResponse): unknown {
      const obj: any = {};
      if (message.student_ids?.length) {
        obj.student_ids = message.student_ids.map((e) => ObjectId.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesResponse>, I>>(
      base?: I,
    ): GetStudentsWithReregistrationInvoicesResponse {
      return GetStudentsWithReregistrationInvoicesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesResponse>, I>>(
      object: I,
    ): GetStudentsWithReregistrationInvoicesResponse {
      const message = createBaseGetStudentsWithReregistrationInvoicesResponse();
      message.student_ids = object.student_ids?.map((e) => ObjectId.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetOrgPaidBassemLabsFeesInPeriodRequest(): GetOrgPaidBassemLabsFeesInPeriodRequest {
  return { context: undefined, organization_id: undefined, start_date: undefined, end_date: undefined };
}

export const GetOrgPaidBassemLabsFeesInPeriodRequest: MessageFns<GetOrgPaidBassemLabsFeesInPeriodRequest> = {
  encode(message: GetOrgPaidBassemLabsFeesInPeriodRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.organization_id !== undefined) {
      ObjectId.encode(message.organization_id, writer.uint32(18).fork()).join();
    }
    if (message.start_date !== undefined) {
      Timestamp.encode(toTimestamp(message.start_date), writer.uint32(26).fork()).join();
    }
    if (message.end_date !== undefined) {
      Timestamp.encode(toTimestamp(message.end_date), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrgPaidBassemLabsFeesInPeriodRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrgPaidBassemLabsFeesInPeriodRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.start_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.end_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrgPaidBassemLabsFeesInPeriodRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      organization_id: isSet(object.organization_id) ? ObjectId.fromJSON(object.organization_id) : undefined,
      start_date: isSet(object.start_date) ? fromJsonTimestamp(object.start_date) : undefined,
      end_date: isSet(object.end_date) ? fromJsonTimestamp(object.end_date) : undefined,
    };
  },

  toJSON(message: GetOrgPaidBassemLabsFeesInPeriodRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.organization_id !== undefined) {
      obj.organization_id = ObjectId.toJSON(message.organization_id);
    }
    if (message.start_date !== undefined) {
      obj.start_date = message.start_date.toISOString();
    }
    if (message.end_date !== undefined) {
      obj.end_date = message.end_date.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrgPaidBassemLabsFeesInPeriodRequest>, I>>(
    base?: I,
  ): GetOrgPaidBassemLabsFeesInPeriodRequest {
    return GetOrgPaidBassemLabsFeesInPeriodRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrgPaidBassemLabsFeesInPeriodRequest>, I>>(
    object: I,
  ): GetOrgPaidBassemLabsFeesInPeriodRequest {
    const message = createBaseGetOrgPaidBassemLabsFeesInPeriodRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.organization_id = (object.organization_id !== undefined && object.organization_id !== null)
      ? ObjectId.fromPartial(object.organization_id)
      : undefined;
    message.start_date = object.start_date ?? undefined;
    message.end_date = object.end_date ?? undefined;
    return message;
  },
};

function createBaseGetOrgPaidBassemLabsFeesInPeriodResponse(): GetOrgPaidBassemLabsFeesInPeriodResponse {
  return { total_amount: 0 };
}

export const GetOrgPaidBassemLabsFeesInPeriodResponse: MessageFns<GetOrgPaidBassemLabsFeesInPeriodResponse> = {
  encode(message: GetOrgPaidBassemLabsFeesInPeriodResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total_amount !== 0) {
      writer.uint32(9).double(message.total_amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrgPaidBassemLabsFeesInPeriodResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrgPaidBassemLabsFeesInPeriodResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.total_amount = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrgPaidBassemLabsFeesInPeriodResponse {
    return { total_amount: isSet(object.total_amount) ? globalThis.Number(object.total_amount) : 0 };
  },

  toJSON(message: GetOrgPaidBassemLabsFeesInPeriodResponse): unknown {
    const obj: any = {};
    if (message.total_amount !== 0) {
      obj.total_amount = message.total_amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrgPaidBassemLabsFeesInPeriodResponse>, I>>(
    base?: I,
  ): GetOrgPaidBassemLabsFeesInPeriodResponse {
    return GetOrgPaidBassemLabsFeesInPeriodResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrgPaidBassemLabsFeesInPeriodResponse>, I>>(
    object: I,
  ): GetOrgPaidBassemLabsFeesInPeriodResponse {
    const message = createBaseGetOrgPaidBassemLabsFeesInPeriodResponse();
    message.total_amount = object.total_amount ?? 0;
    return message;
  },
};

function createBaseUpsertOrganizationInvoiceRequest(): UpsertOrganizationInvoiceRequest {
  return {
    context: undefined,
    organization_id: undefined,
    invoice_start_date: undefined,
    invoice_end_date: undefined,
    current_enrolled_students_count: 0,
    is_in_trial_period: false,
  };
}

export const UpsertOrganizationInvoiceRequest: MessageFns<UpsertOrganizationInvoiceRequest> = {
  encode(message: UpsertOrganizationInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.organization_id !== undefined) {
      ObjectId.encode(message.organization_id, writer.uint32(18).fork()).join();
    }
    if (message.invoice_start_date !== undefined) {
      Timestamp.encode(toTimestamp(message.invoice_start_date), writer.uint32(26).fork()).join();
    }
    if (message.invoice_end_date !== undefined) {
      Timestamp.encode(toTimestamp(message.invoice_end_date), writer.uint32(34).fork()).join();
    }
    if (message.current_enrolled_students_count !== 0) {
      writer.uint32(40).uint32(message.current_enrolled_students_count);
    }
    if (message.is_in_trial_period !== false) {
      writer.uint32(48).bool(message.is_in_trial_period);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpsertOrganizationInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpsertOrganizationInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invoice_start_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invoice_end_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.current_enrolled_students_count = reader.uint32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.is_in_trial_period = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpsertOrganizationInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      organization_id: isSet(object.organization_id) ? ObjectId.fromJSON(object.organization_id) : undefined,
      invoice_start_date: isSet(object.invoice_start_date) ? fromJsonTimestamp(object.invoice_start_date) : undefined,
      invoice_end_date: isSet(object.invoice_end_date) ? fromJsonTimestamp(object.invoice_end_date) : undefined,
      current_enrolled_students_count: isSet(object.current_enrolled_students_count)
        ? globalThis.Number(object.current_enrolled_students_count)
        : 0,
      is_in_trial_period: isSet(object.is_in_trial_period) ? globalThis.Boolean(object.is_in_trial_period) : false,
    };
  },

  toJSON(message: UpsertOrganizationInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.organization_id !== undefined) {
      obj.organization_id = ObjectId.toJSON(message.organization_id);
    }
    if (message.invoice_start_date !== undefined) {
      obj.invoice_start_date = message.invoice_start_date.toISOString();
    }
    if (message.invoice_end_date !== undefined) {
      obj.invoice_end_date = message.invoice_end_date.toISOString();
    }
    if (message.current_enrolled_students_count !== 0) {
      obj.current_enrolled_students_count = Math.round(message.current_enrolled_students_count);
    }
    if (message.is_in_trial_period !== false) {
      obj.is_in_trial_period = message.is_in_trial_period;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpsertOrganizationInvoiceRequest>, I>>(
    base?: I,
  ): UpsertOrganizationInvoiceRequest {
    return UpsertOrganizationInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpsertOrganizationInvoiceRequest>, I>>(
    object: I,
  ): UpsertOrganizationInvoiceRequest {
    const message = createBaseUpsertOrganizationInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.organization_id = (object.organization_id !== undefined && object.organization_id !== null)
      ? ObjectId.fromPartial(object.organization_id)
      : undefined;
    message.invoice_start_date = object.invoice_start_date ?? undefined;
    message.invoice_end_date = object.invoice_end_date ?? undefined;
    message.current_enrolled_students_count = object.current_enrolled_students_count ?? 0;
    message.is_in_trial_period = object.is_in_trial_period ?? false;
    return message;
  },
};

function createBaseGetOrganizationInvoicesRequest(): GetOrganizationInvoicesRequest {
  return { context: undefined };
}

export const GetOrganizationInvoicesRequest: MessageFns<GetOrganizationInvoicesRequest> = {
  encode(message: GetOrganizationInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrganizationInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationInvoicesRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetOrganizationInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationInvoicesRequest>, I>>(base?: I): GetOrganizationInvoicesRequest {
    return GetOrganizationInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrganizationInvoicesRequest>, I>>(
    object: I,
  ): GetOrganizationInvoicesRequest {
    const message = createBaseGetOrganizationInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseGetAllOrganizationInvoicesRequest(): GetAllOrganizationInvoicesRequest {
  return { context: undefined };
}

export const GetAllOrganizationInvoicesRequest: MessageFns<GetAllOrganizationInvoicesRequest> = {
  encode(message: GetAllOrganizationInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllOrganizationInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllOrganizationInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllOrganizationInvoicesRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetAllOrganizationInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllOrganizationInvoicesRequest>, I>>(
    base?: I,
  ): GetAllOrganizationInvoicesRequest {
    return GetAllOrganizationInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllOrganizationInvoicesRequest>, I>>(
    object: I,
  ): GetAllOrganizationInvoicesRequest {
    const message = createBaseGetAllOrganizationInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseGetFailedAutoPayInvoicesRequest(): GetFailedAutoPayInvoicesRequest {
  return { context: undefined };
}

export const GetFailedAutoPayInvoicesRequest: MessageFns<GetFailedAutoPayInvoicesRequest> = {
  encode(message: GetFailedAutoPayInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFailedAutoPayInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFailedAutoPayInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFailedAutoPayInvoicesRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetFailedAutoPayInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFailedAutoPayInvoicesRequest>, I>>(base?: I): GetFailedAutoPayInvoicesRequest {
    return GetFailedAutoPayInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFailedAutoPayInvoicesRequest>, I>>(
    object: I,
  ): GetFailedAutoPayInvoicesRequest {
    const message = createBaseGetFailedAutoPayInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseGetAutoPaymentAttemptsRequest(): GetAutoPaymentAttemptsRequest {
  return { context: undefined, invoice_id: undefined };
}

export const GetAutoPaymentAttemptsRequest: MessageFns<GetAutoPaymentAttemptsRequest> = {
  encode(message: GetAutoPaymentAttemptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutoPaymentAttemptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoPaymentAttemptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoPaymentAttemptsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: GetAutoPaymentAttemptsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAutoPaymentAttemptsRequest>, I>>(base?: I): GetAutoPaymentAttemptsRequest {
    return GetAutoPaymentAttemptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAutoPaymentAttemptsRequest>, I>>(
    object: I,
  ): GetAutoPaymentAttemptsRequest {
    const message = createBaseGetAutoPaymentAttemptsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

function createBaseGetAutoPaymentAttemptsResponse(): GetAutoPaymentAttemptsResponse {
  return { attempts: [] };
}

export const GetAutoPaymentAttemptsResponse: MessageFns<GetAutoPaymentAttemptsResponse> = {
  encode(message: GetAutoPaymentAttemptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attempts) {
      AutoPaymentAttempt.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutoPaymentAttemptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoPaymentAttemptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attempts.push(AutoPaymentAttempt.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoPaymentAttemptsResponse {
    return {
      attempts: globalThis.Array.isArray(object?.attempts)
        ? object.attempts.map((e: any) => AutoPaymentAttempt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAutoPaymentAttemptsResponse): unknown {
    const obj: any = {};
    if (message.attempts?.length) {
      obj.attempts = message.attempts.map((e) => AutoPaymentAttempt.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAutoPaymentAttemptsResponse>, I>>(base?: I): GetAutoPaymentAttemptsResponse {
    return GetAutoPaymentAttemptsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAutoPaymentAttemptsResponse>, I>>(
    object: I,
  ): GetAutoPaymentAttemptsResponse {
    const message = createBaseGetAutoPaymentAttemptsResponse();
    message.attempts = object.attempts?.map((e) => AutoPaymentAttempt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResetAutoPaymentForRetryRequest(): ResetAutoPaymentForRetryRequest {
  return { context: undefined, invoice_id: undefined };
}

export const ResetAutoPaymentForRetryRequest: MessageFns<ResetAutoPaymentForRetryRequest> = {
  encode(message: ResetAutoPaymentForRetryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetAutoPaymentForRetryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetAutoPaymentForRetryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetAutoPaymentForRetryRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoice_id: isSet(object.invoice_id) ? ObjectId.fromJSON(object.invoice_id) : undefined,
    };
  },

  toJSON(message: ResetAutoPaymentForRetryRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoice_id !== undefined) {
      obj.invoice_id = ObjectId.toJSON(message.invoice_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetAutoPaymentForRetryRequest>, I>>(base?: I): ResetAutoPaymentForRetryRequest {
    return ResetAutoPaymentForRetryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetAutoPaymentForRetryRequest>, I>>(
    object: I,
  ): ResetAutoPaymentForRetryRequest {
    const message = createBaseResetAutoPaymentForRetryRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

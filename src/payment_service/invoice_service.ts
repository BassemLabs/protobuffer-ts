// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/invoice_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";
import { ActionRequiredByParents } from "../user_service/action_required_by_parents";
import { ObjectId } from "../utils/object_id";
import { RequestContext } from "../utils/request_context";
import {
  AutoPaymentStatus,
  autoPaymentStatusFromJSON,
  autoPaymentStatusToJSON,
  autoPaymentStatusToNumber,
  Coupon,
  Invoice,
  InvoiceFilter,
  InvoiceItem,
  InvoiceResponse,
  StudentStatus,
  studentStatusFromJSON,
  studentStatusToJSON,
  studentStatusToNumber,
} from "./invoice";

export const protobufPackage = "payment_service";

/** Invoice messages */
export interface Invoices {
  invoices: Invoice[];
}

export interface GetInvoiceRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
}

export interface GetInvoiceByNumberRequest {
  context: RequestContext | undefined;
  invoiceNumber: number;
}

export interface GetUserInvoicesRequest {
  context: RequestContext | undefined;
  userId: ObjectId | undefined;
}

export interface GetUserInvoicesResponse {
  invoices: InvoiceResponse[];
}

export interface GetFamilyInvoicesRequest {
  context: RequestContext | undefined;
  familyId: ObjectId | undefined;
}

export interface GetParentInvoicesRequest {
  context: RequestContext | undefined;
  parentId: ObjectId | undefined;
}

export interface GetActionsRequiredByParentsRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
}

export interface GetActionsRequiredByParentsResponse {
  actions: ActionRequiredByParents[];
}

export interface StudentHasNoUnpaidInvoicesRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
}

export interface StudentHasNoUnpaidInvoicesResponse {
  hasNoUnpaidInvoices: boolean;
}

export interface ListInvoicesRequest {
  context: RequestContext | undefined;
  filter: InvoiceFilter | undefined;
}

export interface AggregationResponse {
  invoices: Invoice[];
  invoicesCount: number;
}

export interface PaginatedListInvoicesResponse {
  invoices: InvoiceResponse[];
  invoicesCount: number;
}

export interface ListInvoicesResponse {
  invoices: InvoiceResponse[];
}

export interface IsInvoicePaidRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
}

export interface IsInvoicePaidResponse {
  isPaid: boolean;
}

export interface CreateInvoiceRequest {
  context: RequestContext | undefined;
  title: string;
  description: string;
  showHst: boolean;
  disableTax: boolean;
  user?: ObjectId | undefined;
  family?: ObjectId | undefined;
  items: InvoiceItem[];
  coupons: Coupon[];
  dueDate?: Date | undefined;
  schoolYear: ObjectId | undefined;
  autoPayEnabled?: boolean | undefined;
  chargeOnDate?: Date | undefined;
  autoPaymentStatus?: AutoPaymentStatus | undefined;
  isTuition?: boolean | undefined;
}

export interface CreateInvoiceForClassRequest {
  context: RequestContext | undefined;
  title: string;
  description: string;
  showHst: boolean;
  disableTax: boolean;
  homeroom?: ObjectId | undefined;
  course?: ObjectId | undefined;
  items: InvoiceItem[];
  coupons: Coupon[];
  dueDate?: Date | undefined;
  schoolYear: ObjectId | undefined;
  autoPayEnabled?: boolean | undefined;
  chargeOnDate?: Date | undefined;
  autoPaymentStatus?: AutoPaymentStatus | undefined;
}

export interface GenerateInterviewFeeInvoiceRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
}

export interface GenerateWaitlistFeeInvoiceRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
}

export interface GenerateRegistrationFeesInvoiceRequest {
  context: RequestContext | undefined;
  studentId: ObjectId | undefined;
  schoolYear: ObjectId | undefined;
}

export interface CreateInvoiceForClassResponse {
  invoices: InvoiceResponse[];
}

export interface UpdateInvoiceRequest {
  context: RequestContext | undefined;
  id: ObjectId | undefined;
  title: string;
  description: string;
  showHst: boolean;
  disableTax: boolean;
  items: InvoiceItem[];
  coupons: Coupon[];
  dueDate?: Date | undefined;
}

export interface UpdateInvoiceAutoPaymentRequest {
  context: RequestContext | undefined;
  id: ObjectId | undefined;
  autoPayEnabled: boolean;
  chargeOnDate: Date | undefined;
}

export interface ArchiveInvoiceRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
}

export interface UnarchiveInvoiceRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
}

export interface GetAutoPayInvoicesReadyToChargeRequest {
  context: RequestContext | undefined;
}

export interface SetAutoPayInvoiceStatusRequest {
  context: RequestContext | undefined;
  invoiceId: ObjectId | undefined;
  autoPaymentStatus: AutoPaymentStatus;
}

export interface GetFamilyTuitionInvoicesRequest {
  context: RequestContext | undefined;
  familyId: ObjectId | undefined;
  schoolYear: ObjectId | undefined;
}

export interface GetStudentsWithUnpaidInvoicesRequest {
  context: RequestContext | undefined;
  studentStatuses: StudentStatus[];
  schoolYear: ObjectId | undefined;
}

export interface GetStudentsWithUnpaidInvoicesResponse {
  studentIds: ObjectId[];
}

export interface GetStudentsWithReregistrationInvoicesRequest {
  context: RequestContext | undefined;
  schoolYear: ObjectId | undefined;
}

export interface GetStudentsWithReregistrationInvoicesResponse {
  studentIds: ObjectId[];
}

function createBaseInvoices(): Invoices {
  return { invoices: [] };
}

export const Invoices: MessageFns<Invoices> = {
  encode(message: Invoices, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      Invoice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invoices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(Invoice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invoices {
    return {
      invoices: globalThis.Array.isArray(object?.invoices) ? object.invoices.map((e: any) => Invoice.fromJSON(e)) : [],
    };
  },

  toJSON(message: Invoices): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => Invoice.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Invoices>, I>>(base?: I): Invoices {
    return Invoices.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Invoices>, I>>(object: I): Invoices {
    const message = createBaseInvoices();
    message.invoices = object.invoices?.map((e) => Invoice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetInvoiceRequest(): GetInvoiceRequest {
  return { context: undefined, invoiceId: undefined };
}

export const GetInvoiceRequest: MessageFns<GetInvoiceRequest> = {
  encode(message: GetInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
    };
  },

  toJSON(message: GetInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvoiceRequest>, I>>(base?: I): GetInvoiceRequest {
    return GetInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvoiceRequest>, I>>(object: I): GetInvoiceRequest {
    const message = createBaseGetInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    return message;
  },
};

function createBaseGetInvoiceByNumberRequest(): GetInvoiceByNumberRequest {
  return { context: undefined, invoiceNumber: 0 };
}

export const GetInvoiceByNumberRequest: MessageFns<GetInvoiceByNumberRequest> = {
  encode(message: GetInvoiceByNumberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceNumber !== 0) {
      writer.uint32(16).int32(message.invoiceNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvoiceByNumberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvoiceByNumberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoiceNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvoiceByNumberRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceNumber: isSet(object.invoiceNumber) ? globalThis.Number(object.invoiceNumber) : 0,
    };
  },

  toJSON(message: GetInvoiceByNumberRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceNumber !== 0) {
      obj.invoiceNumber = Math.round(message.invoiceNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvoiceByNumberRequest>, I>>(base?: I): GetInvoiceByNumberRequest {
    return GetInvoiceByNumberRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvoiceByNumberRequest>, I>>(object: I): GetInvoiceByNumberRequest {
    const message = createBaseGetInvoiceByNumberRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceNumber = object.invoiceNumber ?? 0;
    return message;
  },
};

function createBaseGetUserInvoicesRequest(): GetUserInvoicesRequest {
  return { context: undefined, userId: undefined };
}

export const GetUserInvoicesRequest: MessageFns<GetUserInvoicesRequest> = {
  encode(message: GetUserInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.userId !== undefined) {
      ObjectId.encode(message.userId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      userId: isSet(object.userId) ? ObjectId.fromJSON(object.userId) : undefined,
    };
  },

  toJSON(message: GetUserInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.userId !== undefined) {
      obj.userId = ObjectId.toJSON(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInvoicesRequest>, I>>(base?: I): GetUserInvoicesRequest {
    return GetUserInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInvoicesRequest>, I>>(object: I): GetUserInvoicesRequest {
    const message = createBaseGetUserInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.userId = (object.userId !== undefined && object.userId !== null)
      ? ObjectId.fromPartial(object.userId)
      : undefined;
    return message;
  },
};

function createBaseGetUserInvoicesResponse(): GetUserInvoicesResponse {
  return { invoices: [] };
}

export const GetUserInvoicesResponse: MessageFns<GetUserInvoicesResponse> = {
  encode(message: GetUserInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInvoicesResponse>, I>>(base?: I): GetUserInvoicesResponse {
    return GetUserInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInvoicesResponse>, I>>(object: I): GetUserInvoicesResponse {
    const message = createBaseGetUserInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetFamilyInvoicesRequest(): GetFamilyInvoicesRequest {
  return { context: undefined, familyId: undefined };
}

export const GetFamilyInvoicesRequest: MessageFns<GetFamilyInvoicesRequest> = {
  encode(message: GetFamilyInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.familyId !== undefined) {
      ObjectId.encode(message.familyId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFamilyInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFamilyInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.familyId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFamilyInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      familyId: isSet(object.familyId) ? ObjectId.fromJSON(object.familyId) : undefined,
    };
  },

  toJSON(message: GetFamilyInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.familyId !== undefined) {
      obj.familyId = ObjectId.toJSON(message.familyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFamilyInvoicesRequest>, I>>(base?: I): GetFamilyInvoicesRequest {
    return GetFamilyInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFamilyInvoicesRequest>, I>>(object: I): GetFamilyInvoicesRequest {
    const message = createBaseGetFamilyInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.familyId = (object.familyId !== undefined && object.familyId !== null)
      ? ObjectId.fromPartial(object.familyId)
      : undefined;
    return message;
  },
};

function createBaseGetParentInvoicesRequest(): GetParentInvoicesRequest {
  return { context: undefined, parentId: undefined };
}

export const GetParentInvoicesRequest: MessageFns<GetParentInvoicesRequest> = {
  encode(message: GetParentInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.parentId !== undefined) {
      ObjectId.encode(message.parentId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParentInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParentInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parentId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParentInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      parentId: isSet(object.parentId) ? ObjectId.fromJSON(object.parentId) : undefined,
    };
  },

  toJSON(message: GetParentInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.parentId !== undefined) {
      obj.parentId = ObjectId.toJSON(message.parentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetParentInvoicesRequest>, I>>(base?: I): GetParentInvoicesRequest {
    return GetParentInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetParentInvoicesRequest>, I>>(object: I): GetParentInvoicesRequest {
    const message = createBaseGetParentInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.parentId = (object.parentId !== undefined && object.parentId !== null)
      ? ObjectId.fromPartial(object.parentId)
      : undefined;
    return message;
  },
};

function createBaseGetActionsRequiredByParentsRequest(): GetActionsRequiredByParentsRequest {
  return { context: undefined, studentId: undefined };
}

export const GetActionsRequiredByParentsRequest: MessageFns<GetActionsRequiredByParentsRequest> = {
  encode(message: GetActionsRequiredByParentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActionsRequiredByParentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequiredByParentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActionsRequiredByParentsRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
    };
  },

  toJSON(message: GetActionsRequiredByParentsRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActionsRequiredByParentsRequest>, I>>(
    base?: I,
  ): GetActionsRequiredByParentsRequest {
    return GetActionsRequiredByParentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActionsRequiredByParentsRequest>, I>>(
    object: I,
  ): GetActionsRequiredByParentsRequest {
    const message = createBaseGetActionsRequiredByParentsRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    return message;
  },
};

function createBaseGetActionsRequiredByParentsResponse(): GetActionsRequiredByParentsResponse {
  return { actions: [] };
}

export const GetActionsRequiredByParentsResponse: MessageFns<GetActionsRequiredByParentsResponse> = {
  encode(message: GetActionsRequiredByParentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      ActionRequiredByParents.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActionsRequiredByParentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActionsRequiredByParentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(ActionRequiredByParents.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActionsRequiredByParentsResponse {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => ActionRequiredByParents.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetActionsRequiredByParentsResponse): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => ActionRequiredByParents.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActionsRequiredByParentsResponse>, I>>(
    base?: I,
  ): GetActionsRequiredByParentsResponse {
    return GetActionsRequiredByParentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActionsRequiredByParentsResponse>, I>>(
    object: I,
  ): GetActionsRequiredByParentsResponse {
    const message = createBaseGetActionsRequiredByParentsResponse();
    message.actions = object.actions?.map((e) => ActionRequiredByParents.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStudentHasNoUnpaidInvoicesRequest(): StudentHasNoUnpaidInvoicesRequest {
  return { context: undefined, studentId: undefined };
}

export const StudentHasNoUnpaidInvoicesRequest: MessageFns<StudentHasNoUnpaidInvoicesRequest> = {
  encode(message: StudentHasNoUnpaidInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentHasNoUnpaidInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentHasNoUnpaidInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentHasNoUnpaidInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
    };
  },

  toJSON(message: StudentHasNoUnpaidInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesRequest>, I>>(
    base?: I,
  ): StudentHasNoUnpaidInvoicesRequest {
    return StudentHasNoUnpaidInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesRequest>, I>>(
    object: I,
  ): StudentHasNoUnpaidInvoicesRequest {
    const message = createBaseStudentHasNoUnpaidInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    return message;
  },
};

function createBaseStudentHasNoUnpaidInvoicesResponse(): StudentHasNoUnpaidInvoicesResponse {
  return { hasNoUnpaidInvoices: false };
}

export const StudentHasNoUnpaidInvoicesResponse: MessageFns<StudentHasNoUnpaidInvoicesResponse> = {
  encode(message: StudentHasNoUnpaidInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasNoUnpaidInvoices !== false) {
      writer.uint32(8).bool(message.hasNoUnpaidInvoices);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StudentHasNoUnpaidInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStudentHasNoUnpaidInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hasNoUnpaidInvoices = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StudentHasNoUnpaidInvoicesResponse {
    return {
      hasNoUnpaidInvoices: isSet(object.hasNoUnpaidInvoices) ? globalThis.Boolean(object.hasNoUnpaidInvoices) : false,
    };
  },

  toJSON(message: StudentHasNoUnpaidInvoicesResponse): unknown {
    const obj: any = {};
    if (message.hasNoUnpaidInvoices !== false) {
      obj.hasNoUnpaidInvoices = message.hasNoUnpaidInvoices;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesResponse>, I>>(
    base?: I,
  ): StudentHasNoUnpaidInvoicesResponse {
    return StudentHasNoUnpaidInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StudentHasNoUnpaidInvoicesResponse>, I>>(
    object: I,
  ): StudentHasNoUnpaidInvoicesResponse {
    const message = createBaseStudentHasNoUnpaidInvoicesResponse();
    message.hasNoUnpaidInvoices = object.hasNoUnpaidInvoices ?? false;
    return message;
  },
};

function createBaseListInvoicesRequest(): ListInvoicesRequest {
  return { context: undefined, filter: undefined };
}

export const ListInvoicesRequest: MessageFns<ListInvoicesRequest> = {
  encode(message: ListInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.filter !== undefined) {
      InvoiceFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = InvoiceFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      filter: isSet(object.filter) ? InvoiceFilter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: ListInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.filter !== undefined) {
      obj.filter = InvoiceFilter.toJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInvoicesRequest>, I>>(base?: I): ListInvoicesRequest {
    return ListInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInvoicesRequest>, I>>(object: I): ListInvoicesRequest {
    const message = createBaseListInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? InvoiceFilter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseAggregationResponse(): AggregationResponse {
  return { invoices: [], invoicesCount: 0 };
}

export const AggregationResponse: MessageFns<AggregationResponse> = {
  encode(message: AggregationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      Invoice.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.invoicesCount !== 0) {
      writer.uint32(16).int32(message.invoicesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(Invoice.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoicesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices) ? object.invoices.map((e: any) => Invoice.fromJSON(e)) : [],
      invoicesCount: isSet(object.invoicesCount) ? globalThis.Number(object.invoicesCount) : 0,
    };
  },

  toJSON(message: AggregationResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => Invoice.toJSON(e));
    }
    if (message.invoicesCount !== 0) {
      obj.invoicesCount = Math.round(message.invoicesCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AggregationResponse>, I>>(base?: I): AggregationResponse {
    return AggregationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AggregationResponse>, I>>(object: I): AggregationResponse {
    const message = createBaseAggregationResponse();
    message.invoices = object.invoices?.map((e) => Invoice.fromPartial(e)) || [];
    message.invoicesCount = object.invoicesCount ?? 0;
    return message;
  },
};

function createBasePaginatedListInvoicesResponse(): PaginatedListInvoicesResponse {
  return { invoices: [], invoicesCount: 0 };
}

export const PaginatedListInvoicesResponse: MessageFns<PaginatedListInvoicesResponse> = {
  encode(message: PaginatedListInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.invoicesCount !== 0) {
      writer.uint32(16).int32(message.invoicesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginatedListInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginatedListInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invoicesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginatedListInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
      invoicesCount: isSet(object.invoicesCount) ? globalThis.Number(object.invoicesCount) : 0,
    };
  },

  toJSON(message: PaginatedListInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    if (message.invoicesCount !== 0) {
      obj.invoicesCount = Math.round(message.invoicesCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginatedListInvoicesResponse>, I>>(base?: I): PaginatedListInvoicesResponse {
    return PaginatedListInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginatedListInvoicesResponse>, I>>(
    object: I,
  ): PaginatedListInvoicesResponse {
    const message = createBasePaginatedListInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    message.invoicesCount = object.invoicesCount ?? 0;
    return message;
  },
};

function createBaseListInvoicesResponse(): ListInvoicesResponse {
  return { invoices: [] };
}

export const ListInvoicesResponse: MessageFns<ListInvoicesResponse> = {
  encode(message: ListInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInvoicesResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListInvoicesResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListInvoicesResponse>, I>>(base?: I): ListInvoicesResponse {
    return ListInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListInvoicesResponse>, I>>(object: I): ListInvoicesResponse {
    const message = createBaseListInvoicesResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIsInvoicePaidRequest(): IsInvoicePaidRequest {
  return { context: undefined, invoiceId: undefined };
}

export const IsInvoicePaidRequest: MessageFns<IsInvoicePaidRequest> = {
  encode(message: IsInvoicePaidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsInvoicePaidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsInvoicePaidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsInvoicePaidRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
    };
  },

  toJSON(message: IsInvoicePaidRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsInvoicePaidRequest>, I>>(base?: I): IsInvoicePaidRequest {
    return IsInvoicePaidRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsInvoicePaidRequest>, I>>(object: I): IsInvoicePaidRequest {
    const message = createBaseIsInvoicePaidRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    return message;
  },
};

function createBaseIsInvoicePaidResponse(): IsInvoicePaidResponse {
  return { isPaid: false };
}

export const IsInvoicePaidResponse: MessageFns<IsInvoicePaidResponse> = {
  encode(message: IsInvoicePaidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isPaid !== false) {
      writer.uint32(8).bool(message.isPaid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsInvoicePaidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsInvoicePaidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isPaid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsInvoicePaidResponse {
    return { isPaid: isSet(object.isPaid) ? globalThis.Boolean(object.isPaid) : false };
  },

  toJSON(message: IsInvoicePaidResponse): unknown {
    const obj: any = {};
    if (message.isPaid !== false) {
      obj.isPaid = message.isPaid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsInvoicePaidResponse>, I>>(base?: I): IsInvoicePaidResponse {
    return IsInvoicePaidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsInvoicePaidResponse>, I>>(object: I): IsInvoicePaidResponse {
    const message = createBaseIsInvoicePaidResponse();
    message.isPaid = object.isPaid ?? false;
    return message;
  },
};

function createBaseCreateInvoiceRequest(): CreateInvoiceRequest {
  return {
    context: undefined,
    title: "",
    description: "",
    showHst: false,
    disableTax: false,
    user: undefined,
    family: undefined,
    items: [],
    coupons: [],
    dueDate: undefined,
    schoolYear: undefined,
    autoPayEnabled: false,
    chargeOnDate: undefined,
    autoPaymentStatus: AutoPaymentStatus.AutoPayPending,
    isTuition: false,
  };
}

export const CreateInvoiceRequest: MessageFns<CreateInvoiceRequest> = {
  encode(message: CreateInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.showHst !== false) {
      writer.uint32(32).bool(message.showHst);
    }
    if (message.disableTax !== false) {
      writer.uint32(40).bool(message.disableTax);
    }
    if (message.user !== undefined) {
      ObjectId.encode(message.user, writer.uint32(50).fork()).join();
    }
    if (message.family !== undefined) {
      ObjectId.encode(message.family, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.dueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.dueDate), writer.uint32(82).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(90).fork()).join();
    }
    if (message.autoPayEnabled !== undefined && message.autoPayEnabled !== false) {
      writer.uint32(96).bool(message.autoPayEnabled);
    }
    if (message.chargeOnDate !== undefined) {
      Timestamp.encode(toTimestamp(message.chargeOnDate), writer.uint32(106).fork()).join();
    }
    if (message.autoPaymentStatus !== undefined && message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(112).int32(autoPaymentStatusToNumber(message.autoPaymentStatus));
    }
    if (message.isTuition !== undefined && message.isTuition !== false) {
      writer.uint32(120).bool(message.isTuition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showHst = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disableTax = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.user = ObjectId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.family = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.autoPayEnabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.chargeOnDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.autoPaymentStatus = autoPaymentStatusFromJSON(reader.int32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isTuition = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      showHst: isSet(object.showHst) ? globalThis.Boolean(object.showHst) : false,
      disableTax: isSet(object.disableTax) ? globalThis.Boolean(object.disableTax) : false,
      user: isSet(object.user) ? ObjectId.fromJSON(object.user) : undefined,
      family: isSet(object.family) ? ObjectId.fromJSON(object.family) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      dueDate: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
      autoPayEnabled: isSet(object.autoPayEnabled) ? globalThis.Boolean(object.autoPayEnabled) : false,
      chargeOnDate: isSet(object.chargeOnDate) ? fromJsonTimestamp(object.chargeOnDate) : undefined,
      autoPaymentStatus: isSet(object.autoPaymentStatus)
        ? autoPaymentStatusFromJSON(object.autoPaymentStatus)
        : AutoPaymentStatus.AutoPayPending,
      isTuition: isSet(object.isTuition) ? globalThis.Boolean(object.isTuition) : false,
    };
  },

  toJSON(message: CreateInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.showHst !== false) {
      obj.showHst = message.showHst;
    }
    if (message.disableTax !== false) {
      obj.disableTax = message.disableTax;
    }
    if (message.user !== undefined) {
      obj.user = ObjectId.toJSON(message.user);
    }
    if (message.family !== undefined) {
      obj.family = ObjectId.toJSON(message.family);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate.toISOString();
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    if (message.autoPayEnabled !== undefined && message.autoPayEnabled !== false) {
      obj.autoPayEnabled = message.autoPayEnabled;
    }
    if (message.chargeOnDate !== undefined) {
      obj.chargeOnDate = message.chargeOnDate.toISOString();
    }
    if (message.autoPaymentStatus !== undefined && message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      obj.autoPaymentStatus = autoPaymentStatusToJSON(message.autoPaymentStatus);
    }
    if (message.isTuition !== undefined && message.isTuition !== false) {
      obj.isTuition = message.isTuition;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(base?: I): CreateInvoiceRequest {
    return CreateInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceRequest>, I>>(object: I): CreateInvoiceRequest {
    const message = createBaseCreateInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.showHst = object.showHst ?? false;
    message.disableTax = object.disableTax ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? ObjectId.fromPartial(object.user) : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? ObjectId.fromPartial(object.family)
      : undefined;
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.dueDate = object.dueDate ?? undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    message.autoPayEnabled = object.autoPayEnabled ?? false;
    message.chargeOnDate = object.chargeOnDate ?? undefined;
    message.autoPaymentStatus = object.autoPaymentStatus ?? AutoPaymentStatus.AutoPayPending;
    message.isTuition = object.isTuition ?? false;
    return message;
  },
};

function createBaseCreateInvoiceForClassRequest(): CreateInvoiceForClassRequest {
  return {
    context: undefined,
    title: "",
    description: "",
    showHst: false,
    disableTax: false,
    homeroom: undefined,
    course: undefined,
    items: [],
    coupons: [],
    dueDate: undefined,
    schoolYear: undefined,
    autoPayEnabled: false,
    chargeOnDate: undefined,
    autoPaymentStatus: AutoPaymentStatus.AutoPayPending,
  };
}

export const CreateInvoiceForClassRequest: MessageFns<CreateInvoiceForClassRequest> = {
  encode(message: CreateInvoiceForClassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.showHst !== false) {
      writer.uint32(32).bool(message.showHst);
    }
    if (message.disableTax !== false) {
      writer.uint32(40).bool(message.disableTax);
    }
    if (message.homeroom !== undefined) {
      ObjectId.encode(message.homeroom, writer.uint32(50).fork()).join();
    }
    if (message.course !== undefined) {
      ObjectId.encode(message.course, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.dueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.dueDate), writer.uint32(82).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(90).fork()).join();
    }
    if (message.autoPayEnabled !== undefined && message.autoPayEnabled !== false) {
      writer.uint32(96).bool(message.autoPayEnabled);
    }
    if (message.chargeOnDate !== undefined) {
      Timestamp.encode(toTimestamp(message.chargeOnDate), writer.uint32(106).fork()).join();
    }
    if (message.autoPaymentStatus !== undefined && message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(112).int32(autoPaymentStatusToNumber(message.autoPaymentStatus));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceForClassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceForClassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showHst = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disableTax = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.homeroom = ObjectId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.course = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.autoPayEnabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.chargeOnDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.autoPaymentStatus = autoPaymentStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceForClassRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      showHst: isSet(object.showHst) ? globalThis.Boolean(object.showHst) : false,
      disableTax: isSet(object.disableTax) ? globalThis.Boolean(object.disableTax) : false,
      homeroom: isSet(object.homeroom) ? ObjectId.fromJSON(object.homeroom) : undefined,
      course: isSet(object.course) ? ObjectId.fromJSON(object.course) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      dueDate: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
      autoPayEnabled: isSet(object.autoPayEnabled) ? globalThis.Boolean(object.autoPayEnabled) : false,
      chargeOnDate: isSet(object.chargeOnDate) ? fromJsonTimestamp(object.chargeOnDate) : undefined,
      autoPaymentStatus: isSet(object.autoPaymentStatus)
        ? autoPaymentStatusFromJSON(object.autoPaymentStatus)
        : AutoPaymentStatus.AutoPayPending,
    };
  },

  toJSON(message: CreateInvoiceForClassRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.showHst !== false) {
      obj.showHst = message.showHst;
    }
    if (message.disableTax !== false) {
      obj.disableTax = message.disableTax;
    }
    if (message.homeroom !== undefined) {
      obj.homeroom = ObjectId.toJSON(message.homeroom);
    }
    if (message.course !== undefined) {
      obj.course = ObjectId.toJSON(message.course);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate.toISOString();
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    if (message.autoPayEnabled !== undefined && message.autoPayEnabled !== false) {
      obj.autoPayEnabled = message.autoPayEnabled;
    }
    if (message.chargeOnDate !== undefined) {
      obj.chargeOnDate = message.chargeOnDate.toISOString();
    }
    if (message.autoPaymentStatus !== undefined && message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      obj.autoPaymentStatus = autoPaymentStatusToJSON(message.autoPaymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceForClassRequest>, I>>(base?: I): CreateInvoiceForClassRequest {
    return CreateInvoiceForClassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceForClassRequest>, I>>(object: I): CreateInvoiceForClassRequest {
    const message = createBaseCreateInvoiceForClassRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.showHst = object.showHst ?? false;
    message.disableTax = object.disableTax ?? false;
    message.homeroom = (object.homeroom !== undefined && object.homeroom !== null)
      ? ObjectId.fromPartial(object.homeroom)
      : undefined;
    message.course = (object.course !== undefined && object.course !== null)
      ? ObjectId.fromPartial(object.course)
      : undefined;
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.dueDate = object.dueDate ?? undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    message.autoPayEnabled = object.autoPayEnabled ?? false;
    message.chargeOnDate = object.chargeOnDate ?? undefined;
    message.autoPaymentStatus = object.autoPaymentStatus ?? AutoPaymentStatus.AutoPayPending;
    return message;
  },
};

function createBaseGenerateInterviewFeeInvoiceRequest(): GenerateInterviewFeeInvoiceRequest {
  return { context: undefined, studentId: undefined };
}

export const GenerateInterviewFeeInvoiceRequest: MessageFns<GenerateInterviewFeeInvoiceRequest> = {
  encode(message: GenerateInterviewFeeInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateInterviewFeeInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateInterviewFeeInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateInterviewFeeInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
    };
  },

  toJSON(message: GenerateInterviewFeeInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateInterviewFeeInvoiceRequest>, I>>(
    base?: I,
  ): GenerateInterviewFeeInvoiceRequest {
    return GenerateInterviewFeeInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateInterviewFeeInvoiceRequest>, I>>(
    object: I,
  ): GenerateInterviewFeeInvoiceRequest {
    const message = createBaseGenerateInterviewFeeInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    return message;
  },
};

function createBaseGenerateWaitlistFeeInvoiceRequest(): GenerateWaitlistFeeInvoiceRequest {
  return { context: undefined, studentId: undefined };
}

export const GenerateWaitlistFeeInvoiceRequest: MessageFns<GenerateWaitlistFeeInvoiceRequest> = {
  encode(message: GenerateWaitlistFeeInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateWaitlistFeeInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateWaitlistFeeInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateWaitlistFeeInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
    };
  },

  toJSON(message: GenerateWaitlistFeeInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateWaitlistFeeInvoiceRequest>, I>>(
    base?: I,
  ): GenerateWaitlistFeeInvoiceRequest {
    return GenerateWaitlistFeeInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateWaitlistFeeInvoiceRequest>, I>>(
    object: I,
  ): GenerateWaitlistFeeInvoiceRequest {
    const message = createBaseGenerateWaitlistFeeInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    return message;
  },
};

function createBaseGenerateRegistrationFeesInvoiceRequest(): GenerateRegistrationFeesInvoiceRequest {
  return { context: undefined, studentId: undefined, schoolYear: undefined };
}

export const GenerateRegistrationFeesInvoiceRequest: MessageFns<GenerateRegistrationFeesInvoiceRequest> = {
  encode(message: GenerateRegistrationFeesInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.studentId !== undefined) {
      ObjectId.encode(message.studentId, writer.uint32(18).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateRegistrationFeesInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateRegistrationFeesInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.studentId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateRegistrationFeesInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentId: isSet(object.studentId) ? ObjectId.fromJSON(object.studentId) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
    };
  },

  toJSON(message: GenerateRegistrationFeesInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentId !== undefined) {
      obj.studentId = ObjectId.toJSON(message.studentId);
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateRegistrationFeesInvoiceRequest>, I>>(
    base?: I,
  ): GenerateRegistrationFeesInvoiceRequest {
    return GenerateRegistrationFeesInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateRegistrationFeesInvoiceRequest>, I>>(
    object: I,
  ): GenerateRegistrationFeesInvoiceRequest {
    const message = createBaseGenerateRegistrationFeesInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentId = (object.studentId !== undefined && object.studentId !== null)
      ? ObjectId.fromPartial(object.studentId)
      : undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    return message;
  },
};

function createBaseCreateInvoiceForClassResponse(): CreateInvoiceForClassResponse {
  return { invoices: [] };
}

export const CreateInvoiceForClassResponse: MessageFns<CreateInvoiceForClassResponse> = {
  encode(message: CreateInvoiceForClassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invoices) {
      InvoiceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvoiceForClassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvoiceForClassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoices.push(InvoiceResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvoiceForClassResponse {
    return {
      invoices: globalThis.Array.isArray(object?.invoices)
        ? object.invoices.map((e: any) => InvoiceResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateInvoiceForClassResponse): unknown {
    const obj: any = {};
    if (message.invoices?.length) {
      obj.invoices = message.invoices.map((e) => InvoiceResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvoiceForClassResponse>, I>>(base?: I): CreateInvoiceForClassResponse {
    return CreateInvoiceForClassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvoiceForClassResponse>, I>>(
    object: I,
  ): CreateInvoiceForClassResponse {
    const message = createBaseCreateInvoiceForClassResponse();
    message.invoices = object.invoices?.map((e) => InvoiceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateInvoiceRequest(): UpdateInvoiceRequest {
  return {
    context: undefined,
    id: undefined,
    title: "",
    description: "",
    showHst: false,
    disableTax: false,
    items: [],
    coupons: [],
    dueDate: undefined,
  };
}

export const UpdateInvoiceRequest: MessageFns<UpdateInvoiceRequest> = {
  encode(message: UpdateInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.showHst !== false) {
      writer.uint32(40).bool(message.showHst);
    }
    if (message.disableTax !== false) {
      writer.uint32(48).bool(message.disableTax);
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.dueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.dueDate), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.showHst = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.disableTax = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      showHst: isSet(object.showHst) ? globalThis.Boolean(object.showHst) : false,
      disableTax: isSet(object.disableTax) ? globalThis.Boolean(object.disableTax) : false,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      dueDate: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
    };
  },

  toJSON(message: UpdateInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.showHst !== false) {
      obj.showHst = message.showHst;
    }
    if (message.disableTax !== false) {
      obj.disableTax = message.disableTax;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInvoiceRequest>, I>>(base?: I): UpdateInvoiceRequest {
    return UpdateInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInvoiceRequest>, I>>(object: I): UpdateInvoiceRequest {
    const message = createBaseUpdateInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.showHst = object.showHst ?? false;
    message.disableTax = object.disableTax ?? false;
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.dueDate = object.dueDate ?? undefined;
    return message;
  },
};

function createBaseUpdateInvoiceAutoPaymentRequest(): UpdateInvoiceAutoPaymentRequest {
  return { context: undefined, id: undefined, autoPayEnabled: false, chargeOnDate: undefined };
}

export const UpdateInvoiceAutoPaymentRequest: MessageFns<UpdateInvoiceAutoPaymentRequest> = {
  encode(message: UpdateInvoiceAutoPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.autoPayEnabled !== false) {
      writer.uint32(24).bool(message.autoPayEnabled);
    }
    if (message.chargeOnDate !== undefined) {
      Timestamp.encode(toTimestamp(message.chargeOnDate), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInvoiceAutoPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInvoiceAutoPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.autoPayEnabled = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chargeOnDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInvoiceAutoPaymentRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      autoPayEnabled: isSet(object.autoPayEnabled) ? globalThis.Boolean(object.autoPayEnabled) : false,
      chargeOnDate: isSet(object.chargeOnDate) ? fromJsonTimestamp(object.chargeOnDate) : undefined,
    };
  },

  toJSON(message: UpdateInvoiceAutoPaymentRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.autoPayEnabled !== false) {
      obj.autoPayEnabled = message.autoPayEnabled;
    }
    if (message.chargeOnDate !== undefined) {
      obj.chargeOnDate = message.chargeOnDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInvoiceAutoPaymentRequest>, I>>(base?: I): UpdateInvoiceAutoPaymentRequest {
    return UpdateInvoiceAutoPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInvoiceAutoPaymentRequest>, I>>(
    object: I,
  ): UpdateInvoiceAutoPaymentRequest {
    const message = createBaseUpdateInvoiceAutoPaymentRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.autoPayEnabled = object.autoPayEnabled ?? false;
    message.chargeOnDate = object.chargeOnDate ?? undefined;
    return message;
  },
};

function createBaseArchiveInvoiceRequest(): ArchiveInvoiceRequest {
  return { context: undefined, invoiceId: undefined };
}

export const ArchiveInvoiceRequest: MessageFns<ArchiveInvoiceRequest> = {
  encode(message: ArchiveInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArchiveInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArchiveInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
    };
  },

  toJSON(message: ArchiveInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ArchiveInvoiceRequest>, I>>(base?: I): ArchiveInvoiceRequest {
    return ArchiveInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ArchiveInvoiceRequest>, I>>(object: I): ArchiveInvoiceRequest {
    const message = createBaseArchiveInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    return message;
  },
};

function createBaseUnarchiveInvoiceRequest(): UnarchiveInvoiceRequest {
  return { context: undefined, invoiceId: undefined };
}

export const UnarchiveInvoiceRequest: MessageFns<UnarchiveInvoiceRequest> = {
  encode(message: UnarchiveInvoiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnarchiveInvoiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnarchiveInvoiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnarchiveInvoiceRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
    };
  },

  toJSON(message: UnarchiveInvoiceRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnarchiveInvoiceRequest>, I>>(base?: I): UnarchiveInvoiceRequest {
    return UnarchiveInvoiceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnarchiveInvoiceRequest>, I>>(object: I): UnarchiveInvoiceRequest {
    const message = createBaseUnarchiveInvoiceRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    return message;
  },
};

function createBaseGetAutoPayInvoicesReadyToChargeRequest(): GetAutoPayInvoicesReadyToChargeRequest {
  return { context: undefined };
}

export const GetAutoPayInvoicesReadyToChargeRequest: MessageFns<GetAutoPayInvoicesReadyToChargeRequest> = {
  encode(message: GetAutoPayInvoicesReadyToChargeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutoPayInvoicesReadyToChargeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoPayInvoicesReadyToChargeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoPayInvoicesReadyToChargeRequest {
    return { context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined };
  },

  toJSON(message: GetAutoPayInvoicesReadyToChargeRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAutoPayInvoicesReadyToChargeRequest>, I>>(
    base?: I,
  ): GetAutoPayInvoicesReadyToChargeRequest {
    return GetAutoPayInvoicesReadyToChargeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAutoPayInvoicesReadyToChargeRequest>, I>>(
    object: I,
  ): GetAutoPayInvoicesReadyToChargeRequest {
    const message = createBaseGetAutoPayInvoicesReadyToChargeRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseSetAutoPayInvoiceStatusRequest(): SetAutoPayInvoiceStatusRequest {
  return { context: undefined, invoiceId: undefined, autoPaymentStatus: AutoPaymentStatus.AutoPayPending };
}

export const SetAutoPayInvoiceStatusRequest: MessageFns<SetAutoPayInvoiceStatusRequest> = {
  encode(message: SetAutoPayInvoiceStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.invoiceId !== undefined) {
      ObjectId.encode(message.invoiceId, writer.uint32(18).fork()).join();
    }
    if (message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(24).int32(autoPaymentStatusToNumber(message.autoPaymentStatus));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAutoPayInvoiceStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAutoPayInvoiceStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.invoiceId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.autoPaymentStatus = autoPaymentStatusFromJSON(reader.int32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAutoPayInvoiceStatusRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      invoiceId: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      autoPaymentStatus: isSet(object.autoPaymentStatus)
        ? autoPaymentStatusFromJSON(object.autoPaymentStatus)
        : AutoPaymentStatus.AutoPayPending,
    };
  },

  toJSON(message: SetAutoPayInvoiceStatusRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.invoiceId !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoiceId);
    }
    if (message.autoPaymentStatus !== AutoPaymentStatus.AutoPayPending) {
      obj.autoPaymentStatus = autoPaymentStatusToJSON(message.autoPaymentStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAutoPayInvoiceStatusRequest>, I>>(base?: I): SetAutoPayInvoiceStatusRequest {
    return SetAutoPayInvoiceStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAutoPayInvoiceStatusRequest>, I>>(
    object: I,
  ): SetAutoPayInvoiceStatusRequest {
    const message = createBaseSetAutoPayInvoiceStatusRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.invoiceId = (object.invoiceId !== undefined && object.invoiceId !== null)
      ? ObjectId.fromPartial(object.invoiceId)
      : undefined;
    message.autoPaymentStatus = object.autoPaymentStatus ?? AutoPaymentStatus.AutoPayPending;
    return message;
  },
};

function createBaseGetFamilyTuitionInvoicesRequest(): GetFamilyTuitionInvoicesRequest {
  return { context: undefined, familyId: undefined, schoolYear: undefined };
}

export const GetFamilyTuitionInvoicesRequest: MessageFns<GetFamilyTuitionInvoicesRequest> = {
  encode(message: GetFamilyTuitionInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.familyId !== undefined) {
      ObjectId.encode(message.familyId, writer.uint32(18).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFamilyTuitionInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFamilyTuitionInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.familyId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFamilyTuitionInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      familyId: isSet(object.familyId) ? ObjectId.fromJSON(object.familyId) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
    };
  },

  toJSON(message: GetFamilyTuitionInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.familyId !== undefined) {
      obj.familyId = ObjectId.toJSON(message.familyId);
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFamilyTuitionInvoicesRequest>, I>>(base?: I): GetFamilyTuitionInvoicesRequest {
    return GetFamilyTuitionInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFamilyTuitionInvoicesRequest>, I>>(
    object: I,
  ): GetFamilyTuitionInvoicesRequest {
    const message = createBaseGetFamilyTuitionInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.familyId = (object.familyId !== undefined && object.familyId !== null)
      ? ObjectId.fromPartial(object.familyId)
      : undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    return message;
  },
};

function createBaseGetStudentsWithUnpaidInvoicesRequest(): GetStudentsWithUnpaidInvoicesRequest {
  return { context: undefined, studentStatuses: [], schoolYear: undefined };
}

export const GetStudentsWithUnpaidInvoicesRequest: MessageFns<GetStudentsWithUnpaidInvoicesRequest> = {
  encode(message: GetStudentsWithUnpaidInvoicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    writer.uint32(18).fork();
    for (const v of message.studentStatuses) {
      writer.int32(studentStatusToNumber(v));
    }
    writer.join();
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithUnpaidInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithUnpaidInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag === 16) {
            message.studentStatuses.push(studentStatusFromJSON(reader.int32()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.studentStatuses.push(studentStatusFromJSON(reader.int32()));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithUnpaidInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      studentStatuses: globalThis.Array.isArray(object?.studentStatuses)
        ? object.studentStatuses.map((e: any) => studentStatusFromJSON(e))
        : [],
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
    };
  },

  toJSON(message: GetStudentsWithUnpaidInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.studentStatuses?.length) {
      obj.studentStatuses = message.studentStatuses.map((e) => studentStatusToJSON(e));
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesRequest>, I>>(
    base?: I,
  ): GetStudentsWithUnpaidInvoicesRequest {
    return GetStudentsWithUnpaidInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesRequest>, I>>(
    object: I,
  ): GetStudentsWithUnpaidInvoicesRequest {
    const message = createBaseGetStudentsWithUnpaidInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.studentStatuses = object.studentStatuses?.map((e) => e) || [];
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    return message;
  },
};

function createBaseGetStudentsWithUnpaidInvoicesResponse(): GetStudentsWithUnpaidInvoicesResponse {
  return { studentIds: [] };
}

export const GetStudentsWithUnpaidInvoicesResponse: MessageFns<GetStudentsWithUnpaidInvoicesResponse> = {
  encode(message: GetStudentsWithUnpaidInvoicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.studentIds) {
      ObjectId.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithUnpaidInvoicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithUnpaidInvoicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.studentIds.push(ObjectId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithUnpaidInvoicesResponse {
    return {
      studentIds: globalThis.Array.isArray(object?.studentIds)
        ? object.studentIds.map((e: any) => ObjectId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetStudentsWithUnpaidInvoicesResponse): unknown {
    const obj: any = {};
    if (message.studentIds?.length) {
      obj.studentIds = message.studentIds.map((e) => ObjectId.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesResponse>, I>>(
    base?: I,
  ): GetStudentsWithUnpaidInvoicesResponse {
    return GetStudentsWithUnpaidInvoicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithUnpaidInvoicesResponse>, I>>(
    object: I,
  ): GetStudentsWithUnpaidInvoicesResponse {
    const message = createBaseGetStudentsWithUnpaidInvoicesResponse();
    message.studentIds = object.studentIds?.map((e) => ObjectId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetStudentsWithReregistrationInvoicesRequest(): GetStudentsWithReregistrationInvoicesRequest {
  return { context: undefined, schoolYear: undefined };
}

export const GetStudentsWithReregistrationInvoicesRequest: MessageFns<GetStudentsWithReregistrationInvoicesRequest> = {
  encode(
    message: GetStudentsWithReregistrationInvoicesRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.context !== undefined) {
      RequestContext.encode(message.context, writer.uint32(10).fork()).join();
    }
    if (message.schoolYear !== undefined) {
      ObjectId.encode(message.schoolYear, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithReregistrationInvoicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStudentsWithReregistrationInvoicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.context = RequestContext.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schoolYear = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStudentsWithReregistrationInvoicesRequest {
    return {
      context: isSet(object.context) ? RequestContext.fromJSON(object.context) : undefined,
      schoolYear: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
    };
  },

  toJSON(message: GetStudentsWithReregistrationInvoicesRequest): unknown {
    const obj: any = {};
    if (message.context !== undefined) {
      obj.context = RequestContext.toJSON(message.context);
    }
    if (message.schoolYear !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.schoolYear);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesRequest>, I>>(
    base?: I,
  ): GetStudentsWithReregistrationInvoicesRequest {
    return GetStudentsWithReregistrationInvoicesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesRequest>, I>>(
    object: I,
  ): GetStudentsWithReregistrationInvoicesRequest {
    const message = createBaseGetStudentsWithReregistrationInvoicesRequest();
    message.context = (object.context !== undefined && object.context !== null)
      ? RequestContext.fromPartial(object.context)
      : undefined;
    message.schoolYear = (object.schoolYear !== undefined && object.schoolYear !== null)
      ? ObjectId.fromPartial(object.schoolYear)
      : undefined;
    return message;
  },
};

function createBaseGetStudentsWithReregistrationInvoicesResponse(): GetStudentsWithReregistrationInvoicesResponse {
  return { studentIds: [] };
}

export const GetStudentsWithReregistrationInvoicesResponse: MessageFns<GetStudentsWithReregistrationInvoicesResponse> =
  {
    encode(
      message: GetStudentsWithReregistrationInvoicesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.studentIds) {
        ObjectId.encode(v!, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetStudentsWithReregistrationInvoicesResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetStudentsWithReregistrationInvoicesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.studentIds.push(ObjectId.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetStudentsWithReregistrationInvoicesResponse {
      return {
        studentIds: globalThis.Array.isArray(object?.studentIds)
          ? object.studentIds.map((e: any) => ObjectId.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetStudentsWithReregistrationInvoicesResponse): unknown {
      const obj: any = {};
      if (message.studentIds?.length) {
        obj.studentIds = message.studentIds.map((e) => ObjectId.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesResponse>, I>>(
      base?: I,
    ): GetStudentsWithReregistrationInvoicesResponse {
      return GetStudentsWithReregistrationInvoicesResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetStudentsWithReregistrationInvoicesResponse>, I>>(
      object: I,
    ): GetStudentsWithReregistrationInvoicesResponse {
      const message = createBaseGetStudentsWithReregistrationInvoicesResponse();
      message.studentIds = object.studentIds?.map((e) => ObjectId.fromPartial(e)) || [];
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

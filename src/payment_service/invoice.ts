// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: payment_service/invoice.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../google/protobuf/timestamp";
import {
  StudentStatus,
  studentStatusFromJSON,
  studentStatusToJSON,
  studentStatusToNumber,
} from "../user_service/student";
import { ObjectId } from "../utils/object_id";
import { RefundTransaction, Transaction } from "./transaction";
import {
  DiscountValueType,
  discountValueTypeFromJSON,
  discountValueTypeToJSON,
  discountValueTypeToNumber,
} from "./tuition";

export const protobufPackage = "payment_service";

export enum InvoiceStatus {
  Paid = "Paid",
  NotPaid = "NotPaid",
  Overdue = "Overdue",
  Refunded = "Refunded",
  Processing = "Processing",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function invoiceStatusFromJSON(object: any): InvoiceStatus {
  switch (object) {
    case 1:
    case "Paid":
      return InvoiceStatus.Paid;
    case 2:
    case "NotPaid":
      return InvoiceStatus.NotPaid;
    case 3:
    case "Overdue":
      return InvoiceStatus.Overdue;
    case 4:
    case "Refunded":
      return InvoiceStatus.Refunded;
    case 5:
    case "Processing":
      return InvoiceStatus.Processing;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvoiceStatus.UNRECOGNIZED;
  }
}

export function invoiceStatusToJSON(object: InvoiceStatus): string {
  switch (object) {
    case InvoiceStatus.Paid:
      return "Paid";
    case InvoiceStatus.NotPaid:
      return "NotPaid";
    case InvoiceStatus.Overdue:
      return "Overdue";
    case InvoiceStatus.Refunded:
      return "Refunded";
    case InvoiceStatus.Processing:
      return "Processing";
    case InvoiceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function invoiceStatusToNumber(object: InvoiceStatus): number {
  switch (object) {
    case InvoiceStatus.Paid:
      return 1;
    case InvoiceStatus.NotPaid:
      return 2;
    case InvoiceStatus.Overdue:
      return 3;
    case InvoiceStatus.Refunded:
      return 4;
    case InvoiceStatus.Processing:
      return 5;
    case InvoiceStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum AutoPaymentStatus {
  /** AutoPayPending - Pending to be paid, not yet queued */
  AutoPayPending = "AutoPayPending",
  /** AutoPayQueued - Queued to be charged by the payment consumer */
  AutoPayQueued = "AutoPayQueued",
  /** AutoPayQueueFailed - Failed to queue */
  AutoPayQueueFailed = "AutoPayQueueFailed",
  /** AutoPayProcessing - The auto payment is processing */
  AutoPayProcessing = "AutoPayProcessing",
  /** AutoPaySucceeded - The auto payment succeeded */
  AutoPaySucceeded = "AutoPaySucceeded",
  /** AutoPayFailed - The auto payment failed (will be retried) */
  AutoPayFailed = "AutoPayFailed",
  /** AutoPayPermanentlyFailed - All retries exhausted, permanently failed */
  AutoPayPermanentlyFailed = "AutoPayPermanentlyFailed",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function autoPaymentStatusFromJSON(object: any): AutoPaymentStatus {
  switch (object) {
    case 1:
    case "AutoPayPending":
      return AutoPaymentStatus.AutoPayPending;
    case 2:
    case "AutoPayQueued":
      return AutoPaymentStatus.AutoPayQueued;
    case 3:
    case "AutoPayQueueFailed":
      return AutoPaymentStatus.AutoPayQueueFailed;
    case 4:
    case "AutoPayProcessing":
      return AutoPaymentStatus.AutoPayProcessing;
    case 5:
    case "AutoPaySucceeded":
      return AutoPaymentStatus.AutoPaySucceeded;
    case 6:
    case "AutoPayFailed":
      return AutoPaymentStatus.AutoPayFailed;
    case 7:
    case "AutoPayPermanentlyFailed":
      return AutoPaymentStatus.AutoPayPermanentlyFailed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutoPaymentStatus.UNRECOGNIZED;
  }
}

export function autoPaymentStatusToJSON(object: AutoPaymentStatus): string {
  switch (object) {
    case AutoPaymentStatus.AutoPayPending:
      return "AutoPayPending";
    case AutoPaymentStatus.AutoPayQueued:
      return "AutoPayQueued";
    case AutoPaymentStatus.AutoPayQueueFailed:
      return "AutoPayQueueFailed";
    case AutoPaymentStatus.AutoPayProcessing:
      return "AutoPayProcessing";
    case AutoPaymentStatus.AutoPaySucceeded:
      return "AutoPaySucceeded";
    case AutoPaymentStatus.AutoPayFailed:
      return "AutoPayFailed";
    case AutoPaymentStatus.AutoPayPermanentlyFailed:
      return "AutoPayPermanentlyFailed";
    case AutoPaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function autoPaymentStatusToNumber(object: AutoPaymentStatus): number {
  switch (object) {
    case AutoPaymentStatus.AutoPayPending:
      return 1;
    case AutoPaymentStatus.AutoPayQueued:
      return 2;
    case AutoPaymentStatus.AutoPayQueueFailed:
      return 3;
    case AutoPaymentStatus.AutoPayProcessing:
      return 4;
    case AutoPaymentStatus.AutoPaySucceeded:
      return 5;
    case AutoPaymentStatus.AutoPayFailed:
      return 6;
    case AutoPaymentStatus.AutoPayPermanentlyFailed:
      return 7;
    case AutoPaymentStatus.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface InvoiceItem {
  title: string;
  description: string;
  price: number;
  quantity: number;
  is_bassem_labs_fee?: boolean | undefined;
}

export interface Coupon {
  title: string;
  value_type: DiscountValueType;
  /** percentage or amount value */
  value: number;
}

export interface OrganizationInvoiceDetails {
  period_start_date: Date | undefined;
  period_end_date: Date | undefined;
  number_of_students: number;
  payment_plan_id: ObjectId | undefined;
  payment_plan_info_id: ObjectId | undefined;
}

export interface Invoice {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  invoice_number: number;
  title: string;
  description: string;
  show_hst: boolean;
  disable_tax: boolean;
  archived: boolean;
  user?: ObjectId | undefined;
  family?: ObjectId | undefined;
  items: InvoiceItem[];
  coupons: Coupon[];
  due_date?: Date | undefined;
  invoice_student_registration_pipeline_status?: StudentStatus | undefined;
  school_year:
    | ObjectId
    | undefined;
  /**
   * Auto pay fields
   * If autopay is enabled for this invoice
   */
  auto_pay_enabled?:
    | boolean
    | undefined;
  /** Date when this invoice must be automatically charged one */
  charge_on_date?: Date | undefined;
  auto_payment_status?:
    | AutoPaymentStatus
    | undefined;
  /** determine if this invoice is a tuition invoice */
  is_tuition: boolean;
  /** Organization-specific invoice details */
  organization_invoice_details?:
    | OrganizationInvoiceDetails
    | undefined;
  /**
   * Auto payment retry fields
   * Number of payment retry attempts made
   */
  auto_payment_retry_count?:
    | number
    | undefined;
  /** Timestamp for the next scheduled retry attempt (used for scheduling job queries) */
  auto_payment_next_retry_at?: Date | undefined;
}

export interface InvoiceResponse {
  invoice: Invoice | undefined;
  transactions: Transaction[];
  /** Total amount of the invoice */
  total_amount: number;
  /** Total amount paid towards the invoice, excludes refunds, processing fees, (includes bassemlabs fees) */
  gross_amount_paid: number;
  status: InvoiceStatus;
  bill_to_name?: string | undefined;
  refund_transactions: RefundTransaction[];
  /** Total amount refunded */
  total_amount_refunded: number;
  /** total_amount_paid - total_amount_refunded */
  net_amount_paid: number;
}

export interface InvoiceFilter {
  per_page?: number | undefined;
  page?: number | undefined;
  title?: string | undefined;
  status?: InvoiceStatus | undefined;
  archived?: boolean | undefined;
  user?: ObjectId | undefined;
  family?: ObjectId | undefined;
  school_year?: ObjectId | undefined;
}

export interface AutoPaymentAttempt {
  id: ObjectId | undefined;
  organization: ObjectId | undefined;
  invoice_id: ObjectId | undefined;
  attempted_at: Date | undefined;
  status: AutoPaymentStatus;
  error_message?: string | undefined;
  attempt_number: number;
}

function createBaseInvoiceItem(): InvoiceItem {
  return { title: "", description: "", price: 0, quantity: 0, is_bassem_labs_fee: false };
}

export const InvoiceItem: MessageFns<InvoiceItem> = {
  encode(message: InvoiceItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.is_bassem_labs_fee !== undefined && message.is_bassem_labs_fee !== false) {
      writer.uint32(40).bool(message.is_bassem_labs_fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.is_bassem_labs_fee = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceItem {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      is_bassem_labs_fee: isSet(object.isBassemLabsFee) ? globalThis.Boolean(object.isBassemLabsFee) : false,
    };
  },

  toJSON(message: InvoiceItem): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.is_bassem_labs_fee !== undefined && message.is_bassem_labs_fee !== false) {
      obj.isBassemLabsFee = message.is_bassem_labs_fee;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvoiceItem>, I>>(base?: I): InvoiceItem {
    return InvoiceItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvoiceItem>, I>>(object: I): InvoiceItem {
    const message = createBaseInvoiceItem();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.price = object.price ?? 0;
    message.quantity = object.quantity ?? 0;
    message.is_bassem_labs_fee = object.is_bassem_labs_fee ?? false;
    return message;
  },
};

function createBaseCoupon(): Coupon {
  return { title: "", value_type: DiscountValueType.AMOUNT, value: 0 };
}

export const Coupon: MessageFns<Coupon> = {
  encode(message: Coupon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.value_type !== DiscountValueType.AMOUNT) {
      writer.uint32(16).int32(discountValueTypeToNumber(message.value_type));
    }
    if (message.value !== 0) {
      writer.uint32(25).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Coupon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoupon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value_type = discountValueTypeFromJSON(reader.int32());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Coupon {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      value_type: isSet(object.valueType) ? discountValueTypeFromJSON(object.valueType) : DiscountValueType.AMOUNT,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Coupon): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.value_type !== DiscountValueType.AMOUNT) {
      obj.valueType = discountValueTypeToJSON(message.value_type);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Coupon>, I>>(base?: I): Coupon {
    return Coupon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Coupon>, I>>(object: I): Coupon {
    const message = createBaseCoupon();
    message.title = object.title ?? "";
    message.value_type = object.value_type ?? DiscountValueType.AMOUNT;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseOrganizationInvoiceDetails(): OrganizationInvoiceDetails {
  return {
    period_start_date: undefined,
    period_end_date: undefined,
    number_of_students: 0,
    payment_plan_id: undefined,
    payment_plan_info_id: undefined,
  };
}

export const OrganizationInvoiceDetails: MessageFns<OrganizationInvoiceDetails> = {
  encode(message: OrganizationInvoiceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.period_start_date !== undefined) {
      Timestamp.encode(toTimestamp(message.period_start_date), writer.uint32(10).fork()).join();
    }
    if (message.period_end_date !== undefined) {
      Timestamp.encode(toTimestamp(message.period_end_date), writer.uint32(18).fork()).join();
    }
    if (message.number_of_students !== 0) {
      writer.uint32(24).uint32(message.number_of_students);
    }
    if (message.payment_plan_id !== undefined) {
      ObjectId.encode(message.payment_plan_id, writer.uint32(34).fork()).join();
    }
    if (message.payment_plan_info_id !== undefined) {
      ObjectId.encode(message.payment_plan_info_id, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationInvoiceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationInvoiceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.period_start_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.period_end_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.number_of_students = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payment_plan_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payment_plan_info_id = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationInvoiceDetails {
    return {
      period_start_date: isSet(object.periodStartDate) ? fromJsonTimestamp(object.periodStartDate) : undefined,
      period_end_date: isSet(object.periodEndDate) ? fromJsonTimestamp(object.periodEndDate) : undefined,
      number_of_students: isSet(object.numberOfStudents) ? globalThis.Number(object.numberOfStudents) : 0,
      payment_plan_id: isSet(object.paymentPlanId) ? ObjectId.fromJSON(object.paymentPlanId) : undefined,
      payment_plan_info_id: isSet(object.paymentPlanInfoId) ? ObjectId.fromJSON(object.paymentPlanInfoId) : undefined,
    };
  },

  toJSON(message: OrganizationInvoiceDetails): unknown {
    const obj: any = {};
    if (message.period_start_date !== undefined) {
      obj.periodStartDate = message.period_start_date.toISOString();
    }
    if (message.period_end_date !== undefined) {
      obj.periodEndDate = message.period_end_date.toISOString();
    }
    if (message.number_of_students !== 0) {
      obj.numberOfStudents = Math.round(message.number_of_students);
    }
    if (message.payment_plan_id !== undefined) {
      obj.paymentPlanId = ObjectId.toJSON(message.payment_plan_id);
    }
    if (message.payment_plan_info_id !== undefined) {
      obj.paymentPlanInfoId = ObjectId.toJSON(message.payment_plan_info_id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationInvoiceDetails>, I>>(base?: I): OrganizationInvoiceDetails {
    return OrganizationInvoiceDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationInvoiceDetails>, I>>(object: I): OrganizationInvoiceDetails {
    const message = createBaseOrganizationInvoiceDetails();
    message.period_start_date = object.period_start_date ?? undefined;
    message.period_end_date = object.period_end_date ?? undefined;
    message.number_of_students = object.number_of_students ?? 0;
    message.payment_plan_id = (object.payment_plan_id !== undefined && object.payment_plan_id !== null)
      ? ObjectId.fromPartial(object.payment_plan_id)
      : undefined;
    message.payment_plan_info_id = (object.payment_plan_info_id !== undefined && object.payment_plan_info_id !== null)
      ? ObjectId.fromPartial(object.payment_plan_info_id)
      : undefined;
    return message;
  },
};

function createBaseInvoice(): Invoice {
  return {
    id: undefined,
    organization: undefined,
    invoice_number: 0,
    title: "",
    description: "",
    show_hst: false,
    disable_tax: false,
    archived: false,
    user: undefined,
    family: undefined,
    items: [],
    coupons: [],
    due_date: undefined,
    invoice_student_registration_pipeline_status: StudentStatus.WAITLIST,
    school_year: undefined,
    auto_pay_enabled: false,
    charge_on_date: undefined,
    auto_payment_status: AutoPaymentStatus.AutoPayPending,
    is_tuition: false,
    organization_invoice_details: undefined,
    auto_payment_retry_count: 0,
    auto_payment_next_retry_at: undefined,
  };
}

export const Invoice: MessageFns<Invoice> = {
  encode(message: Invoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.invoice_number !== 0) {
      writer.uint32(24).int32(message.invoice_number);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.show_hst !== false) {
      writer.uint32(48).bool(message.show_hst);
    }
    if (message.disable_tax !== false) {
      writer.uint32(56).bool(message.disable_tax);
    }
    if (message.archived !== false) {
      writer.uint32(64).bool(message.archived);
    }
    if (message.user !== undefined) {
      ObjectId.encode(message.user, writer.uint32(74).fork()).join();
    }
    if (message.family !== undefined) {
      ObjectId.encode(message.family, writer.uint32(82).fork()).join();
    }
    for (const v of message.items) {
      InvoiceItem.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.coupons) {
      Coupon.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.due_date !== undefined) {
      Timestamp.encode(toTimestamp(message.due_date), writer.uint32(106).fork()).join();
    }
    if (
      message.invoice_student_registration_pipeline_status !== undefined &&
      message.invoice_student_registration_pipeline_status !== StudentStatus.WAITLIST
    ) {
      writer.uint32(112).int32(studentStatusToNumber(message.invoice_student_registration_pipeline_status));
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(122).fork()).join();
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      writer.uint32(128).bool(message.auto_pay_enabled);
    }
    if (message.charge_on_date !== undefined) {
      Timestamp.encode(toTimestamp(message.charge_on_date), writer.uint32(138).fork()).join();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(144).int32(autoPaymentStatusToNumber(message.auto_payment_status));
    }
    if (message.is_tuition !== false) {
      writer.uint32(152).bool(message.is_tuition);
    }
    if (message.organization_invoice_details !== undefined) {
      OrganizationInvoiceDetails.encode(message.organization_invoice_details, writer.uint32(162).fork()).join();
    }
    if (message.auto_payment_retry_count !== undefined && message.auto_payment_retry_count !== 0) {
      writer.uint32(168).int32(message.auto_payment_retry_count);
    }
    if (message.auto_payment_next_retry_at !== undefined) {
      Timestamp.encode(toTimestamp(message.auto_payment_next_retry_at), writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Invoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.invoice_number = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.show_hst = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.disable_tax = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.archived = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.user = ObjectId.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.family = ObjectId.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.items.push(InvoiceItem.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.coupons.push(Coupon.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.due_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.invoice_student_registration_pipeline_status = studentStatusFromJSON(reader.int32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.auto_pay_enabled = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.charge_on_date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.auto_payment_status = autoPaymentStatusFromJSON(reader.int32());
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.is_tuition = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.organization_invoice_details = OrganizationInvoiceDetails.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.auto_payment_retry_count = reader.int32();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.auto_payment_next_retry_at = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invoice {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      invoice_number: isSet(object.invoiceNumber) ? globalThis.Number(object.invoiceNumber) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      show_hst: isSet(object.showHst) ? globalThis.Boolean(object.showHst) : false,
      disable_tax: isSet(object.disableTax) ? globalThis.Boolean(object.disableTax) : false,
      archived: isSet(object.archived) ? globalThis.Boolean(object.archived) : false,
      user: isSet(object.user) ? ObjectId.fromJSON(object.user) : undefined,
      family: isSet(object.family) ? ObjectId.fromJSON(object.family) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => InvoiceItem.fromJSON(e)) : [],
      coupons: globalThis.Array.isArray(object?.coupons) ? object.coupons.map((e: any) => Coupon.fromJSON(e)) : [],
      due_date: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
      invoice_student_registration_pipeline_status: isSet(object.invoiceStudentRegistrationPipelineStatus)
        ? studentStatusFromJSON(object.invoiceStudentRegistrationPipelineStatus)
        : StudentStatus.WAITLIST,
      school_year: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
      auto_pay_enabled: isSet(object.autoPayEnabled) ? globalThis.Boolean(object.autoPayEnabled) : false,
      charge_on_date: isSet(object.chargeOnDate) ? fromJsonTimestamp(object.chargeOnDate) : undefined,
      auto_payment_status: isSet(object.autoPaymentStatus)
        ? autoPaymentStatusFromJSON(object.autoPaymentStatus)
        : AutoPaymentStatus.AutoPayPending,
      is_tuition: isSet(object.isTuition) ? globalThis.Boolean(object.isTuition) : false,
      organization_invoice_details: isSet(object.organizationInvoiceDetails)
        ? OrganizationInvoiceDetails.fromJSON(object.organizationInvoiceDetails)
        : undefined,
      auto_payment_retry_count: isSet(object.autoPaymentRetryCount)
        ? globalThis.Number(object.autoPaymentRetryCount)
        : 0,
      auto_payment_next_retry_at: isSet(object.autoPaymentNextRetryAt)
        ? fromJsonTimestamp(object.autoPaymentNextRetryAt)
        : undefined,
    };
  },

  toJSON(message: Invoice): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.invoice_number !== 0) {
      obj.invoiceNumber = Math.round(message.invoice_number);
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.show_hst !== false) {
      obj.showHst = message.show_hst;
    }
    if (message.disable_tax !== false) {
      obj.disableTax = message.disable_tax;
    }
    if (message.archived !== false) {
      obj.archived = message.archived;
    }
    if (message.user !== undefined) {
      obj.user = ObjectId.toJSON(message.user);
    }
    if (message.family !== undefined) {
      obj.family = ObjectId.toJSON(message.family);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => InvoiceItem.toJSON(e));
    }
    if (message.coupons?.length) {
      obj.coupons = message.coupons.map((e) => Coupon.toJSON(e));
    }
    if (message.due_date !== undefined) {
      obj.dueDate = message.due_date.toISOString();
    }
    if (
      message.invoice_student_registration_pipeline_status !== undefined &&
      message.invoice_student_registration_pipeline_status !== StudentStatus.WAITLIST
    ) {
      obj.invoiceStudentRegistrationPipelineStatus = studentStatusToJSON(
        message.invoice_student_registration_pipeline_status,
      );
    }
    if (message.school_year !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.school_year);
    }
    if (message.auto_pay_enabled !== undefined && message.auto_pay_enabled !== false) {
      obj.autoPayEnabled = message.auto_pay_enabled;
    }
    if (message.charge_on_date !== undefined) {
      obj.chargeOnDate = message.charge_on_date.toISOString();
    }
    if (message.auto_payment_status !== undefined && message.auto_payment_status !== AutoPaymentStatus.AutoPayPending) {
      obj.autoPaymentStatus = autoPaymentStatusToJSON(message.auto_payment_status);
    }
    if (message.is_tuition !== false) {
      obj.isTuition = message.is_tuition;
    }
    if (message.organization_invoice_details !== undefined) {
      obj.organizationInvoiceDetails = OrganizationInvoiceDetails.toJSON(message.organization_invoice_details);
    }
    if (message.auto_payment_retry_count !== undefined && message.auto_payment_retry_count !== 0) {
      obj.autoPaymentRetryCount = Math.round(message.auto_payment_retry_count);
    }
    if (message.auto_payment_next_retry_at !== undefined) {
      obj.autoPaymentNextRetryAt = message.auto_payment_next_retry_at.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Invoice>, I>>(base?: I): Invoice {
    return Invoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Invoice>, I>>(object: I): Invoice {
    const message = createBaseInvoice();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.invoice_number = object.invoice_number ?? 0;
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.show_hst = object.show_hst ?? false;
    message.disable_tax = object.disable_tax ?? false;
    message.archived = object.archived ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? ObjectId.fromPartial(object.user) : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? ObjectId.fromPartial(object.family)
      : undefined;
    message.items = object.items?.map((e) => InvoiceItem.fromPartial(e)) || [];
    message.coupons = object.coupons?.map((e) => Coupon.fromPartial(e)) || [];
    message.due_date = object.due_date ?? undefined;
    message.invoice_student_registration_pipeline_status = object.invoice_student_registration_pipeline_status ??
      StudentStatus.WAITLIST;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    message.auto_pay_enabled = object.auto_pay_enabled ?? false;
    message.charge_on_date = object.charge_on_date ?? undefined;
    message.auto_payment_status = object.auto_payment_status ?? AutoPaymentStatus.AutoPayPending;
    message.is_tuition = object.is_tuition ?? false;
    message.organization_invoice_details =
      (object.organization_invoice_details !== undefined && object.organization_invoice_details !== null)
        ? OrganizationInvoiceDetails.fromPartial(object.organization_invoice_details)
        : undefined;
    message.auto_payment_retry_count = object.auto_payment_retry_count ?? 0;
    message.auto_payment_next_retry_at = object.auto_payment_next_retry_at ?? undefined;
    return message;
  },
};

function createBaseInvoiceResponse(): InvoiceResponse {
  return {
    invoice: undefined,
    transactions: [],
    total_amount: 0,
    gross_amount_paid: 0,
    status: InvoiceStatus.Paid,
    bill_to_name: "",
    refund_transactions: [],
    total_amount_refunded: 0,
    net_amount_paid: 0,
  };
}

export const InvoiceResponse: MessageFns<InvoiceResponse> = {
  encode(message: InvoiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.invoice !== undefined) {
      Invoice.encode(message.invoice, writer.uint32(10).fork()).join();
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.total_amount !== 0) {
      writer.uint32(25).double(message.total_amount);
    }
    if (message.gross_amount_paid !== 0) {
      writer.uint32(33).double(message.gross_amount_paid);
    }
    if (message.status !== InvoiceStatus.Paid) {
      writer.uint32(40).int32(invoiceStatusToNumber(message.status));
    }
    if (message.bill_to_name !== undefined && message.bill_to_name !== "") {
      writer.uint32(50).string(message.bill_to_name);
    }
    for (const v of message.refund_transactions) {
      RefundTransaction.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.total_amount_refunded !== 0) {
      writer.uint32(65).double(message.total_amount_refunded);
    }
    if (message.net_amount_paid !== 0) {
      writer.uint32(73).double(message.net_amount_paid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.invoice = Invoice.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.total_amount = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.gross_amount_paid = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = invoiceStatusFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bill_to_name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.refund_transactions.push(RefundTransaction.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.total_amount_refunded = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.net_amount_paid = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceResponse {
    return {
      invoice: isSet(object.invoice) ? Invoice.fromJSON(object.invoice) : undefined,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      total_amount: isSet(object.totalAmount) ? globalThis.Number(object.totalAmount) : 0,
      gross_amount_paid: isSet(object.grossAmountPaid) ? globalThis.Number(object.grossAmountPaid) : 0,
      status: isSet(object.status) ? invoiceStatusFromJSON(object.status) : InvoiceStatus.Paid,
      bill_to_name: isSet(object.billToName) ? globalThis.String(object.billToName) : "",
      refund_transactions: globalThis.Array.isArray(object?.refundTransactions)
        ? object.refundTransactions.map((e: any) => RefundTransaction.fromJSON(e))
        : [],
      total_amount_refunded: isSet(object.totalAmountRefunded) ? globalThis.Number(object.totalAmountRefunded) : 0,
      net_amount_paid: isSet(object.netAmountPaid) ? globalThis.Number(object.netAmountPaid) : 0,
    };
  },

  toJSON(message: InvoiceResponse): unknown {
    const obj: any = {};
    if (message.invoice !== undefined) {
      obj.invoice = Invoice.toJSON(message.invoice);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.total_amount !== 0) {
      obj.totalAmount = message.total_amount;
    }
    if (message.gross_amount_paid !== 0) {
      obj.grossAmountPaid = message.gross_amount_paid;
    }
    if (message.status !== InvoiceStatus.Paid) {
      obj.status = invoiceStatusToJSON(message.status);
    }
    if (message.bill_to_name !== undefined && message.bill_to_name !== "") {
      obj.billToName = message.bill_to_name;
    }
    if (message.refund_transactions?.length) {
      obj.refundTransactions = message.refund_transactions.map((e) => RefundTransaction.toJSON(e));
    }
    if (message.total_amount_refunded !== 0) {
      obj.totalAmountRefunded = message.total_amount_refunded;
    }
    if (message.net_amount_paid !== 0) {
      obj.netAmountPaid = message.net_amount_paid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvoiceResponse>, I>>(base?: I): InvoiceResponse {
    return InvoiceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvoiceResponse>, I>>(object: I): InvoiceResponse {
    const message = createBaseInvoiceResponse();
    message.invoice = (object.invoice !== undefined && object.invoice !== null)
      ? Invoice.fromPartial(object.invoice)
      : undefined;
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.total_amount = object.total_amount ?? 0;
    message.gross_amount_paid = object.gross_amount_paid ?? 0;
    message.status = object.status ?? InvoiceStatus.Paid;
    message.bill_to_name = object.bill_to_name ?? "";
    message.refund_transactions = object.refund_transactions?.map((e) => RefundTransaction.fromPartial(e)) || [];
    message.total_amount_refunded = object.total_amount_refunded ?? 0;
    message.net_amount_paid = object.net_amount_paid ?? 0;
    return message;
  },
};

function createBaseInvoiceFilter(): InvoiceFilter {
  return {
    per_page: 0,
    page: 0,
    title: "",
    status: InvoiceStatus.Paid,
    archived: false,
    user: undefined,
    family: undefined,
    school_year: undefined,
  };
}

export const InvoiceFilter: MessageFns<InvoiceFilter> = {
  encode(message: InvoiceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.per_page !== undefined && message.per_page !== 0) {
      writer.uint32(8).int32(message.per_page);
    }
    if (message.page !== undefined && message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.title !== undefined && message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.status !== undefined && message.status !== InvoiceStatus.Paid) {
      writer.uint32(32).int32(invoiceStatusToNumber(message.status));
    }
    if (message.archived !== undefined && message.archived !== false) {
      writer.uint32(40).bool(message.archived);
    }
    if (message.user !== undefined) {
      ObjectId.encode(message.user, writer.uint32(50).fork()).join();
    }
    if (message.family !== undefined) {
      ObjectId.encode(message.family, writer.uint32(58).fork()).join();
    }
    if (message.school_year !== undefined) {
      ObjectId.encode(message.school_year, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvoiceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvoiceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.per_page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = invoiceStatusFromJSON(reader.int32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.archived = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.user = ObjectId.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.family = ObjectId.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.school_year = ObjectId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvoiceFilter {
    return {
      per_page: isSet(object.perPage) ? globalThis.Number(object.perPage) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      status: isSet(object.status) ? invoiceStatusFromJSON(object.status) : InvoiceStatus.Paid,
      archived: isSet(object.archived) ? globalThis.Boolean(object.archived) : false,
      user: isSet(object.user) ? ObjectId.fromJSON(object.user) : undefined,
      family: isSet(object.family) ? ObjectId.fromJSON(object.family) : undefined,
      school_year: isSet(object.schoolYear) ? ObjectId.fromJSON(object.schoolYear) : undefined,
    };
  },

  toJSON(message: InvoiceFilter): unknown {
    const obj: any = {};
    if (message.per_page !== undefined && message.per_page !== 0) {
      obj.perPage = Math.round(message.per_page);
    }
    if (message.page !== undefined && message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.title !== undefined && message.title !== "") {
      obj.title = message.title;
    }
    if (message.status !== undefined && message.status !== InvoiceStatus.Paid) {
      obj.status = invoiceStatusToJSON(message.status);
    }
    if (message.archived !== undefined && message.archived !== false) {
      obj.archived = message.archived;
    }
    if (message.user !== undefined) {
      obj.user = ObjectId.toJSON(message.user);
    }
    if (message.family !== undefined) {
      obj.family = ObjectId.toJSON(message.family);
    }
    if (message.school_year !== undefined) {
      obj.schoolYear = ObjectId.toJSON(message.school_year);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvoiceFilter>, I>>(base?: I): InvoiceFilter {
    return InvoiceFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvoiceFilter>, I>>(object: I): InvoiceFilter {
    const message = createBaseInvoiceFilter();
    message.per_page = object.per_page ?? 0;
    message.page = object.page ?? 0;
    message.title = object.title ?? "";
    message.status = object.status ?? InvoiceStatus.Paid;
    message.archived = object.archived ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? ObjectId.fromPartial(object.user) : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? ObjectId.fromPartial(object.family)
      : undefined;
    message.school_year = (object.school_year !== undefined && object.school_year !== null)
      ? ObjectId.fromPartial(object.school_year)
      : undefined;
    return message;
  },
};

function createBaseAutoPaymentAttempt(): AutoPaymentAttempt {
  return {
    id: undefined,
    organization: undefined,
    invoice_id: undefined,
    attempted_at: undefined,
    status: AutoPaymentStatus.AutoPayPending,
    error_message: "",
    attempt_number: 0,
  };
}

export const AutoPaymentAttempt: MessageFns<AutoPaymentAttempt> = {
  encode(message: AutoPaymentAttempt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ObjectId.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.organization !== undefined) {
      ObjectId.encode(message.organization, writer.uint32(18).fork()).join();
    }
    if (message.invoice_id !== undefined) {
      ObjectId.encode(message.invoice_id, writer.uint32(26).fork()).join();
    }
    if (message.attempted_at !== undefined) {
      Timestamp.encode(toTimestamp(message.attempted_at), writer.uint32(34).fork()).join();
    }
    if (message.status !== AutoPaymentStatus.AutoPayPending) {
      writer.uint32(40).int32(autoPaymentStatusToNumber(message.status));
    }
    if (message.error_message !== undefined && message.error_message !== "") {
      writer.uint32(50).string(message.error_message);
    }
    if (message.attempt_number !== 0) {
      writer.uint32(56).int32(message.attempt_number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoPaymentAttempt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoPaymentAttempt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = ObjectId.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invoice_id = ObjectId.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attempted_at = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = autoPaymentStatusFromJSON(reader.int32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.error_message = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.attempt_number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoPaymentAttempt {
    return {
      id: isSet(object.id) ? ObjectId.fromJSON(object.id) : undefined,
      organization: isSet(object.organization) ? ObjectId.fromJSON(object.organization) : undefined,
      invoice_id: isSet(object.invoiceId) ? ObjectId.fromJSON(object.invoiceId) : undefined,
      attempted_at: isSet(object.attemptedAt) ? fromJsonTimestamp(object.attemptedAt) : undefined,
      status: isSet(object.status) ? autoPaymentStatusFromJSON(object.status) : AutoPaymentStatus.AutoPayPending,
      error_message: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      attempt_number: isSet(object.attemptNumber) ? globalThis.Number(object.attemptNumber) : 0,
    };
  },

  toJSON(message: AutoPaymentAttempt): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ObjectId.toJSON(message.id);
    }
    if (message.organization !== undefined) {
      obj.organization = ObjectId.toJSON(message.organization);
    }
    if (message.invoice_id !== undefined) {
      obj.invoiceId = ObjectId.toJSON(message.invoice_id);
    }
    if (message.attempted_at !== undefined) {
      obj.attemptedAt = message.attempted_at.toISOString();
    }
    if (message.status !== AutoPaymentStatus.AutoPayPending) {
      obj.status = autoPaymentStatusToJSON(message.status);
    }
    if (message.error_message !== undefined && message.error_message !== "") {
      obj.errorMessage = message.error_message;
    }
    if (message.attempt_number !== 0) {
      obj.attemptNumber = Math.round(message.attempt_number);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AutoPaymentAttempt>, I>>(base?: I): AutoPaymentAttempt {
    return AutoPaymentAttempt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AutoPaymentAttempt>, I>>(object: I): AutoPaymentAttempt {
    const message = createBaseAutoPaymentAttempt();
    message.id = (object.id !== undefined && object.id !== null) ? ObjectId.fromPartial(object.id) : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? ObjectId.fromPartial(object.organization)
      : undefined;
    message.invoice_id = (object.invoice_id !== undefined && object.invoice_id !== null)
      ? ObjectId.fromPartial(object.invoice_id)
      : undefined;
    message.attempted_at = object.attempted_at ?? undefined;
    message.status = object.status ?? AutoPaymentStatus.AutoPayPending;
    message.error_message = object.error_message ?? "";
    message.attempt_number = object.attempt_number ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
